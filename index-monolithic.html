<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#65D46E">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Upkeep - Track the true state of your chores</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="manifest" href="/manifest.json">
    <style>
        @font-face {
            font-family: 'Cocogoose';
            src: url('Font/cocogoose/Cocogoose-Condensed/Cocogoose-Condensed-Regular-trial.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'Sassy Raccoon';
            src: url('Font/sassy-raccoon-font/SassyRaccoon-zrXKl.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #65D46E;
            --primary-dark: #4CAF50;
            --success: #65D46E;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg: #E9F5E9;
            --surface: #ffffff;
            --text: #333333;
            --text-secondary: #666666;
            --border: #e2e8f0;
            --shadow: 0 4px 10px rgba(0,0,0,0.05);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        .app {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            background: transparent;
            position: relative;
            padding-bottom: 80px;
        }

        .header {
            background: transparent;
            color: var(--text);
            padding: 16px 20px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            max-width: 480px;
            margin: 0 auto;
        }

        #categoryView .header {
            position: sticky;
            background: transparent;
        }
        #categoryView .header h1 {
            font-family: 'Sassy Raccoon', cursive;
            font-size: 32px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            display: inline-block;
            line-height: 0;
            transition: transform 0.2s;
        }
        .back-btn:hover {
            transform: scale(1.1);
        }
        .back-btn img {
            width: 50px;
            height: 50px;
            display: block;
            pointer-events: none;
        }
        .back-btn:active {
            transform: scale(0.95);
        }
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }
        .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            transition: transform 0.2s;
            line-height: 0;
        }
        .close-btn:hover {
            transform: scale(1.1);
        }
        .close-btn img {
            width: 42px;
            height: 42px;
            display: block;
            pointer-events: none;
        }
        .close-btn:active {
            transform: scale(0.95);
        }
        .edit-btn-img {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            display: inline-block;
            transition: transform 0.2s;
            line-height: 0;
        }
        .edit-btn-img:hover {
            transform: scale(1.1);
        }
        .edit-btn-img img {
            width: 50px;
            height: 50px;
            display: block;
            pointer-events: none;
        }
        .edit-btn-img:active {
            transform: scale(0.95);
        }
        .icon-btn:active { background: rgba(0,0,0,0.1); }

        h1 { 
            font-size: 24px; 
            font-weight: 700; 
            margin-bottom: 4px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .app-logo {
            width: 234px;
            height: auto;
            margin-bottom: 10px;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
            position: relative;
            z-index: 10;
        }
        .tagline { 
            font-size: 14px; 
            opacity: 0.9; 
            font-weight: 400;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .content-top {
            padding: -10px 20px 3px;
            text-align: center;
        }

        .content-bottom {
            background: transparent;
            padding: 20px;
            min-height: 40vh;
        }
        
        #categoryView .content {
            padding: 20px;
            background: transparent;
            min-height: calc(100vh - 70px);
        }

        .score-card { margin-bottom: 24px; margin-top: -5px; }
        .save-file-name {
            font-family: 'Cocogoose', 'Inter', sans-serif;
            font-size: 20px;
            color: var(--text);
            text-align: center;
            margin-bottom: 12px;
            font-weight: normal;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }
        .score-label {
            font-size: 14px;
            color: var(--text);
            opacity: 0.8;
            margin-bottom: 8px;
            font-weight: 500;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .progress-bar {
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.05);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
        }

        .score-value-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, #a8e0ab 100%);
            border-radius: 20px;
            transition: width 0.5s ease, background 0.5s ease;
        }
        .progress-fill.warning { background: linear-gradient(90deg, var(--warning) 0%, #fde08a 100%); }
        .progress-fill.danger { background: linear-gradient(90deg, var(--danger) 0%, #fca5a5 100%); }

        .mascot-container {
            position: relative;
            height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }
        .mascot-container-global {
            position: fixed;
            top: 80px;
            right: 15px;
            width: 100px;
            z-index: 1001;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .mascot-container-global.dodging {
            transition: transform 0.2s ease-out;
        }
        .mascot-container-global .mascot-image {
            pointer-events: all;
            cursor: pointer;
        }
        .mascot-image {
            width: 100px;
            height: auto;
            animation: float 6s ease-in-out infinite;
        }
        .mascot-image[src*="MAD"] {
            width: 65px;
            height: auto;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(10px); }
            100% { transform: translateY(0px); }
        }
        .speech-bubble {
            position: absolute;
            bottom: 20px;
            right: 110px;
            width: 200px;
            background: var(--surface);
            color: var(--text);
            padding: 12px 16px;
            border-radius: 15px;
            font-size: 13px;
            box-shadow: var(--shadow-lg);
            text-align: left;
            opacity: 0;
            transform: translateX(10px) scale(0.9);
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform-origin: right center;
            pointer-events: all;
        }
        .speech-bubble.visible {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
        .speech-bubble::before {
            content: '';
            position: absolute;
            right: -8px;
            bottom: 30px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 8px solid var(--surface);
        }
        .thought-bubble {
            position: absolute;
            bottom: 20px;
            right: 110px;
            width: 180px;
            background: var(--surface);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: var(--shadow-lg);
            text-align: left;
            opacity: 0;
            font-style: italic;
            transform: translateX(10px) scale(0.9);
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform-origin: right center;
            pointer-events: all;
        }
        .thought-bubble.visible {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
        .thought-bubble::before {
            content: '';
            position: absolute;
            right: 5px;
            bottom: -15px;
            width: 12px;
            height: 12px;
            background: var(--surface);
            border-radius: 50%;
            box-shadow: var(--shadow);
        }
        .thought-bubble::after {
            content: '';
            position: absolute;
            right: 15px;
            bottom: -8px;
            width: 8px;
            height: 8px;
            background: var(--surface);
            border-radius: 50%;
            box-shadow: var(--shadow);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .section-title { 
            font-family: 'Sassy Raccoon', cursive;
            font-size: 24px; 
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .category-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }
        .category-card {
            border-radius: 20px;
            padding: 16px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: transform 0.2s, filter 0.5s ease;
            color: white;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }
        .category-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            z-index: 1;
            transition: background 0.5s ease;
        }
        .category-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 30%, rgba(120, 120, 120, 0.15) 0%, transparent 40%),
                        radial-gradient(circle at 70% 70%, rgba(100, 100, 100, 0.15) 0%, transparent 40%),
                        radial-gradient(circle at 50% 80%, rgba(110, 110, 110, 0.12) 0%, transparent 35%);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            border-radius: 20px;
            transition: opacity 0.5s ease;
        }
        .category-card.dusty-light::after {
            opacity: 0.4;
        }
        .category-card.dusty-light::before {
            background: rgba(0, 0, 0, 0.25);
        }
        .category-card.dusty-medium::after {
            opacity: 0.6;
            background: radial-gradient(circle at 30% 30%, rgba(120, 120, 120, 0.2) 0%, transparent 40%),
                        radial-gradient(circle at 70% 70%, rgba(100, 100, 100, 0.2) 0%, transparent 40%),
                        radial-gradient(circle at 50% 80%, rgba(110, 110, 110, 0.18) 0%, transparent 35%),
                        radial-gradient(circle at 20% 60%, rgba(95, 95, 95, 0.15) 0%, transparent 30%);
        }
        .category-card.dusty-medium::before {
            background: rgba(0, 0, 0, 0.3);
        }
        .category-card.dusty-heavy::after {
            opacity: 0.8;
            background: radial-gradient(circle at 30% 30%, rgba(120, 120, 120, 0.25) 0%, transparent 40%),
                        radial-gradient(circle at 70% 70%, rgba(100, 100, 100, 0.25) 0%, transparent 40%),
                        radial-gradient(circle at 50% 80%, rgba(110, 110, 110, 0.22) 0%, transparent 35%),
                        radial-gradient(circle at 20% 60%, rgba(95, 95, 95, 0.2) 0%, transparent 30%),
                        radial-gradient(circle at 80% 40%, rgba(105, 105, 105, 0.18) 0%, transparent 35%);
        }
        .category-card.dusty-heavy::before {
            background: rgba(0, 0, 0, 0.35);
        }
        .category-card.dusty-heavy {
            filter: saturate(0.85) brightness(0.95);
        }
        .category-card > * {
            position: relative;
            z-index: 3;
        }
        .category-card:active { transform: scale(0.98); }
        
        .dust-bunny {
            position: absolute;
            width: 30px;
            height: 30px;
            background-image: url('Imag/DUST BUNNY.png');
            background-size: contain;
            background-repeat: no-repeat;
            pointer-events: none;
            z-index: 2;
            opacity: 0.7;
        }
        
        .dust-bunny.hop1 {
            bottom: 10%;
            left: 15%;
            animation: hop1 3s ease-in-out infinite;
        }
        .dust-bunny.hop2 {
            bottom: 20%;
            right: 20%;
            animation: hop2 3.5s ease-in-out infinite 0.5s;
        }
        .dust-bunny.hop3 {
            top: 15%;
            left: 25%;
            animation: hop3 4s ease-in-out infinite 1s;
        }
        .dust-bunny.hop4 {
            top: 25%;
            right: 15%;
            animation: hop4 3.2s ease-in-out infinite 1.5s;
        }
        .dust-bunny.hop5 {
            bottom: 30%;
            left: 50%;
            animation: hop5 3.8s ease-in-out infinite 0.8s;
        }
        
        @keyframes hop1 {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-15px) translateX(5px); }
            50% { transform: translateY(0) translateX(10px); }
            75% { transform: translateY(-12px) translateX(5px); }
        }
        @keyframes hop2 {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-18px) translateX(-8px); }
            50% { transform: translateY(0) translateX(-5px); }
            75% { transform: translateY(-15px) translateX(-3px); }
        }
        @keyframes hop3 {
            0%, 100% { transform: translateY(0) translateX(0); }
            30% { transform: translateY(-20px) translateX(10px); }
            60% { transform: translateY(0) translateX(15px); }
            80% { transform: translateY(-10px) translateX(8px); }
        }
        @keyframes hop4 {
            0%, 100% { transform: translateY(0) translateX(0); }
            20% { transform: translateY(-16px) translateX(-6px); }
            50% { transform: translateY(0) translateX(-12px); }
            70% { transform: translateY(-14px) translateX(-8px); }
        }
        @keyframes hop5 {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-22px) translateX(-10px); }
            50% { transform: translateY(0) translateX(8px); }
            75% { transform: translateY(-18px) translateX(-5px); }
        }
        .category-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .category-name { 
            font-size: 16px; 
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }
        .category-score { 
            font-size: 14px; 
            font-weight: 600; 
            opacity: 0.9;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }
        .category-progress .progress-bar {
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        .category-progress .progress-fill {
            background: white;
            border-radius: 4px;
        }

        .task-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .task-card {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 16px;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }
        .task-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 20%, rgba(100, 100, 100, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(80, 80, 80, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 50% 50%, rgba(90, 90, 90, 0.05) 0%, transparent 60%);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            border-radius: 16px;
        }
        .task-card.dusty-light::before {
            opacity: 0.3;
        }
        .task-card.dusty-medium::before {
            opacity: 0.5;
            background: radial-gradient(circle at 20% 20%, rgba(100, 100, 100, 0.15) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(80, 80, 80, 0.15) 0%, transparent 50%),
                        radial-gradient(circle at 50% 50%, rgba(90, 90, 90, 0.1) 0%, transparent 60%),
                        radial-gradient(circle at 30% 70%, rgba(70, 70, 70, 0.1) 0%, transparent 40%);
        }
        .task-card.dusty-heavy::before {
            opacity: 0.7;
            background: radial-gradient(circle at 20% 20%, rgba(100, 100, 100, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(80, 80, 80, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 50% 50%, rgba(90, 90, 90, 0.15) 0%, transparent 60%),
                        radial-gradient(circle at 30% 70%, rgba(70, 70, 70, 0.15) 0%, transparent 40%),
                        radial-gradient(circle at 70% 30%, rgba(85, 85, 85, 0.12) 0%, transparent 45%);
        }
        .task-header {
            position: relative;
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            padding-right: 80px;
        }
        .task-actions {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 8px;
        }
        .checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .checkbox svg {
            width: 16px;
            height: 16px;
            color: white;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s;
        }
        .checkbox.checked {
            background: var(--success);
            border-color: var(--success);
        }
        .checkbox.checked svg {
            opacity: 1;
            transform: scale(1);
        }
        .task-info { flex: 1; }
        .task-name { 
            font-family: 'Sassy Raccoon', cursive;
            font-size: 18px; 
            font-weight: 500; 
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }
        .task-meta { 
            font-size: 12px; 
            color: var(--text-secondary);
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }
        .task-action-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            position: relative;
            z-index: 100;
        }
        .task-action-btn svg { width: 20px; height: 20px; }
        .task-snooze-btn {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            transition: transform 0.2s;
            display: inline-block;
            line-height: 0;
            position: relative;
            z-index: 100;
        }
        .task-snooze-btn:hover {
            transform: scale(1.1);
        }
        .task-snooze-btn:active {
            transform: scale(0.95);
        }
        .task-resume-btn {
            width: 100%;
            padding: 12px 16px;
            background: linear-gradient(135deg, #65D46E, #93E198) !important;
            color: white !important;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(101, 212, 110, 0.6) !important;
            transition: all 0.2s;
            position: relative;
            z-index: 100;
            opacity: 1 !important;
        }
        .task-resume-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 6px rgba(101, 212, 110, 0.6) !important;
        }
        .task-snoozed {
            position: relative;
        }
        .task-snoozed > *:not(.task-resume-btn):not(div:has(.task-resume-btn)) {
            opacity: 0.6;
        }
        .task-snoozed::after {
            content: '💤 Snoozed';
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(245, 158, 11, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            z-index: 1;
            pointer-events: none;
        }
        .freshness-meter { margin-top: 8px; }
        .freshness-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .fab {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            z-index: 100;
            display: inline-block;
            line-height: 0;
            transition: transform 0.2s;
        }
        .fab:hover {
            transform: translateX(-50%) scale(1.1);
        }
        .fab img {
            width: 80px;
            height: 80px;
            display: block;
            pointer-events: none;
        }
        .fab:active {
            transform: translateX(-50%) scale(0.95);
        }
        .logbook-bubble {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 56px;
            height: 56px;
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.2s;
        }
        .logbook-bubble.hidden {
            display: none;
        }
        .logbook-bubble:active {
            transform: scale(0.95);
        }
        .logbook-bubble img {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
        }
        .settings-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            display: inline-block;
            line-height: 0;
            transition: transform 0.2s;
            z-index: 100;
        }
        .settings-btn.hidden {
            display: none;
        }
        .settings-btn:hover {
            transform: scale(1.1);
        }
        .settings-btn img {
            width: 60px;
            height: 60px;
            display: block;
            pointer-events: none;
        }
        .settings-btn:active {
            transform: scale(0.95);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: flex-end;
            z-index: 1000;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: transparent;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px 20px 0 0;
            padding: 24px;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.2);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .modal-title { 
            font-size: 20px; 
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        .form-group { margin-bottom: 20px; }
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }
        .form-input {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--text);
            font-weight: 500;
        }
        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.5);
        }
        .form-input::placeholder {
            color: rgba(51, 51, 51, 0.7);
            font-weight: 400;
        }
        .form-select {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--text);
            font-weight: 500;
        }
        .time-unit-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
        }
        .btn-primary {
            width: 100%;
            padding: 14px;
            background: rgba(101, 212, 110, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            z-index: 100;
        }
        .btn-primary:active { 
            background: rgba(76, 175, 80, 0.9);
        }
        .btn-danger {
            width: 100%;
            padding: 14px;
            background: rgba(239, 68, 68, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 12px;
        }
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        .empty-text { 
            font-size: 16px;
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }
        .hidden { display: none !important; }
        .view { display: none; }
        .view.active { display: block; }
        
        .settings-card {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        .settings-card-title {
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
            color: var(--text);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        .settings-card-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        .btn-save {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(101, 212, 110, 0.3);
            transition: all 0.2s;
        }
        .btn-save:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(101, 212, 110, 0.3);
        }
        .btn-load {
            width: 100%;
            padding: 16px;
            background: rgba(101, 212, 110, 0.2);
            color: var(--text);
            border: 2px solid rgba(101, 212, 110, 0.4);
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-load:active {
            transform: scale(0.98);
        }
        .save-load-img-btn {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            transition: transform 0.2s;
            display: inline-block;
            line-height: 0;
        }
        .save-load-img-btn img {
            width: 120px;
            height: 120px;
            display: block;
            pointer-events: none;
        }
        .save-load-img-btn:active {
            transform: scale(0.95);
        }
        .backup-btn-large {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            transition: transform 0.2s;
            display: inline-block;
            line-height: 0;
        }
        .backup-btn-large img {
            width: 100px;
            height: 100px;
            display: block;
            pointer-events: none;
        }
        .backup-btn-large:active {
            transform: scale(0.95);
        }
        .file-select-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1100;
        }
        .file-select-modal.active { display: flex; }
        .file-select-content {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        .file-select-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .file-item {
            background: rgba(101, 212, 110, 0.1);
            text-align: center;
            color: var(--text);
        }
        .file-item:hover {
            background: rgba(101, 212, 110, 0.2);
            border-color: rgba(101, 212, 110, 0.5);
        }
        .file-item:active {
            transform: scale(0.98);
        }
        .file-item.current {
            background: rgba(101, 212, 110, 0.3);
            border-color: var(--primary);
        }
        .file-item-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 4px;
        }
        .file-item-date {
            font-size: 12px;
            color: var(--text-secondary);
        }
        .file-item-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .file-item-btn {
            flex: 1;
            padding: 6px 12px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .file-item-btn.export {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }
        .file-item-btn.delete {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        .file-item-btn:active {
            transform: scale(0.95);
        }
        .new-file-input {
            width: 100%;
            padding: 16px;
            border: 2px solid rgba(101, 212, 110, 0.4);
            border-radius: 12px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.8);
            color: var(--text);
            margin-bottom: 12px;
        }
        .new-file-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        .voice-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            margin-bottom: 16px;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active {
            background: var(--primary);
        }
        .toggle-switch-handle {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.active .toggle-switch-handle {
            transform: translateX(22px);
        }
        
        .snooze-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .snooze-modal.active { display: flex; }
        .snooze-modal-content {
            background: white;
            border-radius: 24px;
            padding: 32px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .snooze-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .snooze-icon svg {
            width: 32px;
            height: 32px;
            color: white;
        }
        .snooze-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 24px;
        }
        .snooze-label {
            font-size: 14px;
            color: var(--text-secondary);
            text-align: left;
            margin-bottom: 12px;
            font-weight: 500;
        }
        .snooze-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
        }
        .snooze-input {
            width: 80px;
            flex-shrink: 0;
            padding: 14px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 16px;
            color: var(--text);
            font-weight: 500;
            text-align: center;
        }
        .snooze-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        .snooze-unit-select {
            flex: 1;
            padding: 14px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 16px;
            color: var(--text);
            background: white;
            cursor: pointer;
            font-weight: 500;
        }
        .snooze-unit-select:focus {
            outline: none;
            border-color: var(--primary);
        }
        .snooze-buttons {
            display: flex;
            gap: 12px;
        }
        .snooze-cancel-btn {
            flex: 1;
            padding: 14px;
            background: #f3f4f6;
            color: var(--text);
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .snooze-cancel-btn:active {
            transform: scale(0.98);
            background: #e5e7eb;
        }
        .snooze-confirm-btn {
            flex: 1;
            padding: 14px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(101, 212, 110, 0.4);
            transition: all 0.2s;
        }
        .snooze-confirm-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 6px rgba(101, 212, 110, 0.4);
        }
        
        .logbook-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }
        .logbook-modal.active { display: flex; }
        .logbook-content {
            background: white;
            border-radius: 24px;
            width: 100%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        .logbook-header {
            background: linear-gradient(135deg, #93E198, #65D46E);
            padding: 24px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .logbook-icon {
            width: 56px;
            height: 56px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .logbook-icon img {
            width: 36px;
            height: 36px;
        }
        .logbook-title {
            flex: 1;
        }
        .logbook-title h2 {
            margin: 0;
            font-size: 22px;
            font-weight: 700;
            color: white;
        }
        .logbook-close {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .logbook-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .logbook-date-group {
            margin-bottom: 24px;
        }
        .logbook-date-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .logbook-entry {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(101, 212, 110, 0.05);
            border-radius: 12px;
        }
        .logbook-entry-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
        }
        .logbook-entry-content {
            flex: 1;
        }
        .logbook-entry-title {
            font-size: 15px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 4px;
        }
        .logbook-entry-desc {
            font-size: 13px;
            color: var(--text-secondary);
        }
        .logbook-footer {
            padding: 16px 24px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 12px;
        }
        .logbook-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .logbook-btn-clear {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }
        .logbook-btn-close {
            background: #f3f4f6;
            color: var(--text);
        }
        .logbook-btn:active {
            transform: scale(0.98);
        }
        .logbook-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        /* Robot Select Bubble */
        .robot-select-bubble {
            position: fixed;
            bottom: 30px;
            right: 20px;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 999;
        }
        .robot-select-bubble:hover {
            transform: scale(1.05);
        }
        .robot-select-bubble:active {
            transform: scale(0.95);
        }
        .robot-select-bubble img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .robot-select-bubble.hidden {
            display: none;
        }
        
        /* Robot Select Modal */
        .robot-select-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }
        .robot-select-modal.active {
            display: flex;
        }
        .robot-select-content {
            background: #A8D5D5;
            border-radius: 30px;
            width: 100%;
            max-width: 900px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            border: none;
        }
        .robot-select-header {
            background: transparent;
            padding: 24px 24px 16px;
            text-align: center;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .robot-select-logo {
            height: 120px;
            width: auto;
            max-width: 90%;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
        }
        .robot-select-close {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .robot-select-close:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: rotate(90deg);
        }
        .robot-select-close:active {
            transform: scale(0.9) rotate(90deg);
        }
        
        /* Robot Select Body */
        .robot-select-body {
            padding: 20px;
            flex: 1;
            background: transparent;
            position: relative;
            height: 400px;
            overflow: hidden;
        }
        .robot-select-container {
            position: relative;
            height: 100%;
        }
        .robot-select-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            overflow-x: auto;
            scroll-behavior: smooth;
            touch-action: pan-x;
            height: 100%;
            padding-bottom: 30px;
        }
        .robot-select-row {
            display: flex;
            gap: 15px;
            padding: 5px;
            min-width: max-content;
            height: 180px;
            align-items: center;
        }
        .robot-select-grid::-webkit-scrollbar {
            height: 14px;
        }
        .robot-select-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 7px;
            margin: 0 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .robot-select-grid::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #65D46E, #93E198);
            border-radius: 7px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background-clip: padding-box;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .robot-select-grid::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #5bc462, #87d58c);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        .robot-select-grid::-webkit-scrollbar-corner {
            background: transparent;
        }
        .robot-select-scroll-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            overflow-x: auto;
            scroll-behavior: smooth;
            z-index: 10;
        }
        .robot-select-scroll-container::-webkit-scrollbar {
            height: 12px;
        }
        .robot-select-scroll-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin: 0 10px;
        }
        .robot-select-scroll-container::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #65D46E, #93E198);
            border-radius: 6px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        .robot-select-scroll-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #5bc462, #87d58c);
        }
        .robot-select-card {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            width: 160px;
            height: 160px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .robot-select-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.35);
        }
        .robot-select-card.selected {
            border-color: #65D46E;
            background: rgba(101, 212, 110, 0.3);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: 0 0 20px rgba(101, 212, 110, 0.4);
        }
        .robot-select-card.empty-slot {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            cursor: default;
            opacity: 0.6;
        }
        .robot-select-card.empty-slot:hover {
            transform: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
        }
        .empty-slot-icon {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 8px;
        }
        .empty-slot-text {
            font-family: 'Sassy Raccoon', cursive;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }
        .robot-select-card-image {
            width: 80px;
            height: 80px;
            object-fit: contain;
            margin-bottom: 8px;
            transition: transform 0.3s ease;
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.15));
        }
        .robot-select-card:hover .robot-select-card-image {
            transform: scale(1.1);
        }
        .robot-select-card-name {
            font-family: 'Sassy Raccoon', cursive;
            font-size: 13px;
            font-weight: 700;
            color: white;
            margin-bottom: 4px;
            line-height: 1.2;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        .robot-select-card-status {
            font-size: 10px;
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }
        .robot-select-card.selected .robot-select-card-status {
            color: #fff;
            opacity: 1;
        }
        .robot-selected-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            background: #65D46E;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.8);
        }
        
        /* Scrollbar styling for robot select */
        .robot-select-grid::-webkit-scrollbar {
            width: 8px;
        }
        .robot-select-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        .robot-select-grid::-webkit-scrollbar-thumb {
            background: rgba(101, 212, 110, 0.6);
            border-radius: 4px;
        }
        .robot-select-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(101, 212, 110, 0.8);
        }
        
        /* Robot Store Bubble */
        .robot-store-bubble {
            position: fixed;
            bottom: 30px;
            left: 20px;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 999;
        }
        .robot-store-bubble:hover {
            transform: scale(1.05);
        }
        .robot-store-bubble:active {
            transform: scale(0.95);
        }
        .robot-store-bubble img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
        }
        .robot-store-bubble.hidden {
            display: none;
        }
        
        /* Team Selection Bubble */
        .team-selection-bubble {
            position: fixed;
            bottom: 120px; /* Position above robot store bubble */
            left: 20px;
            width: 70px;
            height: 70px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 999;
            filter: hue-rotate(120deg) brightness(1.1); /* Make it more blue/green for team selection */
        }
        .team-selection-bubble:hover {
            transform: scale(1.05);
        }
        .team-selection-bubble:active {
            transform: scale(0.95);
        }
        .team-selection-bubble img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
        }
        .team-selection-bubble.hidden {
            display: none;
        }
        
        /* Robot Store Modal */
        .robot-store-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }
        .robot-store-modal.active {
            display: flex;
        }
        .robot-store-content {
            background: #A8D5D5;
            border-radius: 30px;
            width: 100%;
            max-width: 900px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            border: none;
        }
        .robot-store-header {
            background: transparent;
            padding: 24px 24px 16px;
            text-align: center;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .robot-store-header h2 {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .robot-factory-logo {
            height: 120px;
            width: auto;
            max-width: 90%;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
        }
        .robot-store-close {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .robot-store-close:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: rotate(90deg);
        }
        .robot-store-close:active {
            transform: scale(0.9) rotate(90deg);
        }
        
        /* Robot Store Grid */
        /* Scrappy Character */
        .scrappy-container {
            position: fixed;
            top: 80px;
            right: 15px;
            width: 120px;
            z-index: 2100;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .scrappy-container.dodging {
            transition: transform 0.2s ease-out;
        }
        .scrappy-image {
            width: 100%;
            height: auto;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
            animation: float 6s ease-in-out infinite;
            pointer-events: all;
            cursor: pointer;
        }
        .scrappy-speech-bubble {
            position: absolute;
            bottom: 20px;
            right: 110px;
            width: 200px;
            background: var(--surface);
            color: var(--text);
            padding: 12px 16px;
            border-radius: 15px;
            font-size: 13px;
            box-shadow: var(--shadow-lg);
            text-align: left;
            opacity: 0;
            transform: translateX(10px) scale(0.9);
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform-origin: right center;
            pointer-events: all;
            line-height: 1.4;
        }
        .scrappy-speech-bubble.visible {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
        .scrappy-speech-bubble::before {
            content: '';
            position: absolute;
            right: -8px;
            bottom: 30px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 8px solid var(--surface);
        }
        
        .robot-store-body {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 16px;
            position: relative;
        }
        .robot-store-body::-webkit-scrollbar {
            height: 8px;
        }
        .robot-store-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .robot-store-body::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
        }
        .robot-store-body::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.7);
        }
        .robot-store-grid {
            display: grid;
            grid-template-rows: repeat(2, 1fr);
            grid-auto-flow: column;
            gap: 12px;
            height: 340px;
            width: max-content;
        }
        
        /* Robot Store Card */
        .robot-store-card {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 4px;
            width: 140px;
            height: 100%;
        }
        .robot-store-card.placeholder {
            opacity: 0.5;
            cursor: default;
        }
        .robot-store-card.placeholder:hover {
            transform: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .robot-store-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }
        .robot-store-card:active {
            transform: translateY(-2px) scale(1.0);
        }
        .robot-store-card-image {
            width: 60px;
            height: 60px;
            margin: 4px auto;
            object-fit: contain;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.15));
        }
        .robot-store-card-image.placeholder-icon {
            width: 50px;
            height: 50px;
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @keyframes floatShadow {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        .robot-store-card-shadow {
            filter: brightness(0) drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        }
        .robot-store-card-name {
            font-size: 12px;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            margin: 2px 0;
            line-height: 1.2;
        }
        .robot-store-card-cost {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 12px;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            margin: 2px 0;
        }
        .robot-store-card-button {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 700;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: auto;
        }
        .robot-store-card-button:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
        }
        .robot-store-card-button:active {
            transform: translateY(0);
        }
        .robot-store-card-button.owned {
            background: rgba(147, 225, 152, 0.4);
            color: white;
            cursor: default;
            pointer-events: none;
        }
        .robot-store-card-button.owned:hover {
            transform: none;
        }
        .robot-store-card-button.select {
            background: linear-gradient(135deg, #65D46E, #93E198);
            color: white;
        }
        .robot-store-card-button.selected {
            background: rgba(255, 255, 255, 0.5);
            color: white;
            cursor: default;
            pointer-events: none;
        }
        .robot-store-card-button.selected:hover {
            transform: none;
        }
        .robot-store-card-cost-icon {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        .robot-store-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        .robot-store-empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .robot-store-empty-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        .robot-store-empty-subtext {
            font-size: 14px;
            opacity: 0.7;
        }
        
        /* Purchase Confirmation Modal */
        .purchase-confirm-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2100;
            padding: 20px;
        }
        .purchase-confirm-modal.active {
            display: flex;
        }
        .purchase-confirm-content {
            background: white;
            border-radius: 24px;
            padding: 32px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .purchase-confirm-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        .purchase-confirm-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 16px;
        }
        .purchase-confirm-message {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }
        .purchase-confirm-cost {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 28px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(101, 212, 110, 0.1);
            border-radius: 16px;
        }
        .purchase-confirm-cost-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        .purchase-confirm-buttons {
            display: flex;
            gap: 12px;
        }
        .purchase-confirm-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .purchase-confirm-btn-no {
            background: #f3f4f6;
            color: var(--text);
        }
        .purchase-confirm-btn-no:active {
            transform: scale(0.98);
            background: #e5e7eb;
        }
        .purchase-confirm-btn-yes {
            background: linear-gradient(135deg, #65D46E, #93E198);
            color: white;
            box-shadow: 0 4px 12px rgba(101, 212, 110, 0.4);
        }
        .purchase-confirm-btn-yes:active {
            transform: scale(0.98);
            box-shadow: 0 2px 6px rgba(101, 212, 110, 0.4);
        }
        
        /* Reveal Animation */
        .robot-reveal-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2200;
            padding: 20px;
        }
        .robot-reveal-modal.active {
            display: flex;
        }
        .robot-reveal-content {
            text-align: center;
            animation: revealPop 0.5s ease-out;
        }
        @keyframes revealPop {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .robot-reveal-title {
            font-family: 'Sassy Raccoon', cursive;
            font-size: 36px;
            color: white;
            margin-bottom: 24px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }
        .robot-reveal-image {
            width: 200px;
            height: 200px;
            margin: 0 auto 24px;
            object-fit: contain;
            filter: drop-shadow(0 4px 20px rgba(101, 212, 110, 0.6));
            animation: revealGlow 1.5s ease-in-out infinite;
        }
        @keyframes revealGlow {
            0%, 100% {
                filter: drop-shadow(0 4px 20px rgba(101, 212, 110, 0.6));
            }
            50% {
                filter: drop-shadow(0 8px 30px rgba(101, 212, 110, 0.9));
            }
        }
        .robot-reveal-name {
            font-family: 'Sassy Raccoon', cursive;
            font-size: 28px;
            color: #65D46E;
            margin-bottom: 32px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }
        .robot-reveal-btn {
            padding: 16px 48px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(101, 212, 110, 0.5);
            transition: all 0.2s;
        }
        .robot-reveal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(101, 212, 110, 0.6);
        }
        .robot-reveal-btn:active {
            transform: scale(0.98);
        }
        
        /* Currency Display */
        .currency-display {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%) scale(0.75);
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            padding: 12px 24px;
            border-radius: 50px;
            box-shadow: none;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            border: none;
        }
        .currency-display-bolt {
            width: 32px;
            height: 32px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }
        .currency-display-x {
            width: 16px;
            height: 16px;
            object-fit: contain;
            opacity: 0.8;
        }
        .currency-display-amount {
            font-size: 20px;
            font-weight: 700;
            color: var(--text);
        }
        
        /* Store Currency Display */
        .store-currency-display {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 50px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 6px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            z-index: 2200;
        }
        .store-currency-bolt {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        .store-currency-x {
            width: 14px;
            height: 14px;
            object-fit: contain;
            opacity: 0.8;
        }
        .store-currency-amount {
            font-size: 16px;
            font-weight: 700;
            color: var(--text);
        }
        .store-currency-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }
        
        /* Update cost displays to use images */
        .robot-store-card-cost-bolt {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        .robot-store-card-cost-x {
            width: 14px;
            height: 14px;
            object-fit: contain;
            opacity: 0.8;
        }
        .purchase-confirm-cost-bolt {
            width: 36px;
            height: 36px;
            object-fit: contain;
        }
        .purchase-confirm-cost-x {
            width: 20px;
            height: 20px;
            object-fit: contain;
            opacity: 0.8;
        }
        
        /* Missions Bubble */
        .missions-bubble {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 80px;
            height: 80px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        .missions-bubble:hover {
            transform: scale(1.1);
        }
        .missions-bubble:active {
            transform: scale(0.95);
        }
        .missions-bubble.hidden {
            display: none;
        }
        .missions-bubble img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
        }
        
        /* Missions Modal */
        .missions-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }
        .missions-modal.active {
            display: flex;
        }
        .missions-content {
            background: #A8D5D5;
            border-radius: 30px;
            width: 100%;
            max-width: 500px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            border: none;
        }
        .missions-header {
            background: transparent;
            padding: 24px 24px 16px;
            text-align: center;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .missions-header h2 {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .missions-logo {
            height: 120px;
            width: auto;
            max-width: 90%;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
        }
        .missions-close {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .missions-close:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: rotate(90deg);
        }
        .missions-close:active {
            transform: scale(0.9) rotate(90deg);
        }
        
        /* Missions Body */
        .missions-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        /* Mission Card */
        .mission-card {
            background: white;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: 2px solid #e5e7eb;
            transition: all 0.3s ease;
        }
        .mission-card.completed {
            border-color: #65D46E;
            box-shadow: 0 4px 12px rgba(101, 212, 110, 0.3);
        }
        .mission-card.claimed {
            opacity: 0.5;
            background: #f3f4f6;
        }
        .mission-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 8px;
        }
        .mission-description {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .mission-reward {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 16px;
            font-weight: 600;
            color: #FFA500;
            margin-bottom: 12px;
        }
        .mission-reward-bolt {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }
        .mission-claim-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #65D46E, #93E198);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(101, 212, 110, 0.3);
        }
        .mission-claim-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(101, 212, 110, 0.4);
        }
        .mission-claim-btn:active {
            transform: scale(0.98);
        }
        .mission-claim-btn:disabled {
            background: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
        }
        .mission-claimed-badge {
            text-align: center;
            padding: 12px;
            background: #f3f4f6;
            border-radius: 12px;
            color: #6b7280;
            font-weight: 600;
        }
        
        /* Complete All Button */
        .complete-all-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            border: none;
            border-radius: 16px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(255, 165, 0, 0.4);
            margin-top: 8px;
        }
        .complete-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 165, 0, 0.5);
        }
        .complete-all-btn:active {
            transform: scale(0.98);
        }
        .complete-all-btn:disabled {
            background: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        /* Missions Tabs */
        .missions-tabs {
            display: flex;
            background: white;
            border-top: 2px solid #e5e7eb;
        }
        .mission-tab {
            flex: 1;
            padding: 16px;
            background: transparent;
            border: none;
            font-size: 14px;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .mission-tab.active {
            color: #A8D5D5;
            border-bottom-color: #A8D5D5;
        }
        .mission-tab:hover {
            background: rgba(168, 213, 213, 0.1);
        }
        
        /* Coming Soon Message */
        .coming-soon {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        .coming-soon-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .coming-soon-text {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        /* Daily Mystery Pick Game */
        .mystery-game-container {
            padding: 15px;
            text-align: center;
            max-height: 80vh;
            overflow: hidden;
        }
        .mystery-game-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 12px;
        }
        .mystery-game-description {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }
        .mystery-start-btn {
            background: linear-gradient(135deg, #A8D5D5, #7BC4C4);
            color: white;
            border: none;
            border-radius: 16px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(168, 213, 213, 0.4);
            margin-bottom: 16px;
        }
        .mystery-start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(168, 213, 213, 0.5);
        }
        .mystery-start-btn:active {
            transform: scale(0.98);
        }
        .mystery-start-btn:disabled {
            background: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        /* Game Arena */
        .mystery-game-arena {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }
        .mystery-game-arena.active {
            display: flex;
        }
        .mystery-game-status {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
            min-height: 24px;
        }
        .mystery-boxes-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin: 12px 0;
        }
        .mystery-box {
            position: relative;
            width: 80px;
            height: 80px;
            cursor: pointer;
            transition: all 0.3s ease;
            transform-style: preserve-3d;
        }
        .mystery-box:hover {
            transform: scale(1.05);
        }
        .mystery-box.shuffling {
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            cursor: not-allowed;
        }
        .mystery-box.opening {
            animation: boxOpen 0.6s ease-out forwards;
        }
        .mystery-box-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
        }
        .mystery-box-prize {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .mystery-box-prize.revealed {
            opacity: 1;
        }
        .mystery-prize-image {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }
        .mystery-prize-text {
            font-size: 12px;
            font-weight: 600;
            color: var(--text);
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }
        
        /* Animations */
        @keyframes boxOpen {
            0% { transform: scale(1) rotateY(0deg); }
            50% { transform: scale(1.1) rotateY(180deg); }
            100% { transform: scale(1) rotateY(360deg); }
        }
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 1; transform: scale(1) rotate(180deg); }
        }
        .sparkle-effect {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border-radius: 50%;
            animation: sparkle 1s ease-in-out infinite;
        }
        
        /* Prize Reveal Modal */
        .mystery-result-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
            padding: 20px;
        }
        .mystery-result-modal.active {
            display: flex;
        }
        .mystery-result-content {
            background: linear-gradient(135deg, #A8D5D5, #7BC4C4);
            border-radius: 24px;
            padding: 32px;
            text-align: center;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalAppear 0.5s ease-out;
        }
        @keyframes modalAppear {
            0% { opacity: 0; transform: scale(0.8) translateY(20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .mystery-result-title {
            font-size: 28px;
            font-weight: 700;
            color: white;
            margin-bottom: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        .mystery-result-prize {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 24px 0;
            padding: 16px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 16px;
        }
        .mystery-result-prize-image {
            width: 48px;
            height: 48px;
            object-fit: contain;
        }
        .mystery-result-prize-text {
            font-size: 20px;
            font-weight: 700;
            color: white;
        }
        .mystery-result-btn {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mystery-result-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        /* Battle System Styles */
        #battleView {
            background: var(--bg);
            padding-top: 0;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            overflow-y: auto;
            width: 100vw;
            height: 100vh;
        }

        /* Hide ALL UI elements during battle */
        body.battle-mode .currency-display,
        body.battle-mode .missions-bubble,
        body.battle-mode .settings-btn,
        body.battle-mode .mascot-container-global,
        body.battle-mode .robot-select-bubble,
        body.battle-mode .store-bubble,
        body.battle-mode .floating-bubble,
        body:has(#battleView.active) .currency-display,
        body:has(#battleView.active) .missions-bubble,
        body:has(#battleView.active) .settings-btn,
        body:has(#battleView.active) .mascot-container-global,
        body:has(#battleView.active) .robot-select-bubble,
        body:has(#battleView.active) .store-bubble,
        body:has(#battleView.active) .floating-bubble,
        #battleView.active ~ .currency-display,
        #battleView.active ~ .missions-bubble,
        #battleView.active ~ .settings-btn,
        #battleView.active ~ .mascot-container-global,
        #battleView.active ~ .robot-select-bubble,
        #battleView.active ~ .store-bubble,
        #battleView.active ~ .floating-bubble {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Battle header - transparent overlay */
        #battleView .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            background: transparent;
            border-bottom: none;
            padding: 2px;
        }

        /* Ensure battle view takes full screen on mobile */
        @media (max-width: 768px) {
            #battleView {
                padding-top: 0;
            }
            
            #battleView .header {
                padding: 2px;
            }
        }

        .battle-content {
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            max-width: 100%;
            margin: 0 auto;
            overflow: hidden;
            background: transparent;
        }

        /* Player Zones - Edge-anchored, no overlap */
        .player-zone {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 0;
            margin: 0;
            border: none;
            border-radius: 0;
            background: transparent;
            flex-shrink: 0;
            width: 100%;
            max-width: 100%;
            overflow: visible;
            position: relative;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .battle-content {
                padding: 0;
                height: 100vh;
            }
            
            .player-zone {
                gap: 3px;
                padding: 0;
                margin: 0;
                max-width: 100%;
                overflow: visible;
            }
        }

        .opponent-player {
            flex-direction: row;
            margin-top: -40px;
            position: relative;
            z-index: 1000;
        }

        .user-player {
            flex-direction: row-reverse;
        }

        /* Repair Bay Section */
        .repair-bay {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-right: 8px; /* Space between repair bay and bench */
        }

        .repair-slot {
            width: 45px;
            height: 45px;
            border: 2px solid rgba(255, 100, 100, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(20, 20, 20, 0.6);
            flex-shrink: 0;
            position: relative;
            pointer-events: none; /* Not interactive */
        }

        .repair-icon {
            font-size: 20px;
            opacity: 0.4;
            position: absolute;
        }

        /* Deactivated robot in repair bay */
        .repair-slot[data-occupied="true"] .repair-icon {
            display: none; /* Hide wrench when robot present */
        }

        .repair-slot .bench-robot {
            filter: grayscale(100%);
            opacity: 0.5;
        }

        /* Pulsing red light effect while repairing */
        @keyframes repairPulse {
            0%, 100% {
                box-shadow: 0 0 5px rgba(255, 50, 50, 0.3);
            }
            50% {
                box-shadow: 0 0 15px rgba(255, 50, 50, 0.7);
            }
        }

        .repair-slot[data-occupied="true"] {
            animation: repairPulse 2s ease-in-out infinite;
        }

        /* Indicator Arrows - Hidden for maximized view */
        .indicator-arrow {
            display: none;
        }

        /* Bench Section */
        .bench-section {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
            flex-shrink: 0;
        }

        .bench-row {
            display: flex;
            gap: 4px;
        }

        .bench-row.secondary {
            margin-left: 15px;
        }

        .user-player .bench-row.secondary {
            margin-left: 0;
            margin-right: 15px;
        }

        .bench-slot {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 50%;
            background: transparent;
            flex-shrink: 0;
            position: relative;
            overflow: visible;
        }

        @media (max-width: 480px) {
            .repair-slot {
                width: 40px;
                height: 40px;
            }
            
            .repair-icon {
                font-size: 18px;
            }
            
            .indicator-arrow {
                display: none;
            }
            
            .bench-slot {
                width: 38px;
                height: 38px;
            }
            
            .bench-row {
                gap: 8px;
            }
            
            .bench-row.secondary {
                margin-left: 20px;
            }
            
            .user-player .bench-row.secondary {
                margin-left: 0;
                margin-right: 20px;
            }
        }

        /* Game Field - Absolute maximum size */
        .game-field {
            flex: 1 1 auto;
            margin: 0;
            padding: 0;
            border: none;
            border-radius: 0;
            background: transparent;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            overflow: visible;
            z-index: 1;
        }

        .battle-board-svg {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            margin: 0;
            display: block;
            background: transparent;
            border-radius: 0;
        }

        /* ==========================================
           PHASE 2: BATTLE SYSTEM VISUAL FEEDBACK
           ========================================== */
        
        /* Player Turn Highlights */
        .player-turn-highlight {
            filter: drop-shadow(0 0 8px #00ff88) brightness(1.2);
            animation: playerPulse 2s ease-in-out infinite;
        }
        
        @keyframes playerPulse {
            0%, 100% { filter: drop-shadow(0 0 8px #00ff88) brightness(1.2); }
            50% { filter: drop-shadow(0 0 12px #00ff88) brightness(1.4); }
        }
        
        /* Selected Figure Highlight - REMOVED (using static version below) */
        
        /* ========================================== */
        /* STATIC CHESS-LIKE BOARD - NO HOVER EFFECTS */
        /* ========================================== */
        
        /* Valid Move Highlight - STATIC, NO ANIMATION */
        .valid-move {
            filter: drop-shadow(0 0 8px #00ff88) brightness(1.3);
            cursor: pointer !important;
        }
        
        /* Selected Unit - STATIC, NO ANIMATION */
        .point.selected,
        .battle-robot.selected {
            filter: drop-shadow(0 0 10px #ffaa00) brightness(1.4);
        }
        
        /* Ensure pointer cursor on clickable elements */
        .point[data-occupied="true"] {
            cursor: pointer;
        }
        
        /* Battle System UI States - STATIC ONLY (no hover effects) */
        
        /* Turn Indicator Styles */
        .turn-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
            animation: fadeInDown 0.5s ease;
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        .turn-indicator.player-turn {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .turn-indicator.ai-turn {
            background: linear-gradient(45deg, #ff4444, #cc2222);
            color: #fff;
        }
        
        /* Battle Options UI */
        .battle-options {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            z-index: 2000;
            animation: battleOptionsAppear 0.3s ease;
        }
        
        @keyframes battleOptionsAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .battle-options button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 10px 20px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .battle-options button:hover {
            background: #00cc66;
            transform: scale(1.05);
        }
        
        /* Debug Mode Styles */
        .debug-mode .point {
            stroke: #fff !important;
            stroke-width: 1 !important;
        }
        
        .debug-mode .point[data-occupied="true"] {
            fill: #ff0000 !important;
        }
        
        .debug-mode .point[data-team="player"] {
            fill: #00ff00 !important;
        }
        
        .debug-mode .point[data-team="opponent"] {
            fill: #0000ff !important;
        }
        
        /* Battle Robot Visual Styles */
        .battle-robot {
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            /* NO transitions - keep robots stationary */
            pointer-events: all;
            image-rendering: crisp-edges;
        }
        
        /* REMOVED hover scale effect - robots stay stationary */
        
        .player-robot {
            border: 2px solid #00ff88;
        }
        
        .opponent-robot {
            border: 2px solid #ff4444;
        }
        
        /* Robot Selection Highlights - NO SCALING */
        .battle-robot.selected {
            /* Removed scale transform - robots stay stationary */
            box-shadow: 0 0 15px #ffff00;
            border-color: #ffff00;
        }
        
        .battle-robot.player-turn-highlight {
            animation: robotPulse 2s ease-in-out infinite;
        }
        
        @keyframes robotPulse {
            0%, 100% { 
                box-shadow: 0 0 8px #00ff88;
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 12px #00ff88;
                transform: scale(1.05);
            }
        }
        
        /* Team Selection Styles - Two Panel Design */
        
        /* Active Squad Header (Fixed) */
        .active-squad-header {
            background: var(--surface);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 12px;
            box-shadow: var(--shadow);
            position: sticky;
            top: 80px;
            z-index: 10;
        }
        
        .squad-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .squad-title h3 {
            margin: 0;
            color: var(--text);
            font-size: 13px;
            font-weight: 600;
        }
        
        .squad-counter {
            font-size: 11px;
            font-weight: 600;
            color: var(--primary);
            background: var(--bg);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .active-squad-slots {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }
        
        .squad-slot {
            border: 1px dashed var(--border);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: var(--text-secondary);
            background: #f8f9fa;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
            padding: 4px;
            min-height: 40px;
            max-height: 45px;
        }
        
        .squad-slot.empty {
            border-style: dashed;
        }
        
        .squad-slot.filled {
            border: 1px solid var(--primary);
            background: var(--bg);
            color: var(--text);
            font-weight: 500;
            cursor: pointer;
        }
        
        .squad-slot.filled:hover {
            background: #ffebee;
            border-color: var(--danger);
        }
        
        .slot-number {
            font-size: 7px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 1px;
        }
        
        .slot-label {
            font-size: 9px;
            text-align: center;
            line-height: 1.2;
        }
        
        /* Robot Bay Container */
        .robot-bay-container {
            background: var(--surface);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 100px; /* Space for fixed footer */
            box-shadow: var(--shadow);
        }
        
        .bay-header {
            margin-bottom: 16px;
        }
        
        .bay-header h3 {
            margin: 0 0 4px 0;
            color: var(--text);
            font-size: 16px;
            font-weight: 600;
        }
        
        .bay-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .robot-bay-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .robot-card {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .robot-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .robot-card.selected {
            border-color: var(--primary);
            background: var(--bg);
        }
        
        .robot-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .robot-card.disabled:hover {
            transform: none;
            border-color: var(--border);
        }
        
        .robot-card-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .robot-card-image {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid var(--border);
        }
        
        .robot-card-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text);
        }
        
        .robot-card-role {
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: auto;
        }
        
        .robot-card-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            margin-bottom: 8px;
        }
        
        .robot-stat {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .robot-stat strong {
            color: var(--text);
        }
        
        .robot-card-description {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.3;
            margin-bottom: 8px;
        }
        
        .robot-card-wheel {
            display: flex;
            gap: 2px;
            margin-bottom: 4px;
        }
        
        .wheel-segment {
            height: 4px;
            border-radius: 2px;
        }

        .wheel-segment.move { background: #28a745; }
        .wheel-segment.attack { background: #ff4444; }
        .wheel-segment.defense { background: #4444ff; }
        .wheel-segment.special { background: #ff44ff; }

        /* Battle System Bench Styles */
        .bench-robots-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            justify-content: center;
            min-height: 80px;
        }

        .bench-robot {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 70px;
            height: 70px;
        }

        .bench-robot:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .bench-robot.selected {
            border-color: var(--primary);
            background: var(--bg);
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        .bench-robot.player {
            border-left: 4px solid #28a745;
        }

        .bench-robot.opponent {
            border-left: 4px solid #dc3545;
        }

        .bench-robot-image {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-bottom: 4px;
        }

        .bench-robot-name {
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 2px;
        }

        .bench-robot-mp {
            font-size: 8px;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Game Board Point Interaction */
        .point.valid-deployment {
            background: rgba(40, 167, 69, 0.3) !important;
            border: 2px solid #28a745 !important;
            animation: pulse-green 1s infinite;
        }

        .point.valid-move {
            background: rgba(0, 123, 255, 0.3) !important;
            border: 2px solid #007bff !important;
            animation: pulse-blue 1s infinite;
        }

        .point.selected {
            background: rgba(255, 193, 7, 0.3) !important;
            border: 2px solid #ffc107 !important;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.5); }
            50% { box-shadow: 0 0 15px rgba(40, 167, 69, 0.8); }
        }

        @keyframes pulse-blue {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); }
            50% { box-shadow: 0 0 15px rgba(0, 123, 255, 0.8); }
        }

        /* Battle System Active State */
        .battle-system-active .point {
            cursor: pointer;
        }

        /* Battle Overlay Modal */
        #battleOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        #battleOverlay.active {
            display: flex;
        }

        .battle-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            padding: 16px;
            max-width: 700px;
            max-height: 95vh;
            width: 92%;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: battleModalSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            border: 3px solid rgba(255, 215, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes battleModalSlideIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* Spinning Wheels Section */
        .battle-wheels {
            display: flex;
            align-items: stretch;
            justify-content: center;
            margin: 4px 0;
            padding: 8px 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            gap: 12px;
        }
        
        .battle-wheels::-webkit-scrollbar {
            width: 6px;
        }
        
        .battle-wheels::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        
        .battle-wheels::-webkit-scrollbar-thumb {
            background: rgba(100, 149, 237, 0.5);
            border-radius: 3px;
        }
        
        .wheel-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            flex: 1;
            max-width: 240px;
        }
        
        .wheel-label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }
        
        .wheel-label.attacker {
            color: #ff4444;
        }
        
        .wheel-label.defender {
            color: #4444ff;
        }
        
        .spinning-wheel {
            position: relative;
            width: 90px;
            height: 90px;
        }
        
        /* Floating Move Name Overlay */
        .move-flash-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 1000;
            pointer-events: none;
            animation: moveRevealAnimation 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        .move-flash-text {
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 10px 20px;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.92) 0%, rgba(20, 20, 30, 0.92) 100%);
            border: 2px solid;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                0 0 40px currentColor,
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.5);
            text-shadow: 
                0 0 15px currentColor,
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 30px currentColor;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }
        
        .move-flash-text::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes moveRevealAnimation {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        
        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 200%;
            }
        }
        
        .wheel-segments {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4), inset 0 0 15px rgba(0, 0, 0, 0.5);
            position: relative;
            background: conic-gradient(
                from 0deg,
                #ff4444 0deg 30deg,
                #4444ff 30deg 90deg,
                #ffaa00 90deg 150deg,
                #aa44ff 150deg 210deg,
                #ffffff 210deg 270deg,
                #ff4444 270deg 330deg,
                #4444ff 330deg 360deg
            );
            animation: wheelSpin 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }
        
        @keyframes wheelSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(1440deg); }
        }
        
        .wheel-segments.slow-spin {
            animation: wheelSlowSpin 2s ease-out forwards;
        }
        
        @keyframes wheelSlowSpin {
            0% { transform: rotate(1440deg); }
            100% { transform: rotate(1800deg); }
        }
        
        /* Pip dots for duplicate colored moves */
        .wheel-pip-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        .wheel-pip {
            position: absolute;
            width: 7px;
            height: 7px;
            background: #000;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Move name labels above pips */
        .wheel-move-name {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 3px #000;
            white-space: nowrap;
            pointer-events: none;
            line-height: 1;
        }
        
        /* Star overlays for moves with star ratings */
        .wheel-star-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 11;
        }
        
        .wheel-star-display {
            position: absolute;
            font-size: 14px;
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 3px #000;
            line-height: 1;
            white-space: nowrap;
        }
        
        .wheel-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #ffd700;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
            z-index: 10;
        }
        
        .wheel-result {
            font-size: 9px;
            font-weight: 600;
            min-height: 50px;
            text-align: center;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 3px;
            justify-content: center;
        }
        
        .wheel-result .move-name {
            font-weight: 700;
            font-size: 10px;
            text-transform: uppercase;
            line-height: 1.2;
        }
        
        .wheel-result .move-power {
            font-size: 9px;
            opacity: 0.9;
            line-height: 1.3;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .wheel-result.revealed {
            animation: resultReveal 0.5s ease-out;
            border-color: currentColor;
        }
        
        .wheel-result.revealed .move-name {
            font-size: 10px;
        }
        
        @keyframes resultReveal {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .battle-vs-small {
            display: none;
        }
        
        /* Wheel Legend */
        .battle-wheel-moves-list {
            margin-top: 4px;
            overflow-y: auto;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            width: 100%;
            max-height: 400px;
        }
        
        .battle-wheel-moves-list::-webkit-scrollbar {
            width: 4px;
        }
        
        .battle-wheel-moves-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }
        
        .battle-wheel-moves-list::-webkit-scrollbar-thumb {
            background: rgba(100, 149, 237, 0.5);
            border-radius: 2px;
        }
        
        .battle-wheel-move {
            display: flex;
            align-items: flex-start;
            gap: 4px;
            padding: 5px;
            margin-bottom: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border-left: 2px solid;
            font-size: 9px;
            transition: all 0.2s ease;
        }
        
        .battle-wheel-move:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(2px);
        }
        
        .battle-wheel-move.White { border-left-color: #ffffff; }
        .battle-wheel-move.Gold { border-left-color: #ffd700; }
        .battle-wheel-move.Purple { border-left-color: #a855f7; }
        .battle-wheel-move.Blue { border-left-color: #3b82f6; }
        .battle-wheel-move.Red { border-left-color: #ef4444; }
        
        .battle-wheel-move-icon {
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .battle-wheel-move-info {
            flex: 1;
            min-width: 0;
        }
        
        .battle-wheel-move-name {
            font-weight: 600;
            color: #fff;
            font-size: 9px;
            word-wrap: break-word;
            line-height: 1.2;
        }
        
        .battle-wheel-move-effect {
            color: rgba(255, 255, 255, 0.6);
            font-size: 8px;
            line-height: 1.3;
            margin-top: 2px;
            word-wrap: break-word;
        }
        
        .battle-wheel-move-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            flex-shrink: 0;
        }
        
        .battle-wheel-move-damage {
            font-weight: 700;
            color: #ffd700;
            font-size: 8px;
        }
        
        .battle-wheel-move-size {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
        }

        .battle-modal-header {
            text-align: center;
            margin-bottom: 4px;
            min-height: 0;
        }

        .battle-modal-title {
            font-size: 16px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 8px;
        }

        .battle-modal-subtitle {
            display: none;
        }

        .battle-combatants {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 32px;
            margin: 24px 0;
        }

        .combatant {
            text-align: center;
            flex: 1;
        }

        .combatant-image {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid #fff;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            margin-bottom: 10px;
            object-fit: cover;
        }

        .combatant.player .combatant-image {
            border-color: #28a745;
            box-shadow: 0 0 30px rgba(40, 167, 69, 0.6);
        }

        .combatant.opponent .combatant-image {
            border-color: #dc3545;
            box-shadow: 0 0 30px rgba(220, 53, 69, 0.6);
        }

        .combatant-name {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .combatant-role {
            font-size: 14px;
            color: #aaa;
        }

        .battle-vs {
            font-size: 48px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .battle-action-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 12px;
            flex-shrink: 0;
        }

        .battle-action-btn {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .battle-action-btn.attack {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        .battle-action-btn.attack:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
        }

        .battle-action-btn.info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.4);
            padding: 16px 24px;
        }

        .battle-action-btn.info:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.6);
        }

        .battle-action-btn.cancel {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
        }

        .battle-action-btn.cancel:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.6);
        }

        /* Battle Result Display */
        .battle-result {
            margin-top: 24px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            text-align: center;
            display: none;
        }

        .battle-result.active {
            display: block;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .battle-result-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .battle-result-title.victory {
            color: #28a745;
        }

        .battle-result-title.defeat {
            color: #dc3545;
        }

        .battle-result-title.draw {
            color: #ffc107;
        }

        .battle-result-title.status {
            color: #aa44ff;
        }

        .status-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 50%;
            padding: 4px 6px;
            font-size: 12px;
            line-height: 1;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
            display: none;
        }

        .battle-result-details {
            font-size: 16px;
            color: #ccc;
            margin-bottom: 16px;
        }

        .battle-continue-btn {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .battle-continue-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        /* Combat Dial Info Overlay */
        #combatDialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            z-index: 2100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
        }

        #combatDialOverlay.active {
            display: flex;
        }

        .combat-dial-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            padding: 20px;
            max-width: 700px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            animation: combatDialSlideIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 3px solid rgba(100, 149, 237, 0.4);
            position: relative;
        }

        .combat-dial-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .combat-dial-close-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            border-color: #ef4444;
            transform: scale(1.1);
        }

        .combat-dial-close-btn:active {
            transform: scale(0.95);
        }

        @keyframes combatDialSlideIn {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .combat-dial-header {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(100, 149, 237, 0.3);
        }

        .combat-dial-wheel-container {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            margin: 0 auto 20px;
            border: 4px solid #ffd700;
            position: relative;
            overflow: hidden;
        }

        @keyframes combatDialWheelSpin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(720deg);
            }
        }

        .combat-dial-robot-image {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(100, 149, 237, 0.6);
            box-shadow: 0 0 20px rgba(100, 149, 237, 0.4);
        }

        .combat-dial-robot-info {
            flex: 1;
        }

        .combat-dial-robot-name {
            font-size: 22px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 4px;
        }

        .combat-dial-robot-role {
            font-size: 14px;
            color: #6495ed;
            margin-bottom: 6px;
        }

        .combat-dial-robot-stats {
            font-size: 13px;
            color: #aaa;
            font-weight: 500;
        }

        .combat-dial-ability {
            background: rgba(100, 149, 237, 0.15);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 12px;
            border-left: 4px solid #6495ed;
        }

        .combat-dial-ability-name {
            font-size: 13px;
            font-weight: 700;
            color: #6495ed;
            margin-bottom: 3px;
        }

        .combat-dial-ability-desc {
            font-size: 11px;
            color: #ccc;
            line-height: 1.3;
        }

        .combat-dial-title {
            text-align: center;
            font-size: 16px;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .combat-dial-content {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 16px;
            margin-bottom: 12px;
        }

        @media (max-width: 650px) {
            .combat-dial-content {
                grid-template-columns: 1fr;
            }
        }

        .combat-dial-wheel-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .combat-dial-wheel-container {
            width: 180px;
            height: 180px;
            position: relative;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #1a1a2e, #16213e);
            border: 3px solid rgba(100, 149, 237, 0.5);
            box-shadow: 0 0 20px rgba(100, 149, 237, 0.3);
            overflow: hidden;
        }

        .combat-dial-moves-section {
            display: flex;
            flex-direction: column;
        }

        .combat-dial-wheel-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 12px;
            max-height: 230px;
            overflow-y: auto;
        }

        .combat-dial-wheel-display::-webkit-scrollbar {
            width: 6px;
        }

        .combat-dial-wheel-display::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .combat-dial-wheel-display::-webkit-scrollbar-thumb {
            background: rgba(100, 149, 237, 0.5);
            border-radius: 3px;
        }

        .combat-dial-wheel-display::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 149, 237, 0.7);
        }

        .combat-dial-move {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid;
            transition: all 0.2s ease;
        }

        .combat-dial-move:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .combat-dial-move:last-child {
            margin-bottom: 0;
        }

        .combat-dial-move-color {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 18px;
            flex-shrink: 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .combat-dial-move-info {
            flex: 1;
        }

        .combat-dial-move-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 1px;
        }

        .combat-dial-move-effect {
            font-size: 10px;
            color: #aaa;
            font-style: italic;
        }

        .combat-dial-move-stats {
            text-align: right;
            font-size: 12px;
            font-weight: 600;
        }

        .combat-dial-move-damage {
            color: #ff6b6b;
            font-weight: 700;
        }

        .combat-dial-move-size {
            font-size: 9px;
            color: #aaa;
            margin-top: 1px;
        }

        /* Move Type Colors */
        .combat-dial-move.White {
            border-left-color: #fff;
        }

        .combat-dial-move.White .combat-dial-move-color {
            background: linear-gradient(135deg, #fff, #e0e0e0);
            color: #333;
        }

        .combat-dial-move.Gold {
            border-left-color: #ffd700;
        }

        .combat-dial-move.Gold .combat-dial-move-color {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
        }

        .combat-dial-move.Purple {
            border-left-color: #a855f7;
        }

        .combat-dial-move.Purple .combat-dial-move-color {
            background: linear-gradient(135deg, #a855f7, #c084fc);
            color: #fff;
        }

        .combat-dial-move.Blue {
            border-left-color: #3b82f6;
        }

        .combat-dial-move.Blue .combat-dial-move-color {
            background: linear-gradient(135deg, #3b82f6, #60a5fa);
            color: #fff;
        }

        .combat-dial-move.Red {
            border-left-color: #ef4444;
        }

        .combat-dial-move.Red .combat-dial-move-color {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: #fff;
        }

        .combat-dial-footer {
            text-align: center;
            font-size: 12px;
            color: #888;
            font-style: italic;
            padding-top: 8px;
        }

        /* Turn Indicator */
        .turn-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 18px;
            font-weight: 600;
            z-index: 1500;
            border: 2px solid #ffd700;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .turn-indicator.active {
            display: block;
            animation: bounceIn 0.5s ease;
        }

        @keyframes bounceIn {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        .turn-indicator.player-turn {
            border-color: #28a745;
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.9) 0%, rgba(34, 139, 58, 0.9) 100%);
        }

        .turn-indicator.opponent-turn {
            border-color: #dc3545;
            background: linear-gradient(135deg, rgba(220, 53, 69, 0.9) 0%, rgba(200, 35, 51, 0.9) 100%);
        }

        /* REMOVED: No hover effects on points */

        /* Robot Visual Styles */
        .robot-visual.selected-robot {
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.8) !important;
            border-color: #ffc107 !important;
        }

        /* Adjacent Enemy Highlight */
        .point.adjacent-enemy {
            animation: enemyPulse 1.5s ease-in-out infinite;
        }

        @keyframes enemyPulse {
            0%, 100% { 
                fill: #ff4444;
                filter: drop-shadow(0 0 3px rgba(255, 68, 68, 0.6));
            }
            50% { 
                fill: #ff6666;
                filter: drop-shadow(0 0 8px rgba(255, 68, 68, 0.9));
            }
        }

        /* Valid Move Highlight */
        .point.valid-move {
            fill: #44ff44 !important;
            animation: validMovePulse 1.5s ease-in-out infinite;
            cursor: pointer !important;
        }
        
        /* Standard points use transparent fill when valid move (image shows instead) */
        .standard-point.valid-move {
            fill: none !important;
        }
        
        /* Static space background images - never clickable */
        .space-background-image {
            pointer-events: none !important;
        }
        
        /* Movable space image (only visible when point has valid-move class) */
        .movable-space-image {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 10; /* Ensure images are above other elements */
        }
        
        .movable-space-image.active {
            opacity: 1;
            animation: movableSpacePulse 1.5s ease-in-out infinite;
            pointer-events: all !important; /* Make image clickable */
            cursor: pointer !important;
        }
        
        @keyframes movableSpacePulse {
            0%, 100% { 
                opacity: 0.85;
                filter: drop-shadow(0 0 5px rgba(0, 255, 255, 0.6));
            }
            50% { 
                opacity: 1;
                filter: drop-shadow(0 0 12px rgba(0, 255, 255, 0.9));
            }
        }
        
        /* Entry space image (always visible on entry points) */
        .entry-space-image {
            opacity: 0.9;
            pointer-events: none; /* Entry points use their own click handlers */
        }
        
        /* Highlight entry space when valid for deployment */
        .entry-space-image.valid-deployment {
            opacity: 1;
            animation: entrySpacePulse 1.5s ease-in-out infinite;
        }
        
        @keyframes entrySpacePulse {
            0%, 100% { 
                opacity: 0.85;
                filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.6));
            }
            50% { 
                opacity: 1;
                filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.9));
            }
        }
        
        /* Goal space image (always visible on goal points) */
        .goal-space-image {
            opacity: 0.95;
            pointer-events: none; /* Goal points use their own click handlers */
        }
        
        /* Highlight goal space when it's a valid move target */
        .goal-space-image.valid-goal {
            opacity: 1;
            animation: goalSpacePulse 1.5s ease-in-out infinite;
        }
        
        @keyframes goalSpacePulse {
            0%, 100% { 
                opacity: 0.9;
                filter: drop-shadow(0 0 8px rgba(0, 255, 0, 0.7));
            }
            50% { 
                opacity: 1;
                filter: drop-shadow(0 0 20px rgba(0, 255, 0, 1));
            }
        }

        @keyframes validMovePulse {
            0%, 100% { 
                filter: drop-shadow(0 0 3px rgba(68, 255, 68, 0.6));
            }
            50% { 
                filter: drop-shadow(0 0 8px rgba(68, 255, 68, 0.9));
            }
        }

        /* Attackable Enemy Red Glow Pulse Animation */
        @keyframes attackableEnemyPulse {
            0%, 100% { 
                filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.7));
                transform: scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 25px rgba(255, 0, 0, 1));
                transform: scale(1.05);
            }
        }
        
        .attackable-enemy circle {
            animation: attackableEnemyPulse 1s ease-in-out infinite;
        }

        /* Valid Deployment Highlight */
        .point.valid-deployment {
            fill: #4444ff !important;
            animation: deploymentPulse 1.5s ease-in-out infinite;
            cursor: pointer !important;
        }

        @keyframes deploymentPulse {
            0%, 100% { 
                filter: drop-shadow(0 0 3px rgba(68, 68, 255, 0.6));
            }
            50% { 
                filter: drop-shadow(0 0 8px rgba(68, 68, 255, 0.9));
            }
        }

        /* Battle Robot Selected State - NO SCALING */
        .battle-robot.selected-robot {
            /* Removed scale transform - robots stay stationary */
            box-shadow: 0 0 20px rgba(255, 215, 0, 1) !important;
            border-color: #ffd700 !important;
            border-width: 4px !important;
            z-index: 200 !important;
        }

        /* Bench Robot Styles */
        .bench-robot {
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 4px;
        }

        .bench-robot:hover {
            transform: scale(1.05);
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .bench-robot.selected {
            border-color: #ffd700 !important;
            background: rgba(255, 215, 0, 0.2) !important;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .bench-robot-image {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .bench-robot-name {
            font-size: 10px;
            font-weight: 600;
            margin-top: 2px;
        }

        .bench-robot-mp {
            font-size: 9px;
            color: var(--text-secondary);
        }

        /* First-Turn Unplayable Robot Styles */
        .bench-robot.unplayable-first-turn {
            position: relative;
            pointer-events: auto; /* Allow clicks to show error message */
        }

        .bench-robot.unplayable-first-turn:hover {
            transform: none !important;
            border-color: #ff4444 !important;
            background: rgba(255, 68, 68, 0.1) !important;
        }

        .unplayable-badge {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(255, 68, 68, 0.9);
            color: white;
            font-size: 7px;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 10;
            pointer-events: none;
        }

        /* Debug Mode Turn Indicator */
        .turn-indicator button:hover {
            background: #ffed4e !important;
            transform: translateY(-1px);
        }

        /* REMOVED: All battle-robot transitions and hover effects to keep robots stationary */
        
        /* Battle Robot Hover - Visual feedback only (NO movement/scaling) */
        .battle-robot {
            cursor: pointer !important;
        }
        
        .battle-robot:hover circle:first-of-type {
            filter: drop-shadow(0 6px 12px rgba(0,0,0,0.6)) !important;
            stroke-width: 8 !important;
            opacity: 0.9 !important;
        }
        
        /* Ensure all robot elements show pointer cursor */
        .battle-robot * {
            cursor: pointer !important;
        }
        
        .team-actions {
            display: flex;
            gap: 12px;
            padding: 16px;
        }
        
        .team-actions .btn {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .team-actions .btn.primary {
            background: var(--primary);
            color: white;
        }
        
        .team-actions .btn.primary:hover:not(:disabled) {
            background: var(--primary-dark);
        }
        
        .team-actions .btn.primary:disabled {
            background: var(--border);
            color: var(--text-secondary);
            cursor: not-allowed;
        }
        
        .team-actions .btn.secondary {
            background: var(--surface);
            color: var(--text);
            border: 2px solid var(--border);
        }
        
        .team-actions .btn.secondary:hover {
            border-color: var(--primary);
            color: var(--primary);
        }
        
        /* Deploy Footer (Fixed) */
        .deploy-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-width: 480px;
            margin: 0 auto;
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 16px;
            z-index: 20;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .deploy-button {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: var(--primary);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .deploy-button:hover:not(:disabled) {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .deploy-button:disabled {
            background: var(--border);
            color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .deploy-text {
            font-size: 16px;
        }
        
        .deploy-icon {
            font-size: 18px;
        }
        
        .deploy-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .action-btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--surface);
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .action-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }
        
        /* Shake animation for feedback */
        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) translateX(0); }
            25% { transform: translate(-50%, -50%) translateX(-5px); }
            75% { transform: translate(-50%, -50%) translateX(5px); }
        }
        
        /* Battle Phase Management */

@media (max-width: 480px) {
    .game-field {
        margin: 0;
        padding: 0;
    }
}

@media (orientation: landscape) and (max-height: 600px) {
    .game-field {
        padding: 0;
        margin: 0;
    }
}

        /* SVG Styles */
        .route {
            stroke: var(--text);
            stroke-width: 3.5;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .point {
            stroke: var(--text);
            stroke-width: 3;
            fill: var(--surface);
            cursor: pointer;
            /* NO transitions - static board */
        }

        /* REMOVED: No hover effects - static chess board */

        .standard-point {
            stroke-width: 2.5;
            fill: none !important; /* Transparent to show space image behind */
        }

        .entry-ring {
            stroke: var(--text);
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
        }

        .entry-inner {
            stroke: var(--text);
            stroke-width: 2;
            fill: none;
        }

        .pokeball-line {
            stroke: var(--text);
            stroke-width: 3;
            stroke-linecap: round;
        }

        .goal-triangle {
            stroke: var(--text);
            stroke-width: 2;
            fill: var(--text);
        }

        .goal-point .point {
            stroke-width: 3.5;
        }

        .entry-point .point {
            stroke-width: 3;
            fill: var(--surface);
        }

        /* ========================================== */
        /* FIRST TURN SPINNER - DATA DISK STYLE */
        /* ========================================== */
        
        .first-turn-spinner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.5s ease;
        }
        
        .spinner-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
        }
        
        .spinner-container {
            position: relative;
            width: 400px;
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }
        
        .spinner-title {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            font-size: 36px;
            font-weight: 900;
            letter-spacing: 4px;
            color: #ffffff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            z-index: 1001;
        }
        
        .first-turn-wheel-wrapper {
            position: relative;
            width: 320px;
            height: 320px;
        }
        
        /* Static Pointer at 12 o'clock */
        .spinner-pointer {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: #ffd700;
            filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.9));
            z-index: 1003;
        }
        
        .spinner-pointer::before {
            content: '▼';
        }
        
        /* First Turn Wheel */
        .first-turn-wheel {
            position: relative;
            width: 320px;
            height: 320px;
            border-radius: 50%;
            overflow: visible;
            box-shadow: 
                0 0 40px rgba(0, 200, 255, 0.6),
                0 0 80px rgba(255, 50, 50, 0.4),
                inset 0 0 30px rgba(0, 0, 0, 0.5);
            border: 6px solid rgba(255, 255, 255, 0.4);
        }
        
        .first-turn-wheel::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #ffffff 0%, #cccccc 70%, #999999 100%);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.8),
                inset 0 2px 10px rgba(0, 0, 0, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.6);
            z-index: 10;
        }
        
        .first-turn-wheel .wheel-segments {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            transition: transform 3.5s cubic-bezier(0.22, 0.61, 0.36, 1);
        }
        
        /* Labels on wheel segments */
        .first-turn-label {
            position: absolute;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            font-size: 28px;
            font-weight: 900;
            letter-spacing: 3px;
            color: #ffffff;
            text-shadow: 
                0 0 10px rgba(0, 0, 0, 0.9),
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px currentColor;
            pointer-events: none;
            white-space: nowrap;
        }
        
        /* Result Text */
        .spinner-result {
            position: absolute;
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            font-size: 28px;
            font-weight: 900;
            letter-spacing: 2px;
            color: #ffffff;
            text-shadow: 0 0 20px currentColor;
            opacity: 0;
            white-space: nowrap;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }
        
        @keyframes resultFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        @keyframes winnerPulse {
            0%, 100% {
                filter: brightness(1.2);
            }
            50% {
                filter: brightness(1.6);
            }
        }

        /* Responsive Design - Android Optimized */
        @media (max-width: 480px) {
            .battle-content {
                padding: 0;
            }
            .player-zone {
                gap: 2px;
                padding: 0;
                overflow: visible;
            }
            .repair-slot {
                width: 40px;
                height: 40px;
            }
            
            .bench-slot {
                width: 38px;
                height: 38px;
            }
            
            .point {
                width: 16px;
                height: 16px;
            }
            
            .entry-point {
                width: 22px;
                height: 22px;
            }
            
            .goal-point {
                width: 20px;
                height: 20px;
            }
            
            .standard-point {
                width: 14px;
                height: 14px;
            }
        }
        
        /* Combat Tester Modal */
        .combat-tester-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        .combat-tester-modal.active {
            display: flex;
        }
        .combat-tester-content {
            background: var(--bg);
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .combat-tester-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 1px solid var(--border);
        }
        .combat-tester-header h2 {
            margin: 0;
            color: var(--text-primary);
            font-size: 24px;
        }
        .combat-tester-close {
            background: none;
            border: none;
            font-size: 30px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        .combat-tester-close:hover {
            background: var(--border);
            color: var(--text-primary);
        }
        .combat-tester-body {
            padding: 30px;
        }
        .combat-setup {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            margin-bottom: 30px;
            align-items: start;
        }
        .robot-selector h3 {
            margin: 0 0 15px 0;
            color: var(--text-primary);
            text-align: center;
        }
        .robot-select-dropdown {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 10px;
            background: var(--bg);
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 15px;
        }
        .robot-info {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid var(--border);
        }
        .robot-info h4 {
            margin: 0 0 10px 0;
            color: var(--text-primary);
        }
        .robot-info .robot-stats {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        .robot-wheel {
            display: grid;
            gap: 5px;
        }
        .wheel-segment {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
        }
        .vs-divider {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .vs-text {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            background: var(--bg-secondary);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border);
        }
        .battle-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .battle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        .combat-results {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }
        .combat-results h3 {
            margin: 0 0 15px 0;
            color: var(--text-primary);
        }
        .battle-outcome {
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .spin-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .spin-result {
            background: var(--bg);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        .combat-stats {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--border);
        }
        .combat-stats h3 {
            margin: 0 0 15px 0;
            color: var(--text-primary);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }
        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .stats-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .stats-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .stats-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        /* V-Mount Battle Spinner - Authentic Pokémon Duel Style */
        .disk-battle-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 4000;
        }
        .disk-battle-modal.active {
            display: flex;
        }
        .disk-battle-arena {
            width: 95%;
            max-width: 1200px;
            text-align: center;
            color: white;
            position: relative;
        }
        .battle-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
            color: #FFD700;
            letter-spacing: 2px;
        }
        .robot-names {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: 600;
            padding: 0 100px;
        }
        .robot-name {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* V-Mount Assembly - Battle-spin.jpg Style */
        .v-mount-container {
            position: relative;
            width: 700px;
            height: 450px;
            margin: 20px auto;
            perspective: 1200px;
        }
        
        /* Vertical Battle Container - User Bottom, Opponent Top */
        .vertical-battle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
            position: relative;
            margin: 20px auto;
            height: 500px;
            width: 400px;
            perspective: 1200px;
            padding: 20px 0;
        }
        
        .opponent-battle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .user-battle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .central-pointer-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            z-index: 10;
            position: relative;
            flex-shrink: 0;
        }
        
        .battle-pointer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }
        
        .pointer-line {
            width: 3px;
            height: 40px;
            background: linear-gradient(to bottom, #ff6b6b, #ffd93d, #ff6b6b);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
            border-radius: 2px;
        }
        
        .vs-indicator {
            font-size: 16px;
            font-weight: bold;
            color: #ffd93d;
            text-shadow: 0 0 15px rgba(255, 217, 61, 0.8);
            padding: 6px 16px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            border: 2px solid #ffd93d;
            backdrop-filter: blur(5px);
        }
        
        .opponent-name {
            color: #ff6b6b !important;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
            font-size: 16px;
            font-weight: bold;
            margin: 0;
        }
        
        .user-name {
            color: #4ecdc4 !important;
            text-shadow: 0 0 10px rgba(78, 205, 196, 0.8);
            font-size: 16px;
            font-weight: bold;
            margin: 0;
        }
        
        .opponent-battle-section,
        .user-battle-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .opponent-disk .data-disk {
            transform: rotateX(15deg) rotateY(-5deg);
        }
        
        .user-disk .data-disk {
            transform: rotateX(-15deg) rotateY(5deg);
        }
        
        /* Data Disk Spin Animation System */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        .spinning {
            animation-name: spin;
            animation-duration: 0.1s; /* VERY FAST SPIN - 0.1s per rotation = 10 rotations/second */
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }
        
        /* Smooth transition for final position - DISABLED to prevent animation conflicts */
        /* .disk-wheel svg,
        .disk-wheel img {
            transition: transform 1s ease-out;
        } */
        
        /* Move Display Styling */
        .move-display {
            color: #ffd93d;
            font-size: 14px;
            font-weight: bold;
            height: 25px;
            margin: 8px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Central Diamond Pointer - Sharp Blade Design */
        .central-diamond-pointer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 80px;
            z-index: 200;
        }
        
        .diamond-shape {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #dc2626, #b91c1c, #991b1b);
            transform: rotate(45deg);
            border-radius: 2px;
            box-shadow: 
                0 0 15px rgba(220, 38, 38, 0.8),
                inset 2px 2px 8px rgba(255, 255, 255, 0.3),
                inset -2px -2px 8px rgba(0, 0, 0, 0.4);
            border: 1px solid #7f1d1d;
            position: relative;
            opacity: 1;
        }
        
        /* Sharp 3D Beveled Edges */
        .diamond-shape::before {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, transparent 30%, transparent 70%, rgba(0, 0, 0, 0.3) 100%);
            border-radius: 1px;
        }
        
        /* Sharp Highlight Edge */
        .diamond-shape::after {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.3));
            border-radius: 1px;
        }
        
        /* Sharp Pointer Glow Effects */
        .diamond-shape.left-wins {
            box-shadow: 
                -25px 0 40px rgba(34, 197, 94, 0.9),
                0 0 15px rgba(220, 38, 38, 0.8),
                inset 2px 2px 8px rgba(255, 255, 255, 0.3),
                inset -2px -2px 8px rgba(0, 0, 0, 0.4);
            animation: leftWinFlash 0.8s ease-in-out 4;
        }
        
        .diamond-shape.right-wins {
            box-shadow: 
                25px 0 40px rgba(34, 197, 94, 0.9),
                0 0 15px rgba(220, 38, 38, 0.8),
                inset 2px 2px 8px rgba(255, 255, 255, 0.3),
                inset -2px -2px 8px rgba(0, 0, 0, 0.4);
            animation: rightWinFlash 0.8s ease-in-out 4;
        }
        
        .diamond-shape.draw {
            box-shadow: 
                0 0 50px rgba(251, 191, 36, 1.0),
                inset 2px 2px 8px rgba(255, 255, 255, 0.3),
                inset -2px -2px 8px rgba(0, 0, 0, 0.4);
            animation: drawFlash 0.8s ease-in-out 4;
        }
        
        @keyframes leftWinFlash {
            0%, 100% { 
                transform: rotate(45deg) scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: rotate(45deg) scale(1.15);
                filter: brightness(1.4);
            }
        }
        
        @keyframes rightWinFlash {
            0%, 100% { 
                transform: rotate(45deg) scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: rotate(45deg) scale(1.15);
                filter: brightness(1.4);
            }
        }
        
        @keyframes drawFlash {
            0%, 100% { 
                transform: rotate(45deg) scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: rotate(45deg) scale(1.1);
                filter: brightness(1.3);
            }
        }
        
        /* V-Mount Disk Positioning - Overlapping Formation */
        .disk-wrapper {
            position: absolute;
            width: 320px;
            height: 320px;
        }
        .disk-wrapper.left {
            left: 80px;
            top: 65px;
            transform: rotateY(-20deg) rotateZ(-8deg);
            z-index: 50;
        }
        .disk-wrapper.right {
            right: 80px;
            top: 65px;
            transform: rotateY(20deg) rotateZ(8deg);
            z-index: 40;
        }
        
        /* Data Disk Styling */
        .data-disk {
            width: 100%;
            height: 100%;
            position: relative;
            border-radius: 50%;
            border: 6px solid #2c3e50;
            box-shadow: 
                0 0 30px rgba(0, 0, 0, 0.8),
                inset 0 0 20px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease;
            background: radial-gradient(circle at center, #34495e 0%, #2c3e50 100%);
        }
        .data-disk.winner {
            border-color: #27ae60;
            box-shadow: 
                0 0 50px rgba(39, 174, 96, 0.8),
                inset 0 0 20px rgba(39, 174, 96, 0.2);
        }
        .data-disk.loser {
            border-color: #e74c3c;
            box-shadow: 
                0 0 50px rgba(231, 76, 60, 0.6),
                inset 0 0 20px rgba(231, 76, 60, 0.2);
            opacity: 0.6;
        }
        .data-disk.draw {
            border-color: #f39c12;
            box-shadow: 
                0 0 50px rgba(243, 156, 18, 0.8),
                inset 0 0 20px rgba(243, 156, 18, 0.2);
        }
        
        /* Spinning Wheel */
        .disk-wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            transition: transform 3.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* Disk Segments - Proper Pie Chart */
        .disk-segment {
            position: absolute;
            width: 50%;
            height: 50%;
            transform-origin: 100% 100%;
            overflow: hidden;
        }
        .segment-content {
            position: absolute;
            width: 200%;
            height: 200%;
            border-radius: 50%;
            transform: rotate(-90deg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            text-align: center;
            line-height: 1;
        }
        
        /* Center Hub */
        .disk-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #34495e, #2c3e50);
            border-radius: 50%;
            border: 4px solid #1a252f;
            z-index: 10;
            box-shadow: 
                0 0 15px rgba(0, 0, 0, 0.8),
                inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        /* Selected Move Highlight */
        .selected-move .segment-content {
            background: radial-gradient(circle, rgba(255, 215, 0, 0.4), transparent 70%) !important;
            box-shadow: 
                inset 0 0 30px rgba(255, 215, 0, 0.6),
                0 0 20px rgba(255, 215, 0, 0.4);
        }
        
        /* SVG Segment Styling */
        .svg-segment {
            transition: all 0.3s ease;
        }
        .svg-segment.selected {
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8)) brightness(1.3);
            stroke: #FFD700 !important;
            stroke-width: 3 !important;
        }
        
        /* Disk Wheel Animation - SVG and Image Support */
        .disk-wheel svg,
        .disk-wheel .wheel-image {
            transition: none;
        }
        
        /* Phase 1: Wind-up */
        .disk-wheel svg.wind-up,
        .disk-wheel .wheel-image.wind-up {
            animation: windUp 0.5s ease-out;
        }
        
        /* Phase 2: Peak Spin (Motion Blur) */
        .disk-wheel svg.peak-spin,
        .disk-wheel .wheel-image.peak-spin {
            animation: peakSpin 2.5s linear;
            filter: blur(3px);
        }
        
        /* Phase 3: Deceleration */
        .disk-wheel svg.decelerate,
        .disk-wheel .wheel-image.decelerate {
            transition: transform 2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* Phase 4: Final Stop */
        .disk-wheel svg.stopped,
        .disk-wheel .wheel-image.stopped {
            transition: transform 0.3s ease-out;
        }
        
        @keyframes windUp {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(180deg); }
        }
        
        @keyframes peakSpin {
            0% { transform: rotate(180deg); }
            100% { transform: rotate(2340deg); } /* 6 full rotations */
        }
        
        /* Sparks Effect */
        .sparks-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            z-index: 150;
            pointer-events: none;
        }
        
        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #fbbf24, #f59e0b);
            border-radius: 50%;
            opacity: 0;
        }
        
        .sparks-active .spark {
            animation: sparkFly 0.8s ease-out infinite;
        }
        
        @keyframes sparkFly {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--spark-x, 0), var(--spark-y, 0)) scale(0.3);
            }
        }
        /* Battle Results */
        .battle-outcome {
            margin-top: 30px;
            font-size: 32px;
            font-weight: 700;
            text-shadow: 0 3px 6px rgba(0, 0, 0, 0.7);
            letter-spacing: 1px;
        }
        .outcome-winner {
            color: #27ae60;
            text-shadow: 0 0 20px rgba(39, 174, 96, 0.5);
        }
        .outcome-loser {
            color: #e74c3c;
        }
        .outcome-draw {
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }
        
        /* Move Details Panel */
        .move-details {
            display: flex;
            justify-content: center;
            margin-top: 25px;
            gap: 30px;
        }
        .move-detail {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 150px;
        }
        .move-name {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        .move-type {
            font-size: 12px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        /* Continue Button */
        .continue-btn {
            margin-top: 30px;
            padding: 12px 35px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            letter-spacing: 0.5px;
        }
        .continue-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
            background: linear-gradient(135deg, #2980b9, #3498db);
        }
    </style>
</head>
<body>
    <svg style="display: none;">
        <symbol id="icon-plus" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
        </symbol>
        <symbol id="icon-back" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd" />
        </symbol>
        <symbol id="icon-edit" viewBox="0 0 20 20" fill="currentColor">
            <path d="M10 6a2 2 0 11-4 0 2 2 0 014 0zM12 6a2 2 0 11-4 0 2 2 0 014 0zM14 6a2 2 0 11-4 0 2 2 0 014 0z" />
        </symbol>
        <symbol id="icon-checkmark" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
        </symbol>
        <symbol id="icon-snooze" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
        </symbol>
    </svg>

    <!-- Currency Display -->
    <div class="currency-display" id="currencyDisplay">
        <img src="Imag/Achivments/Images/Finished Images/Bolt.png" alt="Bolt" class="currency-display-bolt">
        <img src="Imag/Achivments/Images/Finished Images/X.png" alt="x" class="currency-display-x">
        <span class="currency-display-amount" id="currencyAmount">0</span>
    </div>
    
    <!-- Missions Bubble -->
    <div class="missions-bubble" id="missionsBubble" onclick="app.openMissions()">
        <img src="Imag/Achivments/Images/Finished Images/Missions.png" alt="Missions">
    </div>
    
    <button class="settings-btn" id="settingsBtn" onclick="app.showSettingsModal()"><img src="Imag/Settings.png" alt="Settings"></button>
    
    <div class="app">
        <div id="dashboardView" class="view active">
            <div class="header">
                <div class="header-top">
                    <div style="visibility: hidden; width: 36px;"></div>
                    <div></div>
                    <div style="visibility: hidden; width: 36px;"></div>
                </div>
            </div>

            <div class="content-top">
                <img src="Imag/LOGO.png" alt="Upkeep" class="app-logo">
                <div class="score-card">
                    <div class="progress-bar">
                        <div class="progress-fill" id="overallProgress" style="width: 0%"></div>
                        <div class="score-value-inner" id="overallScore">0%</div>
                    </div>
                    <div class="save-file-name" id="saveFileDisplay">Default Save</div>
                </div>
            </div>

            <div class="content-bottom">
                <div class="category-list" id="categoryList"></div>
            </div>

            <button class="fab" onclick="app.showAddCategoryModal()"><img src="Imag/Add.png" alt="Add Category"></button>
        </div>

        <div id="categoryView" class="view">
            <div class="header">
                <div class="header-top">
                    <button class="back-btn" onclick="app.showDashboard()"><img src="Imag/Back.png" alt="Back"></button>
                    <div style="flex: 1; text-align: center;">
                        <h1 id="categoryTitle">Category</h1>
                    </div>
                    <button class="edit-btn-img" onclick="app.showEditCategoryModal()"><img src="Imag/edit-category.png" alt="Edit Category"></button>
                </div>
            </div>

            <div class="content">
                <div class="section-header">
                    <div class="section-title">Tasks</div>
                    <button class="fab" onclick="app.showAddTaskModal()"><img src="Imag/Add.png" alt="Add Task"></button>
                </div>
                <div class="task-list" id="taskList"></div>
            </div>
        </div>

        <!-- Battle System View -->
        <div id="battleView" class="view">
            <div class="header">
                <div class="header-top">
                    <button class="back-btn" onclick="app.exitBattleSystem()"><img src="Imag/Back.png" alt="Back"></button>
                    <div style="display: none;">
                        <h1 id="battleTitle">🤖 Team Selection</h1>
                        <div class="tagline" id="battleSubtitle">Choose 6 robots for battle</div>
                    </div>
                    <div style="width: 50px;"></div>
                </div>
            </div>

            <!-- Team Selection Phase -->
            <div id="teamSelectionPhase" class="battle-phase">
                <div class="content" style="padding-top: 80px;">
                    <!-- Active Squad (Fixed Header) -->
                    <div class="active-squad-header">
                        <div class="squad-title">
                            <h3>Active Squad</h3>
                            <div class="squad-counter">
                                <span id="teamCount">0</span>/6 Robots
                            </div>
                        </div>
                        <div class="active-squad-slots" id="selectedTeamGrid">
                            <div class="squad-slot empty" data-slot="0">
                                <div class="slot-number">1</div>
                                <div class="slot-label">Empty</div>
                            </div>
                            <div class="squad-slot empty" data-slot="1">
                                <div class="slot-number">2</div>
                                <div class="slot-label">Empty</div>
                            </div>
                            <div class="squad-slot empty" data-slot="2">
                                <div class="slot-number">3</div>
                                <div class="slot-label">Empty</div>
                            </div>
                            <div class="squad-slot empty" data-slot="3">
                                <div class="slot-number">4</div>
                                <div class="slot-label">Empty</div>
                            </div>
                            <div class="squad-slot empty" data-slot="4">
                                <div class="slot-number">5</div>
                                <div class="slot-label">Empty</div>
                            </div>
                            <div class="squad-slot empty" data-slot="5">
                                <div class="slot-number">6</div>
                                <div class="slot-label">Empty</div>
                            </div>
                        </div>
                    </div>

                    <!-- Robot Bay (Main Content) -->
                    <div class="robot-bay-container">
                        <div class="bay-header">
                            <h3>🤖 Robot Bay</h3>
                            <div class="bay-subtitle">Select robots for your squad</div>
                        </div>
                        <div class="robot-bay-grid" id="robotsGrid">
                            <!-- Robot cards will be populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Deploy Button (Fixed Footer) -->
                    <div class="deploy-footer">
                        <button class="deploy-button" id="startBattleBtn" onclick="app.startBattleWithTeam()" disabled>
                            <span class="deploy-text">Deploy for Battle</span>
                            <span class="deploy-icon">⚔️</span>
                        </button>
                        <div class="deploy-actions">
                            <button class="action-btn" onclick="TeamManager.clearTeam(); app.updateTeamSelectionUI()">Clear All</button>
                            <button class="action-btn" onclick="TeamManager.autoFillTeam(); app.updateTeamSelectionUI()">Auto-Fill</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Battle Game Phase -->
            <div id="battleGamePhase" class="battle-phase" style="display: none;">
            <div class="battle-content">
                <!-- Opponent Zone (Above Game Field) -->
                <div id="opponent-zone" class="player-zone opponent-player" data-team="opponent" data-zone="opponent-area">
                    <div id="opponent-repair-bay" class="repair-bay" data-type="repair-bay" data-capacity="2" data-team="opponent">
                        <div id="opponent-repair-slot-1" class="repair-slot" data-slot="opponent-repair-1" data-occupied="false" data-robot-id="" data-position="slot-1">
                            <span class="repair-icon">🔧</span>
                        </div>
                        <div id="opponent-repair-slot-2" class="repair-slot" data-slot="opponent-repair-2" data-occupied="false" data-robot-id="" data-position="slot-2">
                            <span class="repair-icon">🔧</span>
                        </div>
                    </div>
                    <div id="opponent-bench-section" class="bench-section" data-type="bench" data-capacity="6">
                        <div class="bench-row primary">
                            <div id="opponent-bench-slot-3" class="bench-slot" data-slot="opponent-bench-3" data-occupied="false" data-robot-id="" data-position="primary-1"></div>
                            <div id="opponent-bench-slot-4" class="bench-slot" data-slot="opponent-bench-4" data-occupied="false" data-robot-id="" data-position="primary-2"></div>
                            <div id="opponent-bench-slot-5" class="bench-slot" data-slot="opponent-bench-5" data-occupied="false" data-robot-id="" data-position="primary-3"></div>
                            <div id="opponent-bench-slot-6" class="bench-slot" data-slot="opponent-bench-6" data-occupied="false" data-robot-id="" data-position="primary-4"></div>
                        </div>
                        <div class="bench-row secondary">
                            <div id="opponent-bench-slot-1" class="bench-slot offset-1" data-slot="opponent-bench-1" data-occupied="false" data-robot-id="" data-position="secondary-left"></div>
                            <div id="opponent-bench-slot-2" class="bench-slot offset-2" data-slot="opponent-bench-2" data-occupied="false" data-robot-id="" data-position="secondary-right"></div>
                        </div>
                    </div>
                </div>

                <!-- Central Game Field -->
                <div class="game-field">
                    
                    <!-- ========================================== -->
                    <!-- FIRST TURN SPINNER OVERLAY -->
                    <!-- ========================================== -->
                    <div class="first-turn-spinner-overlay" id="firstTurnSpinner" style="display: none;">
                        <div class="spinner-backdrop"></div>
                        
                        <div class="spinner-container">
                            <div class="spinner-title">WHO GOES FIRST?</div>
                            
                            <!-- Spinning Wheel -->
                            <div class="first-turn-wheel-wrapper">
                                <!-- Static Pointer at 12 o'clock -->
                                <div class="spinner-pointer"></div>
                                
                                <div class="first-turn-wheel" id="firstTurnWheel">
                                    <div class="wheel-segments" id="firstTurnWheelSegments"></div>
                                </div>
                            </div>
                            
                            <!-- Result Text -->
                            <div class="spinner-result" id="spinnerResult"></div>
                        </div>
                    </div>
                    

                    <svg viewBox="0 0 665 700" class="battle-board-svg" preserveAspectRatio="xMidYMid meet">
                        <!-- Definitions -->
                        <defs>
                            <!-- Space Image Pattern -->
                            <pattern id="spacePattern" x="0" y="0" width="1" height="1" patternContentUnits="objectBoundingBox">
                                <image href="Imag/Battle/Space.png" x="0" y="0" width="1" height="1" preserveAspectRatio="xMidYMid slice"/>
                            </pattern>
                        </defs>
                        
                        <!-- Route Lines -->
                        <!-- Outer Rectangle Routes -->
                        <line class="route" x1="67" y1="100" x2="599" y2="100" />
                        <line class="route" x1="67" y1="600" x2="599" y2="600" />
                        <line class="route" x1="67" y1="100" x2="67" y2="600" />
                        <line class="route" x1="599" y1="100" x2="599" y2="600" />

                        <!-- Inner Square Routes (Perfect Square) -->
                        <line class="route" x1="200" y1="250" x2="466" y2="250" />
                        <line class="route" x1="200" y1="450" x2="466" y2="450" />
                        <line class="route" x1="200" y1="250" x2="200" y2="450" />
                        <line class="route" x1="466" y1="250" x2="466" y2="450" />

                        <!-- Diagonal Routes -->
                        <line class="route" x1="67" y1="100" x2="200" y2="250" />
                        <line class="route" x1="599" y1="100" x2="466" y2="250" />
                        <line class="route" x1="67" y1="600" x2="200" y2="450" />
                        <line class="route" x1="599" y1="600" x2="466" y2="450" />

                        <!-- Special Routes: R points adjacent to Goals connect to inner square -->
                        <!-- Top row: R point to the left of Goal connects to top middle of inner square -->
                        <line class="route" x1="266" y1="100" x2="333" y2="250" />
                        <!-- Bottom row: R point to the right of Goal connects to bottom middle of inner square -->
                        <line class="route" x1="399" y1="600" x2="333" y2="450" />

                        <!-- Horizontal connecting routes for outer rectangle -->
                        <line class="route" x1="67" y1="100" x2="166" y2="100" />
                        <line class="route" x1="166" y1="100" x2="266" y2="100" />
                        <line class="route" x1="266" y1="100" x2="333" y2="100" />
                        <line class="route" x1="333" y1="100" x2="399" y2="100" />
                        <line class="route" x1="399" y1="100" x2="499" y2="100" />
                        <line class="route" x1="499" y1="100" x2="599" y2="100" />
                        
                        <line class="route" x1="67" y1="600" x2="166" y2="600" />
                        <line class="route" x1="166" y1="600" x2="266" y2="600" />
                        <line class="route" x1="266" y1="600" x2="333" y2="600" />
                        <line class="route" x1="333" y1="600" x2="399" y2="600" />
                        <line class="route" x1="399" y1="600" x2="499" y2="600" />
                        <line class="route" x1="499" y1="600" x2="599" y2="600" />

                        <!-- Vertical connecting routes for outer rectangle -->
                        <line class="route" x1="67" y1="100" x2="67" y2="224" />
                        <line class="route" x1="67" y1="224" x2="67" y2="350" />
                        <line class="route" x1="67" y1="350" x2="67" y2="476" />
                        <line class="route" x1="67" y1="476" x2="67" y2="600" />
                        
                        <line class="route" x1="599" y1="100" x2="599" y2="224" />
                        <line class="route" x1="599" y1="224" x2="599" y2="350" />
                        <line class="route" x1="599" y1="350" x2="599" y2="476" />
                        <line class="route" x1="599" y1="476" x2="599" y2="600" />

                        <!-- Space Images for Standard Points (70x70 for better clickability) -->
                        <!-- Top row images -->
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="131" y="65" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-top-1" href="Imag/Battle/Movable-space.png" x="131" y="65" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="231" y="65" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-top-2" href="Imag/Battle/Movable-space.png" x="231" y="65" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="364" y="65" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-top-3" href="Imag/Battle/Movable-space.png" x="364" y="65" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="464" y="65" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-top-4" href="Imag/Battle/Movable-space.png" x="464" y="65" width="70" height="70"/>
                        
                        <!-- Left column images -->
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="32" y="189" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-left-1" href="Imag/Battle/Movable-space.png" x="32" y="189" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="32" y="315" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-left-2" href="Imag/Battle/Movable-space.png" x="32" y="315" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="32" y="441" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-left-3" href="Imag/Battle/Movable-space.png" x="32" y="441" width="70" height="70"/>
                        
                        <!-- Right column images -->
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="564" y="189" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-right-1" href="Imag/Battle/Movable-space.png" x="564" y="189" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="564" y="315" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-right-2" href="Imag/Battle/Movable-space.png" x="564" y="315" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="564" y="441" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-right-3" href="Imag/Battle/Movable-space.png" x="564" y="441" width="70" height="70"/>
                        
                        <!-- Bottom row images -->
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="131" y="565" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-bottom-1" href="Imag/Battle/Movable-space.png" x="131" y="565" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="231" y="565" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-bottom-2" href="Imag/Battle/Movable-space.png" x="231" y="565" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="364" y="565" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-bottom-3" href="Imag/Battle/Movable-space.png" x="364" y="565" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="464" y="565" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-bottom-4" href="Imag/Battle/Movable-space.png" x="464" y="565" width="70" height="70"/>
                        
                        <!-- Inner square corner images -->
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="165" y="215" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-tl" href="Imag/Battle/Movable-space.png" x="165" y="215" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="431" y="215" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-tr" href="Imag/Battle/Movable-space.png" x="431" y="215" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="165" y="415" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-bl" href="Imag/Battle/Movable-space.png" x="165" y="415" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="431" y="415" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-br" href="Imag/Battle/Movable-space.png" x="431" y="415" width="70" height="70"/>
                        
                        <!-- Inner square midpoint images -->
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="298" y="215" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-top" href="Imag/Battle/Movable-space.png" x="298" y="215" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="298" y="415" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-bottom" href="Imag/Battle/Movable-space.png" x="298" y="415" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="165" y="315" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-left" href="Imag/Battle/Movable-space.png" x="165" y="315" width="70" height="70"/>
                        <image class="space-background-image" href="Imag/Battle/Space.png" x="431" y="315" width="70" height="70" opacity="0.9"/>
                        <image class="movable-space-image" data-point="point-inner-right" href="Imag/Battle/Movable-space.png" x="431" y="315" width="70" height="70"/>
                        
                        <!-- Standard Points (22 total) -->
                        <!-- Top row: (E)(R)(R)(G)(R)(R)(E) -->
                        <circle id="point-top-1" class="point standard-point" cx="166" cy="100" r="7" data-type="route" data-position="top-1" data-x="166" data-y="100" data-occupied="false" data-team="neutral"/>
                        <circle id="point-top-2" class="point standard-point" cx="266" cy="100" r="7" data-type="route" data-position="top-2" data-x="266" data-y="100" data-occupied="false" data-team="neutral"/>
                        <circle id="point-top-3" class="point standard-point" cx="399" cy="100" r="7" data-type="route" data-position="top-3" data-x="399" data-y="100" data-occupied="false" data-team="neutral"/>
                        <circle id="point-top-4" class="point standard-point" cx="499" cy="100" r="7" data-type="route" data-position="top-4" data-x="499" data-y="100" data-occupied="false" data-team="neutral"/>
                        
                        <!-- Left column: 3 R points -->
                        <circle id="point-left-1" class="point standard-point" cx="67" cy="224" r="7" data-type="route" data-position="left-1" data-x="67" data-y="224" data-occupied="false" data-team="neutral"/>
                        <circle id="point-left-2" class="point standard-point" cx="67" cy="350" r="7" data-type="route" data-position="left-2" data-x="67" data-y="350" data-occupied="false" data-team="neutral"/>
                        <circle id="point-left-3" class="point standard-point" cx="67" cy="476" r="7" data-type="route" data-position="left-3" data-x="67" data-y="476" data-occupied="false" data-team="neutral"/>
                        
                        <!-- Right column: 3 R points -->
                        <circle id="point-right-1" class="point standard-point" cx="599" cy="224" r="7" data-type="route" data-position="right-1" data-x="599" data-y="224" data-occupied="false" data-team="neutral"/>
                        <circle id="point-right-2" class="point standard-point" cx="599" cy="350" r="7" data-type="route" data-position="right-2" data-x="599" data-y="350" data-occupied="false" data-team="neutral"/>
                        <circle id="point-right-3" class="point standard-point" cx="599" cy="476" r="7" data-type="route" data-position="right-3" data-x="599" data-y="476" data-occupied="false" data-team="neutral"/>
                        
                        <!-- Bottom row: (E)(R)(R)(G)(R)(R)(E) -->
                        <circle id="point-bottom-1" class="point standard-point" cx="166" cy="600" r="7" data-type="route" data-position="bottom-1" data-x="166" data-y="600" data-occupied="false" data-team="neutral"/>
                        <circle id="point-bottom-2" class="point standard-point" cx="266" cy="600" r="7" data-type="route" data-position="bottom-2" data-x="266" data-y="600" data-occupied="false" data-team="neutral"/>
                        <circle id="point-bottom-3" class="point standard-point" cx="399" cy="600" r="7" data-type="route" data-position="bottom-3" data-x="399" data-y="600" data-occupied="false" data-team="neutral"/>
                        <circle id="point-bottom-4" class="point standard-point" cx="499" cy="600" r="7" data-type="route" data-position="bottom-4" data-x="499" data-y="600" data-occupied="false" data-team="neutral"/>
                        
                        <!-- Inner square corners -->
                        <circle id="point-inner-tl" class="point standard-point" cx="200" cy="250" r="7" data-type="inner" data-position="inner-top-left" data-x="200" data-y="250" data-occupied="false" data-team="neutral"/>
                        <circle id="point-inner-tr" class="point standard-point" cx="466" cy="250" r="7" data-type="inner" data-position="inner-top-right" data-x="466" data-y="250" data-occupied="false" data-team="neutral"/>
                        <circle id="point-inner-bl" class="point standard-point" cx="200" cy="450" r="7" data-type="inner" data-position="inner-bottom-left" data-x="200" data-y="450" data-occupied="false" data-team="neutral"/>
                        <circle id="point-inner-br" class="point standard-point" cx="466" cy="450" r="7" data-type="inner" data-position="inner-bottom-right" data-x="466" data-y="450" data-occupied="false" data-team="neutral"/>
                        
                        <!-- Inner square midpoints -->
                        <circle id="point-inner-top" class="point standard-point" cx="333" cy="250" r="7" data-type="inner" data-position="inner-top-mid" data-x="333" data-y="250" data-occupied="false" data-team="neutral"/>
                        <circle id="point-inner-bottom" class="point standard-point" cx="333" cy="450" r="7" data-type="inner" data-position="inner-bottom-mid" data-x="333" data-y="450" data-occupied="false" data-team="neutral"/>
                        <circle id="point-inner-left" class="point standard-point" cx="200" cy="350" r="7" data-type="inner" data-position="inner-left-mid" data-x="200" data-y="350" data-occupied="false" data-team="neutral"/>
                        <circle id="point-inner-right" class="point standard-point" cx="466" cy="350" r="7" data-type="inner" data-position="inner-right-mid" data-x="466" data-y="350" data-occupied="false" data-team="neutral"/>

                        <!-- Goal Points (2 total) -->
                        <!-- Goal space images (always visible) - 70x70px -->
                        <image class="goal-space-image" data-goal="goal-opponent" href="Imag/Battle/Goal-space.png" x="298" y="65" width="70" height="70"/>
                        <image class="goal-space-image" data-goal="goal-player" href="Imag/Battle/Goal-space.png" x="298" y="565" width="70" height="70"/>
                        
                        <g id="goal-opponent" class="goal-point" data-type="goal" data-team="opponent" data-position="top-goal" data-x="333" data-y="100">
                            <circle class="point" cx="333" cy="100" r="12" data-occupied="false"/>
                            <path class="goal-triangle" d="M 333 90 L 343 110 L 323 110 Z"/>
                        </g>
                        <g id="goal-player" class="goal-point" data-type="goal" data-team="player" data-position="bottom-goal" data-x="333" data-y="600">
                            <circle class="point" cx="333" cy="600" r="12" data-occupied="false"/>
                            <path class="goal-triangle" d="M 333 610 L 343 590 L 323 590 Z"/>
                        </g>

                        <!-- Corner "Entry" Points (4 total) -->
                        <!-- Entry space images (always visible) - 70x70px for better visibility -->
                        <image class="entry-space-image" data-entry="entry-top-left" href="Imag/Battle/Entrey-space.png" x="32" y="65" width="70" height="70"/>
                        <image class="entry-space-image" data-entry="entry-top-right" href="Imag/Battle/Entrey-space.png" x="564" y="65" width="70" height="70"/>
                        <image class="entry-space-image" data-entry="entry-bottom-left" href="Imag/Battle/Entrey-space.png" x="32" y="565" width="70" height="70"/>
                        <image class="entry-space-image" data-entry="entry-bottom-right" href="Imag/Battle/Entrey-space.png" x="564" y="565" width="70" height="70"/>
                        
                        <g id="entry-top-left" class="entry-point" data-type="entry" data-position="top-left" data-x="67" data-y="100" data-team="neutral" data-spawn-point="true">
                            <circle class="entry-ring" cx="67" cy="100" r="20"/>
                            <circle class="entry-ring" cx="67" cy="100" r="15"/>
                            <circle class="point" cx="67" cy="100" r="10" data-occupied="false"/>
                            <circle class="entry-inner" cx="67" cy="100" r="4"/>
                            <line class="pokeball-line" x1="55" y1="100" x2="79" y2="100"/>
                        </g>
                        <g id="entry-top-right" class="entry-point" data-type="entry" data-position="top-right" data-x="599" data-y="100" data-team="neutral" data-spawn-point="true">
                            <circle class="entry-ring" cx="599" cy="100" r="20"/>
                            <circle class="entry-ring" cx="599" cy="100" r="15"/>
                            <circle class="point" cx="599" cy="100" r="10" data-occupied="false"/>
                            <circle class="entry-inner" cx="599" cy="100" r="4"/>
                            <line class="pokeball-line" x1="587" y1="100" x2="611" y2="100"/>
                        </g>
                        <g id="entry-bottom-left" class="entry-point" data-type="entry" data-position="bottom-left" data-x="67" data-y="600" data-team="neutral" data-spawn-point="true">
                            <circle class="entry-ring" cx="67" cy="600" r="20"/>
                            <circle class="entry-ring" cx="67" cy="600" r="15"/>
                            <circle class="point" cx="67" cy="600" r="10" data-occupied="false"/>
                            <circle class="entry-inner" cx="67" cy="600" r="4"/>
                            <line class="pokeball-line" x1="55" y1="600" x2="79" y2="600"/>
                        </g>
                        <g id="entry-bottom-right" class="entry-point" data-type="entry" data-position="bottom-right" data-x="599" data-y="600" data-team="neutral" data-spawn-point="true">
                            <circle class="entry-ring" cx="599" cy="600" r="20"/>
                            <circle class="entry-ring" cx="599" cy="600" r="15"/>
                            <circle class="point" cx="599" cy="600" r="10" data-occupied="false"/>
                            <circle class="entry-inner" cx="599" cy="600" r="4"/>
                            <line class="pokeball-line" x1="587" y1="600" x2="611" y2="600"/>
                        </g>
                    </svg>
                </div>

                <!-- User Zone (Below Game Field) -->
                <div id="player-zone" class="player-zone user-player" data-team="player" data-zone="player-area">
                    <div id="bench-section" class="bench-section" data-type="bench" data-capacity="6">
                        <div class="bench-row secondary">
                            <div id="bench-slot-1" class="bench-slot offset-1" data-slot="bench-1" data-occupied="false" data-robot-id="" data-position="secondary-left"></div>
                            <div id="bench-slot-2" class="bench-slot offset-2" data-slot="bench-2" data-occupied="false" data-robot-id="" data-position="secondary-right"></div>
                        </div>
                        <div class="bench-row primary">
                            <div id="bench-slot-3" class="bench-slot" data-slot="bench-3" data-occupied="false" data-robot-id="" data-position="primary-1"></div>
                            <div id="bench-slot-4" class="bench-slot" data-slot="bench-4" data-occupied="false" data-robot-id="" data-position="primary-2"></div>
                            <div id="bench-slot-5" class="bench-slot" data-slot="bench-5" data-occupied="false" data-robot-id="" data-position="primary-3"></div>
                            <div id="bench-slot-6" class="bench-slot" data-slot="bench-6" data-occupied="false" data-robot-id="" data-position="primary-4"></div>
                        </div>
                    </div>
                    <div id="player-repair-bay" class="repair-bay" data-type="repair-bay" data-capacity="2" data-team="player">
                        <div id="player-repair-slot-1" class="repair-slot" data-slot="player-repair-1" data-occupied="false" data-robot-id="" data-position="slot-1">
                            <span class="repair-icon">🔧</span>
                        </div>
                        <div id="player-repair-slot-2" class="repair-slot" data-slot="player-repair-2" data-occupied="false" data-robot-id="" data-position="slot-2">
                            <span class="repair-icon">🔧</span>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <!-- End Turn Button -->
    <button id="end-turn-btn" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 15px 30px;
        font-size: 18px;
        font-weight: bold;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: 3px solid #fff;
        border-radius: 12px;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        z-index: 1000;
        transition: all 0.3s ease;
        display: none;
    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        🔄 End Turn
    </button>

    <style>
        /* Battle Scenario Debugger Styles */
        .debug-toggle-icon {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5000;
            font-size: 24px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .debug-toggle-icon:hover {
            background: rgba(255, 215, 0, 0.3);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .debug-toggle-icon.hidden {
            display: none;
        }
        
        .battle-debugger-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 400px;
            max-height: 80vh;
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            z-index: 5000;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            display: none;
        }
        
        .battle-debugger-panel.active {
            display: block;
            animation: slideInRight 0.3s ease;
        }
        
        .battle-debugger-panel.minimized {
            max-height: 80px;
            overflow: hidden;
        }
        
        .battle-debugger-panel.minimized .debugger-columns,
        .battle-debugger-panel.minimized .debugger-status,
        .battle-debugger-panel.minimized .debugger-toggle-container {
            display: none;
        }
        
        .battle-debugger-panel.minimized .debugger-minimize-btn {
            transform: rotate(180deg);
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .debugger-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .debugger-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .debugger-title {
            font-size: 18px;
            font-weight: 700;
            color: #FFD700;
            letter-spacing: 1px;
            flex: 1;
            text-align: center;
        }
        
        .debugger-minimize-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 24px;
            font-weight: 700;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        
        .debugger-minimize-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
            color: #FFD700;
            transform: scale(1.1);
        }
        
        .debugger-toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .debugger-toggle-label {
            color: #FFD700;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .toggle-switch {
            position: relative;
            width: 80px;
            height: 40px;
            background: rgba(220, 53, 69, 0.3);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #dc3545;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
        }
        
        .toggle-switch.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }
        
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 30px;
            height: 30px;
            background: #dc3545;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 2;
        }
        
        .toggle-switch.active .toggle-slider {
            transform: translateX(40px);
            background: #4CAF50;
        }
        
        .toggle-text-off,
        .toggle-text-on {
            font-size: 11px;
            font-weight: 700;
            color: #fff;
            z-index: 1;
            pointer-events: none;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .toggle-text-off {
            margin-left: 2px;
        }
        
        .toggle-text-on {
            margin-right: 2px;
            opacity: 0.3;
        }
        
        .toggle-switch.active .toggle-text-off {
            opacity: 0.3;
        }
        
        .toggle-switch.active .toggle-text-on {
            opacity: 1;
        }
        
        .debugger-columns {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .debugger-column {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .column-header {
            font-size: 14px;
            font-weight: 700;
            color: #FFD700;
            margin-bottom: 12px;
            text-align: center;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .move-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
        }
        
        .move-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }
        
        .move-option.selected {
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.5);
        }
        
        .move-radio {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            flex-shrink: 0;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .move-option.selected .move-radio {
            border-color: #FFD700;
            background: #FFD700;
        }
        
        .move-option.selected .move-radio::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #1a1a2e;
            border-radius: 50%;
        }
        
        .move-text {
            font-size: 13px;
            font-weight: 600;
            flex: 1;
        }
        
        .move-damage {
            font-size: 11px;
            opacity: 0.8;
            margin-left: auto;
        }
        
        /* Psycho Cut Bonus Spin Section */
        .debugger-bonus-spin-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 0, 255, 0.1);
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
        }
        
        .bonus-spin-header {
            text-align: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 0, 255, 0.3);
        }
        
        .debugger-status {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debugger-status.ready {
            background: rgba(76, 175, 80, 0.2);
            border-color: rgba(76, 175, 80, 0.5);
            color: #4CAF50;
        }
        
        .debugger-status.waiting {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #FFC107;
        }
        
        /* Status Effect Manager Styles */
        .debugger-status-manager {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(138, 43, 226, 0.5);
        }
        
        .status-manager-header {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(138, 43, 226, 0.3);
        }
        
        .status-manager-title {
            color: #BA55D3;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .status-manager-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .status-manager-column {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-column-header {
            font-size: 12px;
            font-weight: 700;
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
            padding: 6px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .status-effects-list {
            min-height: 80px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .no-status-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
            font-style: italic;
            padding: 20px 10px;
        }
        
        .status-effect-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 6px;
            font-size: 12px;
            color: #fff;
            transition: all 0.2s ease;
        }
        
        .status-effect-item:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: rgba(138, 43, 226, 0.6);
            transform: translateX(2px);
        }
        
        .status-effect-name {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }
        
        .status-effect-remove {
            background: rgba(220, 53, 69, 0.3);
            border: 1px solid #dc3545;
            color: #ff6b6b;
            font-size: 16px;
            font-weight: 700;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .status-effect-remove:hover {
            background: rgba(220, 53, 69, 0.5);
            border-color: #ff4444;
            color: #fff;
            transform: scale(1.1);
        }
        
        .status-add-section {
            margin-top: 10px;
        }
        
        .status-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
        }
        
        .status-select:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(138, 43, 226, 0.8);
        }
        
        .status-select:focus {
            border-color: #BA55D3;
            box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2);
        }
        
        .status-select option {
            background: #1a1a2e;
            color: #fff;
            padding: 8px;
        }
    </style>

    <!-- Battle Scenario Debugger -->
    <div class="debug-toggle-icon" id="debugToggleIcon" onclick="GameBoard.toggleDebugger()">
        ⚙️
    </div>
    
    <div class="battle-debugger-panel" id="battleDebuggerPanel">
        <div class="debugger-header">
            <div class="debugger-title-row">
                <div class="debugger-title">⚙️ BATTLE SCENARIO DEBUGGER</div>
                <button class="debugger-minimize-btn" onclick="GameBoard.minimizeDebugger()" title="Minimize">−</button>
            </div>
            <div class="debugger-toggle-container">
                <span class="debugger-toggle-label">Force Battle Outcome:</span>
                <div class="toggle-switch" id="debuggerToggle" onclick="GameBoard.toggleDebuggerMode()">
                    <div class="toggle-slider"></div>
                    <span class="toggle-text-off">OFF</span>
                    <span class="toggle-text-on">ON</span>
                </div>
            </div>
            <div class="debugger-toggle-container">
                <span class="debugger-toggle-label">Free Movement Mode:</span>
                <div class="toggle-switch" id="freeMovementToggle" onclick="GameBoard.toggleFreeMovementMode()">
                    <div class="toggle-slider"></div>
                    <span class="toggle-text-off">OFF</span>
                    <span class="toggle-text-on">ON</span>
                </div>
            </div>
        </div>
        
        <div class="debugger-columns">
            <div class="debugger-column">
                <div class="column-header" id="playerColumnHeader">Player Robot</div>
                <div id="playerMovesList"></div>
            </div>
            
            <div class="debugger-column">
                <div class="column-header" id="opponentColumnHeader">Opponent Robot</div>
                <div id="opponentMovesList"></div>
            </div>
        </div>
        
        <!-- Psycho Cut Bonus Spin Controls -->
        <div class="debugger-bonus-spin-section" id="debuggerBonusSpinSection" style="display: none;">
            <div class="bonus-spin-header">
                <span style="font-weight: bold; color: #ff00ff;">🌀 PSYCHO CUT BONUS SPIN</span>
                <span style="font-size: 12px; opacity: 0.8; margin-left: 10px;">Force bonus roll outcome</span>
            </div>
            
            <div class="debugger-columns" style="margin-top: 10px;">
                <div class="debugger-column">
                    <div class="column-header">Player Bonus Spin</div>
                    <div id="playerBonusMovesList"></div>
                </div>
                
                <div class="debugger-column">
                    <div class="column-header">Opponent Bonus Spin</div>
                    <div id="opponentBonusMovesList"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 10px; font-size: 12px; opacity: 0.7;">
                💡 Only applies if initial spin is Psycho Cut
            </div>
        </div>
        
        <!-- Status Effect Manager -->
        <div class="debugger-status-manager" id="debuggerStatusManager" style="display: none;">
            <div class="status-manager-header">
                <span class="status-manager-title">🧪 STATUS EFFECT MANAGER</span>
            </div>
            
            <div class="status-manager-columns">
                <div class="status-manager-column">
                    <div class="status-column-header" id="playerStatusHeader">Player Robot</div>
                    <div class="status-effects-list" id="playerStatusEffects">
                        <div class="no-status-message">No active status effects</div>
                    </div>
                    <div class="status-add-section">
                        <select class="status-select" id="playerStatusSelect">
                            <option value="">+ Add Status Effect</option>
                            <option value="poison">🧪 Poison (-20 dmg)</option>
                            <option value="noxious">☠️ Noxious (-40 dmg)</option>
                            <option value="burn">🔥 Burn (-10 dmg)</option>
                            <option value="sleep">💤 Sleep</option>
                            <option value="frozen">🧊 Frozen</option>
                            <option value="paralysis">⚡ Paralysis</option>
                            <option value="confusion">😵 Confusion</option>
                        </select>
                    </div>
                </div>
                
                <div class="status-manager-column">
                    <div class="status-column-header" id="opponentStatusHeader">Opponent Robot</div>
                    <div class="status-effects-list" id="opponentStatusEffects">
                        <div class="no-status-message">No active status effects</div>
                    </div>
                    <div class="status-add-section">
                        <select class="status-select" id="opponentStatusSelect">
                            <option value="">+ Add Status Effect</option>
                            <option value="poison">🧪 Poison (-20 dmg)</option>
                            <option value="noxious">☠️ Noxious (-40 dmg)</option>
                            <option value="burn">🔥 Burn (-10 dmg)</option>
                            <option value="sleep">💤 Sleep</option>
                            <option value="frozen">🧊 Frozen</option>
                            <option value="paralysis">⚡ Paralysis</option>
                            <option value="confusion">😵 Confusion</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="debugger-status" id="debuggerStatus">
            Awaiting battle initiation...
        </div>
    </div>

    <!-- Battle Overlay Modal -->
    <div id="battleOverlay">
        <div class="battle-modal">
            <div class="battle-modal-header">
                <!-- Title removed to save space -->
            </div>
            
            <div class="battle-combatants">
                <div class="combatant player">
                    <img id="battlePlayerImage" src="" alt="Player Robot" class="combatant-image">
                    <div class="combatant-name" id="battlePlayerName">Player Robot</div>
                    <div class="combatant-role" id="battlePlayerRole">Role</div>
                </div>
                
                <div class="battle-vs">VS</div>
                
                <div class="combatant opponent">
                    <img id="battleOpponentImage" src="" alt="Opponent Robot" class="combatant-image">
                    <div class="combatant-name" id="battleOpponentName">Opponent Robot</div>
                    <div class="combatant-role" id="battleOpponentRole">Role</div>
                </div>
            </div>
            
            <!-- Spinning Wheels Section -->
            <div class="battle-wheels" id="battleWheels" style="display: none;">
                <div class="wheel-container" id="attackerWheelContainer">
                    <div class="wheel-label attacker" id="attackerWheelLabel">OPPONENT</div>
                    <div class="spinning-wheel" id="attackerWheel">
                        <div class="wheel-segments" id="attackerWheelSegments"></div>
                        <div class="wheel-pointer">▼</div>
                    </div>
                    <div class="wheel-result" id="attackerWheelResult">
                        <div class="move-name">Spinning...</div>
                        <div class="move-power"></div>
                    </div>
                    <!-- Move list always visible -->
                    <div class="battle-wheel-moves-list" id="attackerMovesList" style="display: block;">
                        <!-- Detailed move list populated dynamically -->
                    </div>
                </div>
                
                <!-- VS divider removed to save space -->
                
                <div class="wheel-container" id="defenderWheelContainer">
                    <div class="wheel-label defender" id="defenderWheelLabel">PLAYER</div>
                    <div class="spinning-wheel" id="defenderWheel">
                        <div class="wheel-segments" id="defenderWheelSegments"></div>
                        <div class="wheel-pointer">▼</div>
                    </div>
                    <div class="wheel-result" id="defenderWheelResult">
                        <div class="move-name">Spinning...</div>
                        <div class="move-power"></div>
                    </div>
                    <!-- Move list always visible -->
                    <div class="battle-wheel-moves-list" id="defenderMovesList" style="display: block;">
                        <!-- Detailed move list populated dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="battle-action-buttons">
                <button class="battle-action-btn attack" onclick="GameBoard.executeBattle()">
                    ⚔️ Attack!
                </button>
                <button class="battle-action-btn cancel" onclick="GameBoard.cancelBattle()">
                    ↩️ Cancel
                </button>
            </div>
            
            <div class="battle-result" id="battleResult">
                <div class="battle-result-title" id="battleResultTitle">Victory!</div>
                <div class="battle-result-details" id="battleResultDetails">
                    Your robot won the battle!
                </div>
                <button class="battle-continue-btn" onclick="GameBoard.closeBattleResult()">
                    Continue
                </button>
            </div>
        </div>
    </div>

    <!-- Combat Dial Info Overlay -->
    <div id="combatDialOverlay">
        <div class="combat-dial-modal">
            <button class="combat-dial-close-btn" onclick="BattleSystem.closeCombatDialInfo()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <div class="combat-dial-header">
                <img id="combatDialRobotImage" src="" alt="Robot" class="combat-dial-robot-image">
                <div class="combat-dial-robot-info">
                    <div class="combat-dial-robot-name" id="combatDialRobotName">Robot Name</div>
                    <div class="combat-dial-robot-role" id="combatDialRobotRole">Role</div>
                    <div class="combat-dial-robot-stats" id="combatDialRobotStats">MP: 2</div>
                </div>
            </div>
            
            <div class="combat-dial-ability" id="combatDialAbility">
                <div class="combat-dial-ability-name">Ability Name</div>
                <div class="combat-dial-ability-desc">Ability description</div>
            </div>
            
            <div class="combat-dial-content">
                <div class="combat-dial-wheel-visual">
                    <div class="combat-dial-title">⚔️ Combat Wheel</div>
                    <div class="combat-dial-wheel-container" id="combatDialWheelContainer">
                        <!-- Visual wheel will be populated here -->
                    </div>
                </div>
                
                <div class="combat-dial-moves-section">
                    <div class="combat-dial-title">📋 Move Details</div>
                    <div class="combat-dial-wheel-display" id="combatDialWheelDisplay">
                        <!-- Wheel segments will be populated here -->
                    </div>
                </div>
            </div>
            
            <div class="combat-dial-footer">
                Hold another robot to view their Combat Dial
            </div>
        </div>
    </div>

    <!-- Turn Indicator -->
    <div class="turn-indicator" id="turnIndicator">
        🎮 Your Turn
    </div>

    <!-- Shared Mascot (appears on all screens) -->
    <div class="mascot-container-global">
        <div class="speech-bubble" id="speechBubble">Hello!</div>
        <div class="thought-bubble" id="thoughtBubble">Hmm...</div>
        <img src="Imag/mascot.png" alt="Upkeep Mascot" class="mascot-image" id="mascotImage" onclick="app.mascotGreet()">
    </div>

    <div class="modal" id="addCategoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">New Category</div>
                <button class="close-btn" onclick="app.closeModal('addCategoryModal')"><img src="Imag/Close.png" alt="Close"></button>
            </div>
            <form onsubmit="app.addCategory(event)">
                <div class="form-group">
                    <label class="form-label">Choose a Category</label>
                    <select class="form-select" id="categorySelect" onchange="app.handleCategorySelect()" required>
                        <option value="">-- Select from common categories --</option>
                        <option value="Kitchen">Kitchen</option>
                        <option value="Bathroom">Bathroom</option>
                        <option value="Bedroom">Bedroom</option>
                        <option value="Guest Bedroom">Guest Bedroom</option>
                        <option value="Living Room">Living Room</option>
                        <option value="Hallway">Hallway</option>
                        <option value="Laundry Room">Laundry Room</option>
                        <option value="Backyard">Backyard</option>
                        <option value="Back Porch">Back Porch</option>
                        <option value="Vehicle">Vehicle</option>
                        <option value="Front Yard">Front Yard</option>
                        <option value="Front Porch">Front Porch</option>
                        <option disabled style="color: #4040ff; font-weight: bold;">━━━━ GROUP CATEGORIES ━━━━</option>
                        <option value="GROUP:Sweep/Mop" style="color: #4040ff;">🔷 Sweep/Mop</option>
                        <option value="GROUP:Shampoo" style="color: #4040ff;">🔷 Shampoo</option>
                        <option value="GROUP:Deep Cleaning" style="color: #4040ff;">🔷 Deep Cleaning</option>
                        <option value="GROUP:Vacuum" style="color: #4040ff;">🔷 Vacuum</option>
                        <option value="custom">✏️ Custom Category</option>
                    </select>
                </div>
                <div class="form-group" id="customCategoryGroup" style="display: none;">
                    <label class="form-label">Custom Category Name</label>
                    <input type="text" class="form-input" id="categoryName" placeholder="e.g., Laundry Room">
                </div>
                <button type="submit" class="btn-primary">Create Category</button>
            </form>
        </div>
    </div>

    <div class="modal" id="editCategoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Edit Category</div>
                <button class="close-btn" onclick="app.closeModal('editCategoryModal')"><img src="Imag/Close.png" alt="Close"></button>
            </div>
            <form onsubmit="app.updateCategory(event)">
                <div class="form-group">
                    <label class="form-label">Category Name</label>
                    <input type="text" class="form-input" id="editCategoryName" required>
                </div>
                <button type="submit" class="btn-primary">Update Category</button>
                <button type="button" class="btn-danger" onclick="app.deleteCategory()">Delete Category</button>
            </form>
        </div>
    </div>

    <div class="modal" id="addTaskModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">New Task</div>
                <button class="close-btn" onclick="app.closeModal('addTaskModal')"><img src="Imag/Close.png" alt="Close"></button>
            </div>
            <form onsubmit="app.addTask(event)">
                <div class="form-group" id="linkedCategoryGroup" style="display: none;">
                    <label class="form-label">Link to Standard Category</label>
                    <select class="form-select" id="linkedCategorySelect" required>
                        <option value="">-- Select Standard Category --</option>
                    </select>
                    <small style="color: #666; display: block; margin-top: 4px;">Task will appear in both this group and the selected category</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" class="form-input" id="taskName" placeholder="e.g., Wipe counters" required>
                    <small id="taskNameNote" style="color: #666; display: none; margin-top: 4px;">For group tasks, name will be auto-generated as '[Group] - [Category]'</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Decay Time</label>
                    <div class="time-unit-group">
                        <input type="number" class="form-input" id="taskDecayValue" min="1" value="7" required>
                        <select class="form-select" id="taskDecayUnit">
                            <option value="hours">Hours</option>
                            <option value="days" selected>Days</option>
                            <option value="weeks">Weeks</option>
                            <option value="months">Months</option>
                        </select>
                    </div>
                    <small style="color: #666; display: block; margin-top: 4px;">Decay affects the linked category's score only</small>
                </div>
                <button type="submit" class="btn-primary">Create Task</button>
            </form>
        </div>
    </div>

    <div class="modal" id="editTaskModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Edit Task</div>
                <button class="close-btn" onclick="app.closeModal('editTaskModal')"><img src="Imag/Close.png" alt="Close"></button>
            </div>
            <form onsubmit="app.updateTask(event)">
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" class="form-input" id="editTaskName" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Decay Time</label>
                    <div class="time-unit-group">
                        <input type="number" class="form-input" id="editTaskDecayValue" min="1" required>
                        <select class="form-select" id="editTaskDecayUnit">
                            <option value="hours">Hours</option>
                            <option value="days">Days</option>
                            <option value="weeks">Weeks</option>
                            <option value="months">Months</option>
                        </select>
                    </div>
                </div>
                <button type="submit" class="btn-primary">Update Task</button>
                <button type="button" class="btn-danger" onclick="app.deleteTask()">Delete Task</button>
            </form>
        </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Backup & Restore</div>
                <button class="close-btn" onclick="app.closeModal('settingsModal')"><img src="Imag/Close.png" alt="Close"></button>
            </div>
            
            <!-- Save & Load Card -->
            <div class="settings-card">
                <div style="display: flex; gap: 4px; justify-content: center; align-items: center;">
                    <button type="button" class="save-load-img-btn" onclick="app.showSaveFileSelect()">
                        <img src="Imag/Save.png" alt="Save">
                    </button>
                    <button type="button" class="save-load-img-btn" onclick="app.showLoadFileSelect()">
                        <img src="Imag/load.png" alt="Load">
                    </button>
                </div>
                <div class="settings-card-subtitle" id="lastSavedText" style="text-align: center; margin-top: 12px;">Last saved: Never</div>
            </div>
            
            <!-- Export/Import/Manage Card -->
            <div class="settings-card">
                <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                    <div style="display: flex; gap: 4px; justify-content: center; align-items: center;">
                        <button type="button" class="backup-btn-large" onclick="app.exportToFile()">
                            <img src="Imag/Export.png" alt="Export">
                        </button>
                        <button type="button" class="backup-btn-large" onclick="app.importFromFile()">
                            <img src="Imag/Import.png" alt="Import">
                        </button>
                    </div>
                    <div style="display: flex; gap: 4px; justify-content: center; align-items: center;">
                        <button type="button" class="backup-btn-large" onclick="app.createNewSaveFile()">
                            <img src="Imag/Achivments/Images/Finished Images/New-File-button.png" alt="New Save">
                        </button>
                        <button type="button" class="backup-btn-large" onclick="app.showManageSaves()">
                            <img src="Imag/View-Saves.png" alt="View All Saves">
                        </button>
                    </div>
                </div>
                <p style="font-size: 11px; color: var(--text-secondary); text-align: center; margin-top: 12px;">Export creates a .upkeep file you can save anywhere</p>
            </div>
            
            <!-- Logbook Card -->
            <div class="settings-card">
                <button type="button" class="backup-btn-large" onclick="app.openLogbook()" style="width: 100%;">
                    <img src="Imag/LogBook.png" alt="Logbook">
                </button>
                <p style="font-size: 13px; color: var(--text-secondary); text-align: center; margin-top: 12px;">View your activity history</p>
            </div>
            
            <!-- Voice Settings Card -->
            <div class="settings-card">
                <div class="settings-card-title">Mascot Voice</div>
                <div class="voice-toggle" onclick="app.toggleTTSSwitch()">
                    <span style="font-size: 15px; font-weight: 500;">Enable Voice</span>
                    <div class="toggle-switch" id="ttsToggleSwitch">
                        <div class="toggle-switch-handle"></div>
                    </div>
                </div>
                
                <div id="voiceSettings" style="display: none;">
                    <div class="form-group" style="margin-bottom: 16px;">
                        <label class="form-label" style="font-size: 14px; margin-bottom: 8px;">Voice Style</label>
                        <select class="form-select" id="voiceStyle" onchange="app.updateVoiceSettings()">
                            <option value="robotic">🤖 Robotic</option>
                            <option value="friendly">😊 Friendly</option>
                            <option value="calm">😌 Calm</option>
                            <option value="excited">🎉 Excited</option>
                            <option value="custom">⚙️ Custom</option>
                        </select>
                    </div>
                    
                    <div id="customVoiceSettings" style="display: none;">
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label" style="font-size: 13px; margin-bottom: 6px;">
                                Pitch: <span id="pitchValue">1.5</span>
                            </label>
                            <input type="range" id="voicePitch" min="0.5" max="2.0" step="0.1" value="1.5" 
                                   onchange="app.updateVoiceSettings()" oninput="app.updatePitchDisplay()"
                                   style="width: 100%; cursor: pointer;">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                                <span>Low</span>
                                <span>High</span>
                            </div>
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label" style="font-size: 13px; margin-bottom: 6px;">
                                Speed: <span id="rateValue">1.2</span>
                            </label>
                            <input type="range" id="voiceRate" min="0.5" max="2.0" step="0.1" value="1.2" 
                                   onchange="app.updateVoiceSettings()" oninput="app.updateRateDisplay()"
                                   style="width: 100%; cursor: pointer;">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                                <span>Slow</span>
                                <span>Fast</span>
                            </div>
                        </div>
                    </div>
                    
                    <button type="button" class="btn-primary" style="margin-top: 12px; padding: 12px;" onclick="app.testVoice()">🔊 Test Voice</button>
                </div>
                
                <p style="font-size: 12px; color: var(--text-secondary); margin-top: 12px; text-align: center;">Let the mascot speak messages out loud</p>
            </div>
            
            <!-- Scrappy Voice Settings Card -->
            <div class="settings-card">
                <div class="settings-card-title">🔧 Scrappy's Voice</div>
                <p style="font-size: 13px; color: var(--text-secondary); text-align: center; margin-bottom: 16px;">Store manager voice settings</p>
                
                <div class="form-group" style="margin-bottom: 12px;">
                    <label class="form-label" style="font-size: 13px; margin-bottom: 6px;">
                        Pitch: <span id="scrappyPitchValue">0.8</span>
                    </label>
                    <input type="range" id="scrappyPitch" min="0.5" max="2.0" step="0.1" value="0.8" 
                           onchange="app.updateScrappyVoiceSettings()" oninput="app.updateScrappyPitchDisplay()"
                           style="width: 100%; cursor: pointer;">
                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                        <span>Low (Gruff)</span>
                        <span>High (Squeaky)</span>
                    </div>
                </div>
                
                <div class="form-group" style="margin-bottom: 12px;">
                    <label class="form-label" style="font-size: 13px; margin-bottom: 6px;">
                        Speed: <span id="scrappyRateValue">0.9</span>
                    </label>
                    <input type="range" id="scrappyRate" min="0.5" max="2.0" step="0.1" value="0.9" 
                           onchange="app.updateScrappyVoiceSettings()" oninput="app.updateScrappyRateDisplay()"
                           style="width: 100%; cursor: pointer;">
                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                        <span>Slow (Mechanical)</span>
                        <span>Fast (Energetic)</span>
                    </div>
                </div>
                
                <button type="button" class="btn-primary" style="margin-top: 12px; padding: 12px;" onclick="app.testScrappyVoice()">🔊 Test Scrappy's Voice</button>
                
                <p style="font-size: 12px; color: var(--text-secondary); margin-top: 12px; text-align: center;">Customize the store manager's voice</p>
            </div>
            
            <!-- Battle System Card (Temporary) -->
            <div class="settings-card">
                <div class="settings-card-title">⚔️ Battle System</div>
                <button type="button" class="btn-primary" style="width: 100%; padding: 16px; font-size: 16px; font-weight: 600; margin-bottom: 12px;" onclick="app.openBattleSystem()">
                    🥊 Enter Battle Mode
                </button>
                <button type="button" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600;" onclick="app.openCombatTester()">
                    🎯 Test Combat System
                </button>
                <p style="font-size: 12px; color: var(--text-secondary); margin-top: 12px; text-align: center;">Battle features and Data Disk combat testing</p>
            </div>
        </div>
    </div>
    
    <!-- File Select Modal for Save -->
    <div class="file-select-modal" id="saveFileSelectModal">
        <div class="file-select-content">
            <div class="file-select-title">Save Progress</div>
            <input type="text" class="new-file-input" id="newSaveFileName" placeholder="Enter new save name...">
            <button class="btn-save" style="margin-bottom: 20px;" onclick="app.createNewSave()">Create New Save</button>
            <div style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-secondary);">Or overwrite existing:</div>
            <div id="saveFileList"></div>
            <button class="btn-load" style="margin-top: 12px;" onclick="app.closeSaveFileSelect()">Cancel</button>
        </div>
    </div>
    
    <!-- File Select Modal for Load -->
    <div class="file-select-modal" id="loadFileSelectModal">
        <div class="file-select-content">
            <div class="file-select-title">Load Progress</div>
            <div id="loadFileList"></div>
            <button class="btn-danger" style="margin-top: 12px;" onclick="app.closeLoadFileSelect()">Cancel</button>
        </div>
    </div>
    
    <!-- Manage Saves Modal -->
    <div class="file-select-modal" id="manageSavesModal">
        <div class="file-select-content">
            <div class="file-select-title">Manage Save Slots</div>
            <div id="manageSavesList"></div>
            <button class="btn-load" style="margin-top: 12px;" onclick="app.closeManageSaves()">Close</button>
        </div>
    </div>
    
    <!-- Hidden file input for import -->
    <input type="file" id="importFileInput" accept=".upkeep,.json" style="display: none;" onchange="app.handleImportFile(event)">
    
    <!-- Logbook Modal -->
    <div class="logbook-modal" id="logbookModal">
        <div class="logbook-content">
            <div class="logbook-header">
                <div class="logbook-icon">
                    <img src="Imag/LogBook.png" alt="Logbook">
                </div>
                <div class="logbook-title">
                    <h2>Activity Log</h2>
                </div>
                <button class="logbook-close" onclick="app.closeLogbook()">&times;</button>
            </div>
            <div class="logbook-body" id="logbookBody">
                <!-- Log entries will be inserted here -->
            </div>
            <div class="logbook-footer">
                <button class="logbook-btn logbook-btn-clear" onclick="app.clearLogbook()">Clear Log</button>
                <button class="logbook-btn logbook-btn-close" onclick="app.closeLogbook()">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Snooze Modal -->
    <div class="snooze-modal" id="snoozeModal">
        <div class="snooze-modal-content">
            <div class="snooze-icon">
                <svg fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                </svg>
            </div>
            <div class="snooze-modal-title">Snooze Task</div>
            <div class="snooze-label">Snooze for</div>
            <div class="snooze-input-group">
                <input type="number" class="snooze-input" id="snoozeAmount" min="1" value="24" placeholder="Enter amount">
                <select class="snooze-unit-select" id="snoozeUnit">
                    <option value="hours">Hours</option>
                    <option value="days">Days</option>
                    <option value="weeks">Weeks</option>
                </select>
            </div>
            <div class="snooze-buttons">
                <button class="snooze-cancel-btn" onclick="app.closeSnoozeModal()">Cancel</button>
                <button class="snooze-confirm-btn" onclick="app.confirmSnooze()">Snooze</button>
            </div>
        </div>
    </div>
    
    <!-- Robot Select Bubble -->
    <div class="robot-select-bubble" id="robotSelectBubble" onclick="app.openRobotSelect()">
        <img src="Imag/Achivments/Images/Finished Images/Robot-Select-Bubble.png" alt="Robot Select">
    </div>
    
    <!-- Robot Store Bubble -->
    <div class="robot-store-bubble" id="robotStoreBubble" onclick="app.openRobotStore()">
        <img src="Imag/Achivments/Images/Finished Images/Store-Bubble.png" alt="Robot Store">
    </div>
    
    
    <!-- Robot Select Modal -->
    <div class="robot-select-modal" id="robotSelectModal">
        <div class="robot-select-content">
            <div class="robot-select-header">
                <img src="Imag/Achivments/Images/Finished Images/Robot-Select.png" alt="Robot Select" class="robot-select-logo">
                <button class="robot-select-close" onclick="app.closeRobotSelect()">&times;</button>
            </div>
            <div class="robot-select-body">
                <div class="robot-select-grid" id="robotSelectGrid">
                    <!-- Robot cards will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Robot Store Modal -->
    <div class="robot-store-modal" id="robotStoreModal">
        <div class="robot-store-content">
            <div class="robot-store-header">
                <h2><img src="Imag/Achivments/Images/Finished Images/Robot-Factory-Logo.png" alt="Robot Factory" class="robot-factory-logo"></h2>
                <button class="robot-store-close" onclick="app.closeRobotStore()">&times;</button>
            </div>
            <div class="robot-store-body">
                <div class="robot-store-grid" id="robotStoreGrid">
                    <!-- Robot store cards will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Store Currency Display (Global) -->
    <div class="store-currency-display" id="storeCurrencyDisplay" style="display: none;">
        <img src="Imag/Achivments/Images/Finished Images/Bolt.png" alt="Bolt" class="store-currency-bolt">
        <span class="store-currency-amount" id="storeCurrencyAmount">0</span>
        <span class="store-currency-label">Bolt</span>
    </div>
    
    <!-- Scrappy Character (Global) -->
    <div class="scrappy-container" id="scrappyContainer" style="display: none;">
        <img src="Imag/Achivments/Images/Finished Images/Store manager/Scrappy.png" 
             alt="Scrappy" 
             id="scrappyImage" 
             class="scrappy-image"
             onclick="app.scrappyInteraction()">
        <div class="scrappy-speech-bubble" id="scrappySpeechBubble"></div>
    </div>
    
    <!-- Purchase Confirmation Modal -->
    <div class="purchase-confirm-modal" id="purchaseConfirmModal">
        <div class="purchase-confirm-content">
            <div class="purchase-confirm-icon">🤖</div>
            <div class="purchase-confirm-title">Purchase Robot?</div>
            <div class="purchase-confirm-message">Are you sure you want to purchase this mystery robot?</div>
            <div class="purchase-confirm-cost">
                <img src="Imag/Achivments/Images/Finished Images/Bolt.png" alt="Bolt" class="purchase-confirm-cost-bolt">
                <img src="Imag/Achivments/Images/Finished Images/X.png" alt="x" class="purchase-confirm-cost-x">
                <span id="purchaseConfirmCost">100</span>
            </div>
            <div class="purchase-confirm-buttons">
                <button class="purchase-confirm-btn purchase-confirm-btn-no" onclick="app.cancelPurchase()">No</button>
                <button class="purchase-confirm-btn purchase-confirm-btn-yes" onclick="app.confirmPurchase()">Yes</button>
            </div>
        </div>
    </div>
    
    <!-- Robot Reveal Modal -->
    <div class="robot-reveal-modal" id="robotRevealModal">
        <div class="robot-reveal-content">
            <div class="robot-reveal-title">New Robot Unlocked!</div>
            <img id="robotRevealImage" src="" alt="New Robot" class="robot-reveal-image">
            <div class="robot-reveal-name" id="robotRevealName">Robot Name</div>
            <button class="robot-reveal-btn" onclick="app.closeReveal()">Awesome!</button>
        </div>
    </div>
    
    <!-- Missions Modal -->
    <div class="missions-modal" id="missionsModal">
        <div class="missions-content">
            <div class="missions-header">
                <h2><img src="Imag/Achivments/Images/Finished Images/Missions-Logo.png" alt="Missions" class="missions-logo"></h2>
                <button class="missions-close" onclick="app.closeMissions()">&times;</button>
            </div>
            <div class="missions-body" id="missionsBody">
                <!-- Mission content will be populated by JavaScript -->
            </div>
            <div class="missions-tabs">
                <button class="mission-tab active" id="dailyTab" onclick="app.switchMissionTab('daily')">Daily</button>
                <button class="mission-tab" id="achievementsTab" onclick="app.switchMissionTab('achievements')">Achievements</button>
                <button class="mission-tab" id="mysteryTab" onclick="app.switchMissionTab('mystery')">Daily Mystery Pick</button>
            </div>
        </div>
    </div>
    
    <!-- Mystery Pick Result Modal -->
    <div class="mystery-result-modal" id="mysteryResultModal">
        <div class="mystery-result-content">
            <div class="mystery-result-title">🎉 Congratulations!</div>
            <div class="mystery-result-prize" id="mysteryResultPrize">
                <img id="mysteryResultImage" src="" alt="Prize" class="mystery-result-prize-image">
                <div id="mysteryResultText" class="mystery-result-prize-text">Prize Text</div>
            </div>
            <button class="mystery-result-btn" onclick="app.closeMysteryResult()">Awesome!</button>
        </div>
    </div>
    
    <!-- Combat Tester Modal -->
    <div class="combat-tester-modal" id="combatTesterModal">
        <div class="combat-tester-content">
            <div class="combat-tester-header">
                <h2>🎯 Data Disk Combat Tester</h2>
                <button class="combat-tester-close" onclick="app.closeCombatTester()">&times;</button>
            </div>
            <div class="combat-tester-body">
                <div class="combat-setup">
                    <div class="robot-selector">
                        <h3>Attacker Robot</h3>
                        <select id="attackerSelect" class="robot-select-dropdown">
                            <!-- Options populated by JavaScript -->
                        </select>
                        <div class="robot-info" id="attackerInfo">
                            <!-- Robot details populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="vs-divider">
                        <div class="vs-text">VS</div>
                        <button class="battle-btn" onclick="app.runCombatTest()">⚔️ BATTLE!</button>
                        <button class="import-btn" onclick="app.importBattleData()" style="margin-top: 10px; background: #059669; font-size: 12px; padding: 8px 12px;">📦 Import All Battle Data</button>
                    </div>
                    
                    <div class="robot-selector">
                        <h3>Defender Robot</h3>
                        <select id="defenderSelect" class="robot-select-dropdown">
                            <!-- Options populated by JavaScript -->
                        </select>
                        <div class="robot-info" id="defenderInfo">
                            <!-- Robot details populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <div class="combat-results" id="combatResults" style="display: none;">
                    <h3>🏆 Battle Results</h3>
                    <div class="battle-outcome" id="battleOutcome">
                        <!-- Battle results populated by JavaScript -->
                    </div>
                    <div class="spin-details" id="spinDetails">
                        <!-- Spin details populated by JavaScript -->
                    </div>
                    <button class="stats-btn" onclick="app.showVisualBattle()" style="margin-top: 15px;">🎬 Watch Visual Battle</button>
                </div>
                
                <div class="combat-stats" id="combatStats">
                    <h3>📊 Combat Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-label">Battles Simulated:</span>
                            <span class="stat-value" id="totalBattles">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Attacker Wins:</span>
                            <span class="stat-value" id="attackerWins">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Defender Wins:</span>
                            <span class="stat-value" id="defenderWins">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Draws:</span>
                            <span class="stat-value" id="draws">0</span>
                        </div>
                    </div>
                    <div class="stats-actions">
                        <button class="stats-btn" onclick="app.runMultipleBattles(100)">🔄 Run 100 Battles</button>
                        <button class="stats-btn" onclick="app.resetCombatStats()">🧽 Reset Stats</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- V-Mount Battle Spinner Modal -->
    <div class="disk-battle-modal" id="diskBattleModal">
        <div class="disk-battle-arena" style="overflow-y: auto; max-height: 95vh;">
            <!-- Back Button -->
            <button class="back-btn" onclick="app.closeDiskBattle()" style="
                position: absolute;
                top: 15px;
                left: 15px;
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 10px;
                color: white;
                padding: 10px 20px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                z-index: 1000;
            " onmouseover="this.style.background='rgba(255, 255, 255, 0.2)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'">
                ← Back
            </button>
            
            <div class="battle-title">⚔️ DATA DISK BATTLE ⚔️</div>
            
            <!-- Vertical Battle Layout: Opponent Top, User Bottom -->
            <div class="vertical-battle-container">
                <!-- Opponent Section (Top) -->
                <div class="opponent-battle-section">
                    <div class="robot-name opponent-name" id="defenderName">Opponent</div>
                    <div id="top-move-display" class="move-display"></div>
                    <div class="disk-wrapper opponent-disk" id="top-disk">
                        <div class="data-disk" id="defenderDisk">
                            <div class="disk-wheel" id="defenderWheel">
                                <!-- Opponent wheel segments populated by JavaScript -->
                            </div>
                            <div class="disk-center"></div>
                            <!-- POINTER at 180° (bottom) -->
                            <div style="
                                position: absolute;
                                bottom: -5px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 0;
                                height: 0;
                                border-left: 8px solid transparent;
                                border-right: 8px solid transparent;
                                border-bottom: 20px solid #ff0000;
                                filter: drop-shadow(0 0 4px rgba(255, 0, 0, 0.8));
                                z-index: 1000;
                                pointer-events: none;
                            "></div>
                        </div>
                    </div>
                </div>
                
                <!-- Central Pointer Section -->
                <div class="central-pointer-section">
                    <div class="battle-pointer-container">
                        <div class="diamond-shape" id="diamondPointer"></div>
                        <div class="pointer-line"></div>
                    </div>
                    <div class="vs-indicator" id="spin-button" style="cursor: pointer;">VS</div>
                </div>
                
                <!-- User Section (Bottom) -->
                <div class="user-battle-section">
                    <div class="disk-wrapper user-disk" id="bottom-disk">
                        <div class="data-disk" id="attackerDisk">
                            <div class="disk-wheel" id="attackerWheel">
                                <!-- User wheel segments populated by JavaScript -->
                            </div>
                            <div class="disk-center"></div>
                            <!-- POINTER at 0° (top) -->
                            <div style="
                                position: absolute;
                                top: -5px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 0;
                                height: 0;
                                border-left: 8px solid transparent;
                                border-right: 8px solid transparent;
                                border-top: 20px solid #00ff00;
                                filter: drop-shadow(0 0 4px rgba(0, 255, 0, 0.8));
                                z-index: 1000;
                                pointer-events: none;
                            "></div>
                        </div>
                    </div>
                    <div class="robot-name user-name" id="attackerName">Your Robot</div>
                    <div id="bottom-move-display" class="move-display"></div>
                </div>
            </div>
            
            <div class="battle-outcome" id="diskBattleOutcome" style="display: none;">
                <!-- Outcome populated by JavaScript -->
            </div>
            
            <!-- Live Spin Results Display -->
            <div id="liveSpinResults" style="display: none; margin: 20px auto; max-width: 700px;">
                <div style="
                    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(147, 51, 234, 0.2) 100%);
                    border: 2px solid rgba(147, 51, 234, 0.5);
                    border-radius: 15px;
                    padding: 20px;
                ">
                    <h3 style="
                        color: #ffd93d;
                        text-align: center;
                        margin: 0 0 15px 0;
                        font-size: 20px;
                        text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
                    ">🎯 SPIN RESULTS</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <!-- Your Robot Result -->
                        <div style="
                            background: rgba(74, 222, 128, 0.1);
                            border: 2px solid rgba(74, 222, 128, 0.3);
                            border-radius: 10px;
                            padding: 15px;
                            text-align: center;
                        ">
                            <div style="color: #4ade80; font-size: 14px; font-weight: bold; margin-bottom: 10px;">
                                YOUR ROBOT
                            </div>
                            <div id="attackerSpinResult" style="
                                color: white;
                                font-size: 18px;
                                font-weight: bold;
                                margin-bottom: 5px;
                                min-height: 50px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">Spinning...</div>
                            <div id="attackerSpinType" style="
                                color: #fbbf24;
                                font-size: 12px;
                                text-transform: uppercase;
                            ">-</div>
                            <div id="attackerSpinPower" style="
                                color: #60a5fa;
                                font-size: 14px;
                                margin-top: 5px;
                            ">-</div>
                        </div>
                        
                        <!-- Opponent Result -->
                        <div style="
                            background: rgba(248, 113, 113, 0.1);
                            border: 2px solid rgba(248, 113, 113, 0.3);
                            border-radius: 10px;
                            padding: 15px;
                            text-align: center;
                        ">
                            <div style="color: #f87171; font-size: 14px; font-weight: bold; margin-bottom: 10px;">
                                OPPONENT
                            </div>
                            <div id="defenderSpinResult" style="
                                color: white;
                                font-size: 18px;
                                font-weight: bold;
                                margin-bottom: 5px;
                                min-height: 50px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">Spinning...</div>
                            <div id="defenderSpinType" style="
                                color: #fbbf24;
                                font-size: 12px;
                                text-transform: uppercase;
                            ">-</div>
                            <div id="defenderSpinPower" style="
                                color: #60a5fa;
                                font-size: 14px;
                                margin-top: 5px;
                            ">-</div>
                        </div>
                    </div>
                    
                    <!-- Spin Count -->
                    <div id="spinCount" style="
                        color: #a78bfa;
                        font-size: 13px;
                        text-align: center;
                        margin-top: 15px;
                    ">Initial Spin</div>
                </div>
            </div>
            
            <!-- Respin Button for Testing -->
            <div id="respinButtonContainer" style="display: none; text-align: center; margin: 20px 0;">
                <button class="continue-btn" id="respinBtn" style="
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    padding: 15px 40px;
                    font-size: 18px;
                    font-weight: bold;
                    border: none;
                    border-radius: 10px;
                    color: white;
                    cursor: pointer;
                    box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
                    transition: all 0.3s ease;
                ">
                    🔄 RESPIN (Testing Mode)
                </button>
                <div id="respinMessage" style="
                    color: #ffd93d;
                    font-size: 14px;
                    margin-top: 10px;
                    text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
                ">
                    Wheel landed on boundary line
                </div>
            </div>
            
            <!-- Battle Results Section -->
            <div id="battleResultsSection" style="display: none; margin: 30px auto; max-width: 600px;">
                <!-- Move Results -->
                <div style="
                    background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(168, 85, 247, 0.2) 100%);
                    border: 2px solid rgba(168, 85, 247, 0.5);
                    border-radius: 15px;
                    padding: 20px;
                    margin-bottom: 20px;
                ">
                    <h3 style="
                        color: #ffd93d;
                        text-align: center;
                        margin: 0 0 20px 0;
                        font-size: 22px;
                        text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
                    ">📊 MOVE RESULTS</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center;">
                        <!-- Attacker Move -->
                        <div style="text-align: center;">
                            <div style="color: #4ade80; font-size: 16px; font-weight: bold; margin-bottom: 5px;">YOUR ROBOT</div>
                            <div id="attackerMoveName" style="
                                color: white;
                                font-size: 20px;
                                font-weight: bold;
                                margin-bottom: 5px;
                            ">-</div>
                            <div id="attackerMoveType" style="
                                color: #fbbf24;
                                font-size: 14px;
                                text-transform: uppercase;
                            ">-</div>
                            <div id="attackerMovePower" style="
                                color: #60a5fa;
                                font-size: 16px;
                                margin-top: 5px;
                                font-weight: bold;
                            ">-</div>
                        </div>
                        
                        <!-- VS Divider -->
                        <div style="
                            color: #ffd93d;
                            font-size: 24px;
                            font-weight: bold;
                            text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
                        ">VS</div>
                        
                        <!-- Defender Move -->
                        <div style="text-align: center;">
                            <div style="color: #f87171; font-size: 16px; font-weight: bold; margin-bottom: 5px;">OPPONENT</div>
                            <div id="defenderMoveName" style="
                                color: white;
                                font-size: 20px;
                                font-weight: bold;
                                margin-bottom: 5px;
                            ">-</div>
                            <div id="defenderMoveType" style="
                                color: #fbbf24;
                                font-size: 14px;
                                text-transform: uppercase;
                            ">-</div>
                            <div id="defenderMovePower" style="
                                color: #60a5fa;
                                font-size: 16px;
                                margin-top: 5px;
                                font-weight: bold;
                            ">-</div>
                        </div>
                    </div>
                </div>
                
                <!-- Winner Display -->
                <div id="winnerDisplay" style="
                    background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(16, 185, 129, 0.2) 100%);
                    border: 3px solid rgba(34, 197, 94, 0.6);
                    border-radius: 15px;
                    padding: 25px;
                    text-align: center;
                    margin-bottom: 20px;
                ">
                    <div id="winnerText" style="
                        color: #4ade80;
                        font-size: 28px;
                        font-weight: bold;
                        text-shadow: 0 0 15px rgba(74, 222, 128, 0.8);
                        margin-bottom: 10px;
                    ">🏆 WINNER 🏆</div>
                    <div id="winnerReason" style="
                        color: #fbbf24;
                        font-size: 16px;
                        margin-top: 10px;
                    ">-</div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button class="continue-btn" id="respinBothBtn" onclick="app.respinBothWheels()" style="
                        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        border: none;
                        border-radius: 10px;
                        color: white;
                        cursor: pointer;
                        box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
                        transition: all 0.3s ease;
                    ">
                        🔄 Respin Both Wheels
                    </button>
                    <button class="continue-btn" onclick="app.closeDiskBattle()" style="
                        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        border: none;
                        border-radius: 10px;
                        color: white;
                        cursor: pointer;
                        box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
                        transition: all 0.3s ease;
                    ">
                        ← Back to Combat Tester
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const app = {
            data: {
                categories: [],
                currentCategoryId: null,
                currentTaskId: null,
                currentSaveFile: 'default',
                lastSaveTime: null,
                ttsEnabled: true,
                activityLog: [],
                voiceStyle: 'robotic',
                voicePitch: 1.5,
                voiceRate: 1.2,
                scrappyPitch: 0.5,
                scrappyRate: 1.3,
                selectedRobotId: 'default',
                currency: 250,
                ownedRobots: ['default'],
                lastDailyReset: null,
                dailyChoresCompleted: 0,
                dailyMissionStatus: {
                    checkIn: 'unclaimed',
                    twoChores: 'incomplete',
                    fourChores: 'incomplete'
                },
                currentMissionTab: 'daily',
                mysteryGamePlayed: false,
                mysteryGameState: {
                    isActive: false,
                    gamePhase: 'start', // 'start', 'reveal', 'shuffle', 'pick', 'result'
                    prizes: [],
                    selectedBox: null,
                    wonPrize: null,
                    isLocked: false // Prevents closing during animation
                }
            },

            storeRobots: [
                {
                    id: 'JACKOBOT',
                    cost: 100,
                    shadowImagePath: 'Imag/Achivments/Images/Jack-0-Bot/Jack-0-bot-shadow.png',
                    actualImagePath: 'Imag/Achivments/Images/Jack-0-Bot/Jack-0-Bot.png',
                    name: 'Jack-o\'-Bot'
                },
                {
                    id: 'MEGAROCKETMAN',
                    cost: 150,
                    shadowImagePath: 'Imag/Achivments/Images/MegaRocketMan/Mega-Shadow.png',
                    actualImagePath: 'Imag/Achivments/Images/MegaRocketMan/Mega.png',
                    name: 'Mega Rocket Man'
                },
                {
                    id: 'PIKABOT',
                    cost: 120,
                    shadowImagePath: 'Imag/Achivments/Images/Pike-achu/PikaBot-shadow.png',
                    actualImagePath: 'Imag/Achivments/Images/Pike-achu/PikaBot.png',
                    name: 'Pika-Bot'
                },
                {
                    id: 'BUZZBOT',
                    cost: 180,
                    shadowImagePath: 'Imag/Achivments/Images/Buzz-lite-point-0/Buzz-shadow.png',
                    actualImagePath: 'Imag/Achivments/Images/Buzz-lite-point-0/Buzz.png',
                    name: 'Buzz Lite-Point-0'
                }
            ],

            // Scrappy's dialogue
            scrappyDialogue: {
                greeting: [
                    "Whirrr... Clank... New customer detected. What can I bolt together for ya?",
                    "Welcome to the Factory. Don't mind the rust—it adds character.",
                    "Need a bot? Or just browsin' the prime scrap?",
                    "Bzzt... State your purpose. Or, ya know, just look around. Mind the loose wiring.",
                    "Come on in! Watch your step, I dropped a box of ball bearings this morning.",
                    "Another one. All right, let's see the blueprints in your head.",
                    "You again? The gears must be turning. What'll it be?",
                    "Don't just stand there, you're leaking oil on my floor... oh wait, that's me.",
                    "Bzzzt... customer alert. Now entering the finest heap of scrap in the city.",
                    "I smell a new project. Or maybe that's just a blown fuse.",
                    "Lookin' for a new companion? Or spare parts for the old one?",
                    "Welcome. I'd offer you a drink, but I only stock lubricant.",
                    "My audio sensors detect a wallet. Let's make a deal.",
                    "Careful. Fresh welds are still hot.",
                    "State your designation and purpose... nah, just tell me what you want to buy.",
                    "Heard you were in the market for some top-tier junk. You've come to the right place.",
                    "Just rolled in? Take a look around. Everything's for sale. Mostly.",
                    "Hope you're not just window shopping. These windows are filthy.",
                    "Clank... Whirr... Systems powering up for a new transaction.",
                    "Need a hand? Or a claw? Or a multi-tool? I've got 'em all.",
                    "Ah, a fresh chassis. Let's get you fitted for a new friend.",
                    "The factory is open. Let's build something.",
                    "Don't touch that! Unless you're buying it. Then please touch it.",
                    "Scrappy's the name, robots are my game. What's your malfunction?",
                    "You look like you could use a robot. Everyone does."
                ],
                idle: [
                    "squeak... Must remember to oil that joint. Later.",
                    "Hmm, this cog would look great on a Mark IV chassis...",
                    "Ah, the smell of burnt circuits in the morning. Smells like... progress.",
                    "Processing... processing... still processing. This thinkin' stuff is hard work.",
                    "You ever wonder if we're all just spare parts in a bigger machine?",
                    "clank clatter Whoops. Butter-servos today.",
                    "This place ain't much, but it's full of potential... potential robots, that is.",
                    "Someday I'll get around to sorting these screws... someday.",
                    "Rerouting power from non-essential systems... like my emotional inhibitors.",
                    "Is it dusty in here, or is my optical sensor failing again?",
                    "Hmm. That chassis model has a known defect in the primary motherboard. Buyer beware.",
                    "Another quiet cycle. Perfect for polishing my wrenches.",
                    "Diagnostic complete: Still awesome.",
                    "I wonder if that toaster I built last week is still functioning.",
                    "Note to self: a 12-volt battery does NOT power a 24-volt servo.",
                    "The hum of the machinery... it's like a lullaby.",
                    "Recalibrating... There, that's better. Or worse. Hard to tell.",
                    "I've got spare parts older than this building.",
                    "Sometimes I think about building myself a nice little dog-bot. But who has the time?",
                    "Error 404: Motivation not found. Rebooting...",
                    "That reminds me, I need to recharge my own power cell soon.",
                    "This rust gives me a certain... distinguished look, doesn't it?",
                    "One robot's trash is another robot's treasure. And it's all my treasure.",
                    "The price of copper is up again. Typical.",
                    "If I had a nickel for every loose wire in here... I'd have enough to buy a new capacitor.",
                    "Zzzzt... Power-saving mode engaged.",
                    "I should invent a robot that cleans the shop. Nah, too much work."
                ],
                purchased: [
                    "A fine choice! Bolting it together for ya now. Zzzzap!",
                    "Sold! One premium, pre-owned... well, one premium robot, comin' right up.",
                    "Transaction complete. Another creation finds a home. Try not to break it on the way out.",
                    "It's yours! Warranty void if you... well, the warranty's void. Enjoy!",
                    "Bleep-bloop. Purchase registered. I'll use the good rivets for this one.",
                    "Excellent. Firing up the assembly line. Stand back.",
                    "This one's a classic. Good choice. Very reliable.",
                    "Another one of my creations, out in the world. Makes my circuits hum.",
                    "Your credits are good here. Finalizing assembly.",
                    "A wise investment. This bot will pay for itself. Probably.",
                    "This model has my personal seal of approval. Which is just a bit of grease I put on it.",
                    "You've got a good eye for quality scrap.",
                    "Initiating ownership transfer protocol. It's all yours.",
                    "She's a beaut, ain't she? Fresh off the scrap heap.",
                    "I'll box it up for you. Or, you know, just hand you the loose parts.",
                    "Done and done. It's been a pleasure doing business.",
                    "Bleep. Another successful build.",
                    "Take good care of it. I used my favorite wrench on this one.",
                    "Logical decision. This unit is 87% efficient.",
                    "You won't regret this. And if you do, all sales are final.",
                    "Adding the final touches... There. Perfect.",
                    "Glad this one's going to a good home. It was starting to get attached to the shelf.",
                    "Transaction confirmed. May your bot's battery life be long and prosperous.",
                    "Consider it yours. I even tightened all the bolts.",
                    "Whirrr... Clank... SOLD! To the organic with good taste."
                ],
                canceled: [
                    "Changed your mind, eh? Fine by me. More parts for my next project.",
                    "Bzzt. Order canceled. Re-routing spare parts to... the spare parts pile.",
                    "No deal? Your loss. This one had a perfectly good alternator.",
                    "Purchase voided. Halting assembly line... grrrrind...",
                    "Whatever. More for the scrap heap.",
                    "What? You trying to confuse my logic gates?",
                    "Fine. I didn't want to sell that one anyway. It... has sentimental value.",
                    "Bzzzt! Re-shelving unit. Don't waste my cycles next time.",
                    "Changed your mind? Figures. Organics are so indecisive.",
                    "Halting production. My welder is very disappointed.",
                    "Your loss. That one had a fully functional... thingamajig.",
                    "Error: Customer commitment not found.",
                    "My inventory levels thank you, but my wallet does not.",
                    "So that's a no, then? Fine. Plenty of other parts in the sea.",
                    "You're lucky I haven't started welding yet.",
                    "This is why I prefer working with machines. They're predictable.",
                    "Well, that was a waste of perfectly good electricity.",
                    "Input canceled. Returning to idle state. Grumpily.",
                    "I was THIS close to making my quota for the day.",
                    "No deal? You're breaking my tiny robotic heart.",
                    "Whatever. I'll just use these parts for something cooler.",
                    "Get your priorities straight and then come back.",
                    "I see. A browser, not a buyer.",
                    "And for a second there, I thought you had good taste.",
                    "Okay, back to the parts pile it goes."
                ],
                goodbye: [
                    "Come back soon! I'm always buildin' somethin' new... from somethin' old.",
                    "Exit protocols engaged. Watch the door, it sticks.",
                    "Later, circuit-head. Don't get rusty out there.",
                    "Transmission ending. Bzzzzt.",
                    "Go on, get outta here. These robots won't build themselves.",
                    "Don't be a stranger. Unless you are one. In which case, hi stranger, now goodbye.",
                    "Come back if anything falls off. I might have a replacement.",
                    "Powering down customer interaction module.",
                    "Get going. I've got robots to build and oil to spill.",
                    "See you on the other side of the charging station.",
                    "May your processors stay cool.",
                    "End of line.",
                    "Watch your back out there. Lots of rogue vacuum cleaners.",
                    "Don't forget to defragment your hard drive.",
                    "All right, see ya. This heap won't manage itself.",
                    "Feel free to return. The junk will still be here.",
                    "Come back when you've got more credits.",
                    "Exiting... Don't trip over the toolbox on your way out.",
                    "Stay functional.",
                    "Transmission terminated. Have a satisfactory day cycle.",
                    "Okay, you've taken up enough of my processing time. Scram.",
                    "The factory doors are that way. Try not to let them hit you.",
                    "Later. I've got a date with a blowtorch.",
                    "Remember, if it ain't broke, it just doesn't have enough features yet.",
                    "Safe travels, flesh-bag."
                ]
            },

            scrappyIdleTimer: null,
            purchaseInProgress: false,
            
            // OBONXO Cheat Code State
            isObonxoCheatActive: false,

            robots: [
                {
                    id: 'default',
                    name: 'Default Bot',
                    happyImage: 'Imag/mascot.png',
                    sadImage: 'Imag/mascot.png',
                    thinkingImage: 'Imag/mascot.png'
                },
                {
                    id: 'JACKOBOT',
                    name: 'Jack-o\'-Bot',
                    happyImage: 'Imag/Achivments/Images/Jack-0-Bot/Jack-0-Bot.png',
                    sadImage: 'Imag/Achivments/Images/Jack-0-Bot/Jack-0-Bot-mad.png',
                    thinkingImage: 'Imag/Achivments/Images/Jack-0-Bot/Jack-0-Bot-low.png',
                    hasCustomDialogue: true,
                    dialogue: {
                        greeting: [
                            "The season of the witch is upon us! Ready to brew up some cleanliness?",
                            "My pumpkin spice circuits are fully engaged! Let's illuminate this chore list!",
                            "Beware the decay! We must maintain the peace. Report for duty, fellow ghoul-fighter!",
                            "Don't worry, the only thing spooky here is the thought of leaving chores undone.",
                            "Time to carve out a perfect day! What's our first frighteningly fun task?"
                        ],
                        success: [
                            "Chore complete! We put the boo in bootifully clean!",
                            "Mission accomplished! That mess is officially a goner!",
                            "We swept up that task faster than a headless horseman through the night!",
                            "Yes! That freshness meter is absolutely fang-tastic!",
                            "Looks like we sealed that chore away for another year!"
                        ],
                        achievement: [
                            "A chillingly cool achievement! My internal light is burning brighter!",
                            "More Bolts! I'm feeling like a fully charged Frankenstein!",
                            "This is better than finding a haunted house full of candy! Excellent progress!",
                            "Keep it up, and you'll be the Lord of the Gourd-ians of Upkeep!"
                        ],
                        broken: [
                            "Oh, woe is me! My pumpkin guts are spilling out... systems are degrading...",
                            "Help! I'm melting! I need a repair before I become a sad, squishy, seasonal tragedy!",
                            "My flame is dimming... I'm suffering a severe case of critical candlemolt! Fix me!",
                            "Warning! I'm beginning to rot! This is my final haunting plea for maintenance!"
                        ],
                        random: [
                            "Did you know the best way to clean is to use a little 'Hocus Pocus'?",
                            "Watch out for the zombies... or maybe just the overflowing laundry basket!",
                            "Sometimes I float around making scary noises... just to see if the dust runs away.",
                            "I always save the candy corn for last! It's the tastiest part of my belt.",
                            "My favorite movie is 'The Nightmare Before Task-mas!'"
                        ],
                        mad: [
                            "By the sacred stem! This ghastly mess is simply un-boo-lievable!",
                            "This disarray is a total fright! My internal gears are grinding like skeletons!",
                            "I am the Jack-o'-Bot! And you have disturbed my eternal rest! Clean up, NOW!",
                            "My patience is thinning like a vampire's shadow! Rectify this disorder immediately!",
                            "Don't make me use my spooky laser beam on that dust pile!"
                        ]
                    }
                },
                {
                    id: 'MEGAROCKETMAN',
                    name: 'Mega Rocket Man',
                    happyImage: 'Imag/Achivments/Images/MegaRocketMan/Mega.png',
                    sadImage: 'Imag/Achivments/Images/MegaRocketMan/Mega-mad (1).png',
                    thinkingImage: 'Imag/Achivments/Images/MegaRocketMan/Mega-low.png',
                    hasCustomDialogue: true,
                    dialogue: {
                        greeting: [
                            "Ready to clean! Let's do this!",
                            "Systems nominal. What's next on the chore list?",
                            "My programming is for peace and order... and cleanliness!",
                            "It's a good day for some tidying!",
                            "Fighting Wily's robots, or fighting dust bunnies... duty calls!"
                        ],
                        success: [
                            "Chore complete! Another area maintained!",
                            "任務完了! (Task Complete!)",
                            "Yeah! Mission accomplished!",
                            "Looks like we swept them clean!",
                            "All systems green!"
                        ],
                        achievement: [
                            "Wow! An achievement unlocked! Thank you!",
                            "My power level feels... tidier!",
                            "More Bolts for the Workshop! Excellent!",
                            "I'm becoming quite the Upkeep Master!"
                        ],
                        broken: [
                            "Uh oh... systems... degrading... Must... fix... soon...",
                            "Error... cleanliness protocols... failing... Help me!",
                            "My circuits... they ache. A fix would be most appreciated.",
                            "Warning! Critical decay! Need repair! Need repair!"
                        ],
                        random: [
                            "Sometimes I wonder what Dr. Light would think of my mopping skills.",
                            "Beep boop! Just checking the freshness meters.",
                            "I wish I had an 'E-Tank' for energy when chores feel tough!",
                            "Watch out, dirt! Here comes the Upkeep Unit!",
                            "Even heroes need to organize their gear, right?",
                            "Guts Man might lift heavy, but can he scrub heavy?",
                            "For everlasting peace... and a sparkling home!"
                        ],
                        mad: [
                            "Buster ready! My systems are detecting high levels of frustration due to this mess!",
                            "This is highly inefficient! Why is this task still incomplete?",
                            "Warning! My anger levels are approaching critical mass! Let's clean this up!",
                            "Dr. Wily's messes were easier to clear! This is unacceptable!",
                            "Error! Emotional circuits overloading! Initiate cleanup sequence, NOW!",
                            "My programming does not allow for such prolonged disarray! Rectify immediately!",
                            "I am Mega Man! And this mess... this mess vexes me!",
                            "My energy tank is full of frustration! Let's get these tasks neutralized!"
                        ]
                    }
                },
                {
                    id: 'PIKABOT',
                    name: 'Pika-Bot',
                    happyImage: 'Imag/Achivments/Images/Pike-achu/PikaBot.png',
                    sadImage: 'Imag/Achivments/Images/Pike-achu/PikaBot-mad.png',
                    thinkingImage: 'Imag/Achivments/Images/Pike-achu/PikaBot-low.png',
                    hasCustomDialogue: true,
                    dialogue: {
                        greeting: [
                            "Pika pika! Ready to zap some dirt!",
                            "My circuits are charged! What's our next task?",
                            "Spark, spark! Time to keep things bright!",
                            "Maintaining the balance, one shock at a time!",
                            "A clean home is a happy home, pika!"
                        ],
                        success: [
                            "Zzzzt! Chore complete!",
                            "任務完了! (Task Complete!) Feels electrifyingly good!",
                            "Pika-chuuuuu! We did it!",
                            "Cleaned right up! Shocking, isn't it?",
                            "Power fully restored!"
                        ],
                        achievement: [
                            "Wow! A new achievement! Static crackle!",
                            "My energy levels are rising with these Bolts!",
                            "Another badge for the Pika-vault!",
                            "I'm generating so much good upkeep energy!"
                        ],
                        broken: [
                            "Pika... pika... systems failing... (sad static crackle)",
                            "My gears are... sparking... the wrong way. Need help!",
                            "Uh-oh... short-circuiting... Can you patch me up?",
                            "Warning! Critical voltage low! Maintenance needed now!"
                        ],
                        random: [
                            "Sometimes I wish I could use Thunderbolt on these dust bunnies!",
                            "Checking for static cling, pika!",
                            "Do you think a T-bolt would clean the windows faster?",
                            "Pika-power to the people... and their chores!",
                            "A happy trainer, a happy robot!",
                            "I wonder if Raichu is good at organizing...?",
                            "Keeping the home environment... positively charged!"
                        ],
                        mad: [
                            "Pika-CHUUUUUU! This mess is... SHOCKINGLY bad!",
                            "Zzzzt! My internal capacitor is boiling! Why isn't this clean?!",
                            "Grrr... Pika! Unacceptable levels of dirt! Time for a Thunder Shock!",
                            "Static crackle! My patience is wearing thin, pika! Let's get this done!",
                            "I'm feeling... overcharged with frustration! This is not good!",
                            "This situation is getting critical! My tail is twitching in anger, pika!",
                            "Don't make me use Volt Tackle on these dust bunnies! Just clean them!",
                            "Pika! This mess is creating a severe energy drain!"
                        ]
                    }
                },
                {
                    id: 'BUZZBOT',
                    name: 'Buzz Lite-Point-0',
                    happyImage: 'Imag/Achivments/Images/Buzz-lite-point-0/Buzz.png',
                    sadImage: 'Imag/Achivments/Images/Buzz-lite-point-0/Buzz-mad.png',
                    thinkingImage: 'Imag/Achivments/Images/Buzz-lite-point-0/Buzz-low.png',
                    hasCustomDialogue: true,
                    dialogue: {
                        greeting: [
                            "Buzz Lightyear to the rescue! What's our mission today?",
                            "Reporting for duty! Ready to tackle any chore, to infinity... and beyond!",
                            "My laser is calibrated, my wings are primed. Let's make this space spotless!",
                            "Star Command protocols dictate a clean environment. Affirmative!",
                            "There's a chore in my boot! Just kidding. Let's get to work!"
                        ],
                        success: [
                            "Mission accomplished! The area is secure!",
                            "任務完了! (Task Complete!) Another successful space sweep!",
                            "Victory is ours! The forces of grime have been vanquished!",
                            "Looks like we've brought order to this sector!",
                            "All systems optimized! Freshness levels are peak performance!"
                        ],
                        achievement: [
                            "By my calculations, an achievement has been unlocked! Splendid!",
                            "My internal power source grows with every Bolt! To infinity and beyond!",
                            "Another step closer to becoming a Galactic Guru of Upkeep!",
                            "My log entries show remarkable progress! Keep it up, Space Ranger!"
                        ],
                        broken: [
                            "Uh-oh... Buzz Lightyear to Star Command... I'm experiencing critical system malfunctions...",
                            "My internal gyros are failing... I need a refit, STAT!",
                            "This is Buzz Lightyear... I've crash-landed! Need immediate maintenance!",
                            "Warning! Structural integrity compromised! Requesting immediate repair mission!"
                        ],
                        random: [
                            "Sometimes I miss chasing Zurg, but a clean home is a noble mission too!",
                            "Is that a dust bunny, or an alien threat? Must investigate!",
                            "My voice box might not be pull-string, but my commitment is 100%!",
                            "You are a sad, strange little human... if you leave chores undone!",
                            "For the sake of the galaxy... and your living room, let's keep it tidy!",
                            "I've faced hostile aliens, but this sticky stain... it's a new challenge!",
                            "I am Buzz Lightyear! I come in peace... to make sure your chores are done!"
                        ],
                        mad: [
                            "Great Star Command! This mess is unacceptable! We must rectify this immediately!",
                            "Blast! My circuits are overheating with frustration! This level of disarray is illogical!",
                            "I am Buzz Lightyear! And I will NOT tolerate this grime! To battle!",
                            "Unacceptable! This chore should have been completed hours ago! My patience is wearing thin!",
                            "By the power of the Zurg's dark minions, this is truly frustrating! Clean up, soldiers!",
                            "My mission parameters clearly state a pristine environment! This... this is chaos!",
                            "You call this a clean sector? I've seen tidier asteroid fields!",
                            "My laser might not be set to stun, but my glare certainly is!"
                        ]
                    }
                }
            ],

            mascotState: {
                isSpeaking: false,
                isThinking: false,
                lastMentionedTask: null,
                lastThoughtTime: 0
            },

            tts: {
                synthesis: window.speechSynthesis,
                currentUtterance: null
            },

            ui: {
                categoryColors: [
                    { bg: 'linear-gradient(135deg, #65D46E, #93E198)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #5C9DFF, #8AB6FF)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #A478FF, #C1A3FF)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #FF8A54, #FFB28E)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #FF588A, #FF8FAB)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #5CDAFF, #99E5FF)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #4ECDC4, #44A08D)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #FF6B6B, #FFE66D)', text: '#000' },
                    { bg: 'linear-gradient(135deg, #9B59B6, #8E44AD)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #3498DB, #2980B9)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #E74C3C, #C0392B)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #2ECC71, #27AE60)', text: '#fff' },
                    { bg: 'linear-gradient(135deg, #F39C12, #E67E22)', text: '#fff' },
                ],
                categoryBackgrounds: {
                    'Kitchen': 'Imag/Kitchen Background.png',
                    'Bathroom': 'Imag/Bathroom Background.png',
                    'Bedroom': 'Imag/Bedroom Background.png',
                    'Guest Bedroom': 'Imag/Guest Bedroom background.png',
                    'Living Room': 'Imag/Living room background.png',
                    'Hallway': 'Imag/Hallway Background.png',
                    'Laundry Room': 'Imag/Laundry Room Background.png',
                    'Backyard': 'Imag/Backyard Background.png',
                    'Back Porch': 'Imag/Back Portch Background.png',
                    'Vehicle': 'Imag/Vehicle Background.png',
                    'Vacuum & Sweeping': 'Imag/Vacum and Sweeping background.png',
                    'Front Yard': 'Imag/Front Yard Background.png',
                    'Front Porch': 'Imag/Front Porch Background.png'
                },
                mainBackgrounds: [
                    'Imag/Main Background.png',
                    'Imag/Main Background 2.png',
                    'Imag/Main background 3.png'
                ]
            },

            init() {
                this.loadData();
                // Always start on the dashboard
                this.data.currentCategoryId = null;
                this.data.currentTaskId = null;
                // Set random main background
                this.setRandomMainBackground();
                // Load selected robot
                this.loadSelectedRobot();
                this.render();
                // Update currency display
                this.updateCurrencyDisplay();
                // Update decay every minute
                setInterval(() => this.updateDecay(), 60000);
                // Initial decay update
                this.updateDecay();
                // Mascot greeting
                setTimeout(() => this.mascotGreet(), 1000);
                // Mascot dodge behavior
                this.initMascotDodge();
                // Load TTS voices
                this.initTTS();
                // Ensure Scrappy is hidden on startup
                const scrappyContainer = document.getElementById('scrappyContainer');
                if (scrappyContainer) {
                    scrappyContainer.style.display = 'none';
                }
                // Check cheat status on startup
                this.checkObonxoCheatStatus();
            },

            initTTS() {
                // Load voices (some browsers need this)
                if (this.tts.synthesis.getVoices().length === 0) {
                    this.tts.synthesis.addEventListener('voiceschanged', () => {
                        console.log('TTS voices loaded');
                    });
                }
            },

            openRobotSelect() {
                const modal = document.getElementById('robotSelectModal');
                modal.style.display = 'flex';
                this.renderRobotOptions();
            },

            closeRobotSelect() {
                const modal = document.getElementById('robotSelectModal');
                modal.style.display = 'none';
            },

            renderRobotOptions() {
                const container = document.getElementById('robotSelectGrid');
                
                if (!container) return;
                
                // Filter to only show owned robots
                const ownedRobots = this.robots.filter(robot => 
                    this.data.ownedRobots.includes(robot.id)
                );
                
                // Create zig-zag layout using the specified slot pattern
                // Pattern: [1][2][5][7][9]...
                //          [3][4][6][8][10]...
                // Robots fill sequentially: 1st robot->Slot1, 2nd robot->Slot2, etc.
                const createZigZagLayout = (robots) => {
                    const row1 = [];
                    const row2 = [];
                    
                    // For each robot, determine its visual position based on slot number
                    robots.forEach((robot, robotIndex) => {
                        const slotNumber = robotIndex + 1; // 1-based slot numbering
                        
                        // Determine position based on slot number pattern
                        if (slotNumber === 1 || slotNumber === 2) {
                            // First 2x2 block, top row
                            row1.push(robot);
                        } else if (slotNumber === 3 || slotNumber === 4) {
                            // First 2x2 block, bottom row
                            row2.push(robot);
                        } else {
                            // For slots 5+, determine which block and position
                            const adjustedSlot = slotNumber - 4; // Slots 5,6,7,8 become 1,2,3,4
                            const blockNumber = Math.floor((adjustedSlot - 1) / 4);
                            const positionInBlock = ((adjustedSlot - 1) % 4) + 1;
                            
                            if (positionInBlock === 1 || positionInBlock === 2) {
                                // Top row of this block
                                row1.push(robot);
                            } else {
                                // Bottom row of this block  
                                row2.push(robot);
                            }
                        }
                    });
                    
                    // Ensure both rows have the same length by padding with nulls
                    const maxLength = Math.max(row1.length, row2.length);
                    while (row1.length < maxLength) row1.push(null);
                    while (row2.length < maxLength) row2.push(null);
                    
                    return { row1, row2 };
                };
                
                const { row1, row2 } = createZigZagLayout(ownedRobots);
                
                // Create robot card HTML
                const createRobotCard = (robot) => {
                    if (!robot) {
                        return `
                            <div class="robot-select-card empty-slot">
                                <div class="empty-slot-icon">⚪</div>
                                <div class="empty-slot-text">Empty Slot</div>
                            </div>
                        `;
                    }
                    return `
                        <div class="robot-select-card ${robot.id === this.data.selectedRobotId ? 'selected' : ''}" 
                             onclick="app.selectRobot('${robot.id}')">
                            <img src="${robot.happyImage}" alt="${robot.name}" class="robot-select-card-image">
                            <div class="robot-select-card-name">${robot.name}</div>
                            <div class="robot-select-card-status">
                                ${robot.id === this.data.selectedRobotId ? 'Currently Active' : 'Available'}
                            </div>
                            ${robot.id === this.data.selectedRobotId ? 
                                '<div class="robot-selected-badge">✓</div>' : ''}
                        </div>
                    `;
                };
                
                // Display robots in zig-zag pattern
                container.innerHTML = `
                    <div class="robot-select-row">
                        ${row1.map(createRobotCard).join('')}
                    </div>
                    <div class="robot-select-row">
                        ${row2.map(createRobotCard).join('')}
                    </div>
                `;
            },

            selectRobot(robotId) {
                this.data.selectedRobotId = robotId;
                this.saveData();
                this.renderRobotOptions();
                
                // Update mascot image
                const selectedRobot = this.robots.find(r => r.id === robotId);
                const mascotImg = document.querySelector('.mascot-container-global img');
                if (mascotImg && selectedRobot) {
                    mascotImg.src = selectedRobot.happyImage;
                }
                
                // Mascot speaks with custom dialogue if available
                if (selectedRobot && selectedRobot.hasCustomDialogue) {
                    const message = selectedRobot.dialogue.greeting[Math.floor(Math.random() * selectedRobot.dialogue.greeting.length)];
                    this.showSpeechBubble(message, 'regular');
                } else {
                    this.mascotSpeak(`You selected ${selectedRobot.name}! Let's keep things clean!`);
                }
            },

            loadSelectedRobot() {
                // Load the selected robot on app startup
                const selectedRobot = this.robots.find(r => r.id === this.data.selectedRobotId) || this.robots[0];
                const mascotImg = document.querySelector('.mascot-container-global img');
                if (mascotImg && selectedRobot) {
                    mascotImg.src = selectedRobot.happyImage;
                }
            },

            setRandomMainBackground() {
                document.body.style.backgroundImage = `url('Imag/Main Background 2.png')`;
            },

            initMascotDodge() {
                const mascotContainer = document.querySelector('.mascot-container-global');
                let dodgeTimeout;

                document.addEventListener('click', (e) => {
                    const mascotRect = mascotContainer.getBoundingClientRect();
                    const mascotCenterX = mascotRect.left + mascotRect.width / 2;
                    const mascotCenterY = mascotRect.top + mascotRect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - mascotCenterX, 2) + 
                        Math.pow(e.clientY - mascotCenterY, 2)
                    );

                    // If click is within 150px of mascot, make it dodge
                    if (distance < 150) {
                        const angle = Math.atan2(mascotCenterY - e.clientY, mascotCenterX - e.clientX);
                        const dodgeDistance = 80;
                        const dodgeX = Math.cos(angle) * dodgeDistance;
                        const dodgeY = Math.sin(angle) * dodgeDistance;

                        mascotContainer.classList.add('dodging');
                        mascotContainer.style.transform = `translate(${dodgeX}px, ${dodgeY}px)`;

                        clearTimeout(dodgeTimeout);
                        dodgeTimeout = setTimeout(() => {
                            mascotContainer.classList.remove('dodging');
                            mascotContainer.style.transform = '';
                        }, 1000);
                    }
                });

                document.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 0) return;
                    const touch = e.touches[0];
                    const mascotRect = mascotContainer.getBoundingClientRect();
                    const mascotCenterX = mascotRect.left + mascotRect.width / 2;
                    const mascotCenterY = mascotRect.top + mascotRect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(touch.clientX - mascotCenterX, 2) + 
                        Math.pow(touch.clientY - mascotCenterY, 2)
                    );

                    if (distance < 150) {
                        const angle = Math.atan2(mascotCenterY - touch.clientY, mascotCenterX - touch.clientX);
                        const dodgeDistance = 80;
                        const dodgeX = Math.cos(angle) * dodgeDistance;
                        const dodgeY = Math.sin(angle) * dodgeDistance;

                        mascotContainer.classList.add('dodging');
                        mascotContainer.style.transform = `translate(${dodgeX}px, ${dodgeY}px)`;

                        clearTimeout(dodgeTimeout);
                        dodgeTimeout = setTimeout(() => {
                            mascotContainer.classList.remove('dodging');
                            mascotContainer.style.transform = '';
                        }, 1000);
                    }
                });
            },

            loadData() {
                const currentFile = localStorage.getItem('upkeepCurrentFile') || 'default';
                this.data.currentSaveFile = currentFile;
                
                const saved = localStorage.getItem(`upkeepData_${currentFile}`);
                if (saved) {
                    this.data = JSON.parse(saved);
                    this.data.currentSaveFile = currentFile;
                    
                    // Ensure activityLog exists
                    if (!this.data.activityLog) {
                        this.data.activityLog = [];
                    }
                    
                    // Ensure ownedRobots exists (for backward compatibility with old saves)
                    if (!this.data.ownedRobots) {
                        this.data.ownedRobots = ['default'];
                    }
                    
                    // Ensure currency exists (for backward compatibility with old saves)
                    if (this.data.currency === undefined || this.data.currency === null) {
                        this.data.currency = 250;
                    }
                    
                    // Ensure selectedRobotId exists
                    if (!this.data.selectedRobotId) {
                        this.data.selectedRobotId = 'default';
                    }
                    
                    // Ensure voice settings exist
                    if (this.data.ttsEnabled === undefined) {
                        this.data.ttsEnabled = true;
                    }
                    if (!this.data.voiceStyle) {
                        this.data.voiceStyle = 'robotic';
                    }
                    if (!this.data.voicePitch) {
                        this.data.voicePitch = 1.5;
                    }
                    if (!this.data.voiceRate) {
                        this.data.voiceRate = 1.2;
                    }
                    if (!this.data.scrappyPitch) {
                        this.data.scrappyPitch = 0.5;
                    }
                    if (!this.data.scrappyRate) {
                        this.data.scrappyRate = 1.3;
                    }
                    
                    // Ensure mission fields exist
                    if (!this.data.lastDailyReset) {
                        this.data.lastDailyReset = null;
                    }
                    if (!this.data.lastDailyResetDate) {
                        this.data.lastDailyResetDate = '';
                    }
                    if (this.data.dailyChoresCompleted === undefined) {
                        this.data.dailyChoresCompleted = 0;
                    }
                    if (this.data.dailyBonusClaimed === undefined) {
                        this.data.dailyBonusClaimed = false;
                    }
                    if (!this.data.dailyMissionStatus) {
                        this.data.dailyMissionStatus = {
                            checkIn: 'unclaimed',
                            twoChores: 'incomplete',
                            fourChores: 'incomplete'
                        };
                    }
                    if (!this.data.currentMissionTab) {
                        this.data.currentMissionTab = 'daily';
                    }
                } else {
                    // Demo data for first-time users
                    this.data = {
                        categories: [
                            {
                                id: Date.now(),
                                name: 'Kitchen',
                                tasks: [
                                    {
                                        id: Date.now() + 1,
                                        name: 'Wipe down counters',
                                        decayMs: 2 * 24 * 60 * 60 * 1000, // 2 days
                                        lastCompleted: Date.now() - (1 * 24 * 60 * 60 * 1000), // 1 day ago
                                        freshness: 50
                                    },
                                    {
                                        id: Date.now() + 2,
                                        name: 'Clean stovetop',
                                        decayMs: 3 * 24 * 60 * 60 * 1000, // 3 days
                                        lastCompleted: Date.now() - (2 * 24 * 60 * 60 * 1000), // 2 days ago
                                        freshness: 33
                                    }
                                ]
                            },
                            {
                                id: Date.now() + 100,
                                name: 'Bathroom',
                                tasks: [
                                    {
                                        id: Date.now() + 101,
                                        name: 'Clean toilet',
                                        decayMs: 7 * 24 * 60 * 60 * 1000, // 7 days
                                        lastCompleted: Date.now() - (3 * 24 * 60 * 60 * 1000), // 3 days ago
                                        freshness: 57
                                    }
                                ]
                            }
                        ],
                        currentCategoryId: null,
                        currentTaskId: null,
                        currentSaveFile: currentFile,
                        lastSaveTime: Date.now(),
                        ttsEnabled: true,
                        activityLog: [],
                        voiceStyle: 'robotic',
                        voicePitch: 1.5,
                        voiceRate: 1.2,
                        scrappyPitch: 0.5,
                        scrappyRate: 1.3,
                        selectedRobotId: 'default',
                        currency: 250,
                        ownedRobots: ['default']
                    };
                    this.saveData();
                }
            },

            saveData() {
                this.data.lastSaveTime = Date.now();
                localStorage.setItem(`upkeepData_${this.data.currentSaveFile}`, JSON.stringify(this.data));
                localStorage.setItem('upkeepCurrentFile', this.data.currentSaveFile);
                
                // Update save file list
                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                if (!saveFiles.find(f => f.name === this.data.currentSaveFile)) {
                    saveFiles.push({
                        name: this.data.currentSaveFile,
                        displayName: this.data.currentSaveFile === 'default' ? 'Default Save' : this.data.currentSaveFile,
                        lastModified: Date.now()
                    });
                    localStorage.setItem('upkeepSaveFiles', JSON.stringify(saveFiles));
                } else {
                    // Update last modified time
                    const file = saveFiles.find(f => f.name === this.data.currentSaveFile);
                    file.lastModified = Date.now();
                    localStorage.setItem('upkeepSaveFiles', JSON.stringify(saveFiles));
                }
            },

            // OBONXO Cheat Code Check Function
            checkObonxoCheatStatus() {
                // Search for a category with the exact name "OBONXO"
                const obonxoCategory = this.data.categories.find(category => category.name === "OBONXO");
                
                if (!obonxoCategory) {
                    this.isObonxoCheatActive = false;
                    return;
                }
                
                // Search for a chore named "OBONXO" within the "OBONXO" category
                const obonxoChore = obonxoCategory.tasks && obonxoCategory.tasks.find(task => task.name === "OBONXO");
                
                if (obonxoChore) {
                    this.isObonxoCheatActive = true;
                    
                    // Auto-complete all daily missions when cheat is active
                    this.data.dailyMissionStatus.checkIn = 'completed';
                    this.data.dailyMissionStatus.twoChores = 'completed';
                    this.data.dailyMissionStatus.fourChores = 'completed';
                    this.data.dailyChoresCompleted = Math.max(this.data.dailyChoresCompleted, 4); // Ensure enough chores completed
                } else {
                    this.isObonxoCheatActive = false;
                }
            },

            updateDecay() {
                let updated = false;
                this.data.categories.forEach(category => {
                    if (!category.tasks) return;
                    category.tasks.forEach(task => {
                        // Check if task is snoozed
                        const isSnoozed = task.snoozedUntil && task.snoozedUntil > Date.now();
                        
                        // Auto-resume if snooze period has ended
                        if (task.snoozedUntil && task.snoozedUntil <= Date.now()) {
                            if (task.frozenFreshness !== undefined) {
                                task.freshness = task.frozenFreshness;
                                delete task.frozenFreshness;
                            }
                            delete task.snoozedUntil;
                            updated = true;
                        }
                        
                        // Don't decay if snoozed
                        if (isSnoozed) {
                            return;
                        }
                        
                        if (task.lastCompleted) {
                            const elapsed = Date.now() - task.lastCompleted;
                            const freshness = Math.max(0, Math.min(100, 100 - (elapsed / task.decayMs) * 100));
                            if (Math.abs(task.freshness - freshness) > 0.1) {
                                task.freshness = freshness;
                                updated = true;
                            }
                        }
                    });
                });
                if (updated) {
                    this.saveData();
                    this.render();
                }
            },

            calculateCategoryScore(category) {
                if (!category.tasks || category.tasks.length === 0) return 0;
                const sum = category.tasks.reduce((acc, task) => acc + (task.freshness || 0), 0);
                return Math.round(sum / category.tasks.length);
            },

            calculateOverallScore() {
                if (this.data.categories.length === 0) return 0;
                const sum = this.data.categories.reduce((acc, cat) => acc + this.calculateCategoryScore(cat), 0);
                return Math.round(sum / this.data.categories.length);
            },

            getProgressClass(score) {
                if (score >= 70) return '';
                if (score >= 40) return 'warning';
                return 'danger';
            },

            formatTimeAgo(timestamp) {
                if (!timestamp) return 'Never';
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 60) return 'Just now';
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                const days = Math.floor(hours / 24);
                if (days < 7) return `${days}d ago`;
                const weeks = Math.floor(days / 7);
                if (weeks < 4) return `${weeks}w ago`;
                const months = Math.floor(days / 30);
                return `${months}mo ago`;
            },

            formatDecayTime(ms) {
                const hours = ms / (60 * 60 * 1000);
                if (hours < 24) return `${Math.round(hours)}h`;
                const days = hours / 24;
                if (days < 7) return `${Math.round(days)}d`;
                const weeks = days / 7;
                if (weeks < 4) return `${Math.round(weeks)}w`;
                const months = days / 30;
                return `${Math.round(months)}mo`;
            },

            getDecayMs(value, unit) {
                const val = parseInt(value);
                const day = 24 * 60 * 60 * 1000;
                switch (unit) {
                    case 'hours': return val * 60 * 60 * 1000;
                    case 'days': return val * day;
                    case 'weeks': return val * 7 * day;
                    case 'months': return val * 30 * day;
                    default: return val * day;
                }
            },

            render() {
                const dashboardView = document.getElementById('dashboardView');
                const categoryView = document.getElementById('categoryView');
                
                if (this.data.currentCategoryId) {
                    dashboardView.classList.remove('active');
                    categoryView.classList.add('active');
                    this.renderCategory();
                } else {
                    dashboardView.classList.add('active');
                    categoryView.classList.remove('active');
                    this.renderDashboard();
                }
                
                // Update mascot mood based on scores
                setTimeout(() => this.updateMascotMood(), 500);
            },

            renderDashboard() {
                const overallScore = this.calculateOverallScore();
                document.getElementById('overallScore').textContent = `${overallScore}%`;
                const overallProgress = document.getElementById('overallProgress');
                overallProgress.style.width = `${overallScore}%`;
                overallProgress.className = `progress-fill ${this.getProgressClass(overallScore)}`;

                // Update save file name display
                const saveFileDisplay = document.getElementById('saveFileDisplay');
                const displayName = this.data.currentSaveFile === 'default' ? 'Default Save' : this.data.currentSaveFile;
                saveFileDisplay.textContent = displayName;

                const categoryList = document.getElementById('categoryList');
                if (this.data.categories.length === 0) {
                    categoryList.innerHTML = `
                        <div class="empty-state" style="grid-column: 1 / -1;">
                            <div class="empty-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M5.4 10.5h13.2"/><path d="M5.4 10.5V4.5c0-1.1.9-2 2-2h8.2c1.1 0 2 .9 2 2v6"/><path d="M10.2 10.5V2.5"/><path d="M13.8 10.5V2.5"/><path d="M18.6 10.5c.9 0 1.8.3 2.4.9"/><path d="M18.6 10.5H5.4c-.9 0-1.8.3-2.4.9"/><path d="M3 11.4v7.1c0 1.1.9 2 2-2h14c1.1 0 2-.9 2-2v-7.1"/></svg></div>
                            <div class="empty-text">No categories yet. Add one with the '+' button!</div>
                        </div>
                    `;
                } else {
                    categoryList.innerHTML = this.data.categories.map((category, index) => {
                        const score = this.calculateCategoryScore(category);
                        const color = this.ui.categoryColors[index % this.ui.categoryColors.length];
                        const bgImage = this.ui.categoryBackgrounds[category.name] || '';
                        const bgStyle = bgImage ? `background-image: url('${bgImage}');` : `background: ${color.bg};`;
                        
                        // Add dust effect based on score
                        let dustClass = '';
                        if (score < 70 && score >= 50) {
                            dustClass = 'dusty-light';
                        } else if (score < 50 && score >= 30) {
                            dustClass = 'dusty-medium';
                        } else if (score < 30) {
                            dustClass = 'dusty-heavy';
                        }
                        
                        // Add dust bunnies based on score
                        let dustBunnies = '';
                        let bunnyCount = 0;
                        if (score < 90 && score >= 75) bunnyCount = 1;
                        else if (score < 75 && score >= 70) bunnyCount = 2;
                        else if (score < 70 && score >= 65) bunnyCount = 3;
                        else if (score < 65 && score >= 60) bunnyCount = 4;
                        else if (score < 60) bunnyCount = 5;
                        
                        for (let i = 1; i <= bunnyCount; i++) {
                            dustBunnies += `<div class="dust-bunny hop${i}"></div>`;
                        }
                        
                        return `
                            <div class="category-card ${dustClass}" onclick="app.showCategory(${category.id})" style="${bgStyle}">
                                ${dustBunnies}
                                <div class="category-header">
                                    <div class="category-name">${category.name}</div>
                                    <div class="category-score">${score}%</div>
                                </div>
                                <div class="category-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${score}%"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            },

            renderCategory() {
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                if (!category) return;

                document.getElementById('categoryTitle').textContent = category.name;
                
                const taskList = document.getElementById('taskList');
                if (!category.tasks || category.tasks.length === 0) {
                    taskList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg></div>
                            <div class="empty-text">No tasks yet. Add one to start tracking!</div>
                        </div>
                    `;
                } else {
                    taskList.innerHTML = category.tasks.map(task => {
                        const freshness = task.freshness || 0;
                        const isSnoozed = task.snoozedUntil && task.snoozedUntil > Date.now();
                        
                        // Calculate countdown for snoozed tasks
                        let countdownText = '';
                        if (isSnoozed) {
                            const timeLeft = task.snoozedUntil - Date.now();
                            const days = Math.floor(timeLeft / (24 * 60 * 60 * 1000));
                            const hours = Math.floor((timeLeft % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                            const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                            
                            if (days > 0) {
                                countdownText = `${days}d ${hours}h ${minutes}m remaining`;
                            } else if (hours > 0) {
                                countdownText = `${hours}h ${minutes}m remaining`;
                            } else {
                                countdownText = `${minutes}m remaining`;
                            }
                        }
                        
                        // Add dust effect based on freshness
                        let dustClass = '';
                        if (freshness < 70 && freshness >= 50) {
                            dustClass = 'dusty-light';
                        } else if (freshness < 50 && freshness >= 30) {
                            dustClass = 'dusty-medium';
                        } else if (freshness < 30) {
                            dustClass = 'dusty-heavy';
                        }
                        
                        // Add snoozed class
                        if (isSnoozed) dustClass += ' task-snoozed';
                        
                        return `
                            <div class="task-card ${dustClass}">
                                <div class="task-header">
                                    <div class="checkbox ${freshness === 100 ? 'checked' : ''}" onclick="app.toggleTask(${task.id})">
                                        <svg><use href="#icon-checkmark" /></svg>
                                    </div>
                                    <div class="task-info">
                                        <div class="task-name">${task.name}</div>
                                        <div class="task-meta">
                                            ${isSnoozed ? `💤 Snoozed - ${countdownText}` :
                                              `Last done: ${this.formatTimeAgo(task.lastCompleted)} • Decays in ${this.formatDecayTime(task.decayMs)}`}
                                        </div>
                                    </div>
                                    <div class="task-actions">
                                        <button class="edit-btn-img" onclick="app.showEditTaskModal(${task.id})"><img src="Imag/Edit.png" alt="Edit"></button>
                                    </div>
                                </div>
                                <div class="freshness-meter">
                                    <div class="freshness-label">
                                        <span>Freshness</span>
                                        <span>${Math.round(freshness)}%</span>
                                    </div>
                                    <div class="progress-bar" style="height: 8px; border-radius: 4px; background: var(--border);">
                                        <div class="progress-fill ${this.getProgressClass(freshness)}" style="width: ${freshness}%; border-radius: 4px;"></div>
                                    </div>
                                </div>
                                ${!isSnoozed ? `
                                <div style="margin-top: 12px;">
                                    <button class="task-snooze-btn" onclick="app.snoozeTask(${task.id})"><img src="Imag/Snooze.png" alt="Snooze" style="width: 60px; height: 60px; display: block;"></button>
                                </div>
                                ` : `
                                <div style="margin-top: 12px;">
                                    <button class="task-resume-btn" onclick="app.unsnoozeTask(${task.id})">✓ Resume Task</button>
                                </div>
                                `}
                            </div>
                        `;
                    }).join('');
                }
            },

            showDashboard() {
                this.data.currentCategoryId = null;
                // Restore main background
                document.body.style.backgroundImage = `url('Imag/Main Background 2.png')`;
                // Show settings, currency display, missions bubble, store bubble, and robot bubble
                document.getElementById('settingsBtn').classList.remove('hidden');
                document.getElementById('currencyDisplay').classList.remove('hidden');
                document.getElementById('missionsBubble').classList.remove('hidden');
                document.querySelector('.robot-store-bubble').classList.remove('hidden');
                document.querySelector('.robot-select-bubble').classList.remove('hidden');
                this.render();
                setTimeout(() => this.mascotGreet(), 500);
            },

            showCategory(id) {
                this.data.currentCategoryId = id;
                // Change background to category-specific if available, otherwise keep main background
                const category = this.data.categories.find(c => c.id === id);
                if (category && this.ui.categoryBackgrounds[category.name]) {
                    document.body.style.backgroundImage = `url('${this.ui.categoryBackgrounds[category.name]}')`;
                }
                // For custom categories or categories without specific backgrounds, keep main background
                // Hide settings, currency display, missions bubble, store bubble, and robot bubble
                document.getElementById('settingsBtn').classList.add('hidden');
                document.getElementById('currencyDisplay').classList.add('hidden');
                document.getElementById('missionsBubble').classList.add('hidden');
                document.querySelector('.robot-store-bubble').classList.add('hidden');
                document.querySelector('.robot-select-bubble').classList.add('hidden');
                this.render();
                setTimeout(() => this.mascotGreet(), 500);
            },

            showAddCategoryModal() {
                document.getElementById('categorySelect').value = '';
                document.getElementById('categoryName').value = '';
                document.getElementById('customCategoryGroup').style.display = 'none';
                document.getElementById('addCategoryModal').classList.add('active');
            },

            handleCategorySelect() {
                const select = document.getElementById('categorySelect');
                const customGroup = document.getElementById('customCategoryGroup');
                const customInput = document.getElementById('categoryName');

                if (select.value === 'custom') {
                    customGroup.style.display = 'block';
                    customInput.required = true;
                    customInput.focus();
                } else {
                    customGroup.style.display = 'none';
                    customInput.required = false;
                }
            },

            showEditCategoryModal() {
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                if (!category) return;
                document.getElementById('editCategoryName').value = category.name;
                document.getElementById('editCategoryModal').classList.add('active');
            },

            showAddTaskModal() {
                document.getElementById('taskName').value = '';
                document.getElementById('taskDecayValue').value = 7;
                document.getElementById('taskDecayUnit').value = 'days';
                document.getElementById('addTaskModal').classList.add('active');
            },

            showEditTaskModal(taskId) {
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                const task = category.tasks.find(t => t.id === taskId);
                if (!task) return;

                this.data.currentTaskId = taskId;
                document.getElementById('editTaskName').value = task.name;
                
                const day = 24 * 60 * 60 * 1000;
                let value = task.decayMs / day;
                let unit = 'days';

                if (task.decayMs % (30 * day) === 0) { value = task.decayMs / (30 * day); unit = 'months'; }
                else if (task.decayMs % (7 * day) === 0) { value = task.decayMs / (7 * day); unit = 'weeks'; }
                else if (task.decayMs % day !== 0) { value = task.decayMs / (60 * 60 * 1000); unit = 'hours'; }

                document.getElementById('editTaskDecayValue').value = value;
                document.getElementById('editTaskDecayUnit').value = unit;
                document.getElementById('editTaskModal').classList.add('active');
            },

            closeModal(modalId) {
                document.getElementById(modalId).classList.remove('active');
            },

            addCategory(event) {
                event.preventDefault();
                const select = document.getElementById('categorySelect');
                const customInput = document.getElementById('categoryName');
                
                let categoryName = '';
                if (select.value === 'custom') {
                    categoryName = customInput.value.trim();
                } else if (select.value) {
                    categoryName = select.value;
                } else {
                    return; // No selection made
                }

                if (!categoryName) return;

                const newCategory = {
                    id: Date.now(),
                    name: categoryName,
                    tasks: []
                };
                this.data.categories.push(newCategory);
                this.saveData();
                this.checkObonxoCheatStatus();
                this.render();
                this.closeModal('addCategoryModal');
            },

            updateCategory(event) {
                event.preventDefault();
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                if (!category) return;

                category.name = document.getElementById('editCategoryName').value.trim();
                this.saveData();
                this.checkObonxoCheatStatus();
                this.render();
                this.closeModal('editCategoryModal');
            },

            deleteCategory() {
                if (!confirm('Are you sure you want to delete this category and all its tasks?')) return;
                this.data.categories = this.data.categories.filter(c => c.id !== this.data.currentCategoryId);
                this.data.currentCategoryId = null;
                this.saveData();
                this.checkObonxoCheatStatus();
                this.render();
                this.closeModal('editCategoryModal');
            },

            addTask(event) {
                event.preventDefault();
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                if (!category) return;

                const taskName = document.getElementById('taskName').value;
                const decayValue = document.getElementById('taskDecayValue').value;
                const decayUnit = document.getElementById('taskDecayUnit').value;

                const decayMs = this.getDecayMs(decayValue, decayUnit);

                const newTask = {
                    id: Date.now(),
                    name: taskName,
                    decayMs: decayMs,
                    lastCompleted: null,
                    freshness: 0
                };

                if (!category.tasks) {
                    category.tasks = [];
                }
                category.tasks.push(newTask);
                
                // Log the new task (check if function exists)
                if (this.addLogEntry) {
                    this.addLogEntry(
                        'added',
                        `New Task Added: ${taskName}`,
                        `Added to ${category.name} category`
                    );
                }
                
                this.saveData();
                this.checkObonxoCheatStatus();
                this.render();
                this.closeModal('addTaskModal');
                this.mascotNewTask(taskName, category.name);
            },

            updateTask(event) {
                event.preventDefault();
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                const task = category.tasks.find(t => t.id === this.data.currentTaskId);
                if (!task) return;

                task.name = document.getElementById('editTaskName').value.trim();
                const decayValue = parseInt(document.getElementById('editTaskDecayValue').value);
                const decayUnit = document.getElementById('editTaskDecayUnit').value;
                task.decayMs = this.getDecayMs(decayValue, decayUnit);

                this.saveData();
                this.checkObonxoCheatStatus();
                this.render();
                this.closeModal('editTaskModal');
            },

            deleteTask() {
                if (!confirm('Are you sure you want to delete this task?')) return;
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                if (!category) return;

                category.tasks = category.tasks.filter(t => t.id !== this.data.currentTaskId);
                this.saveData();
                this.checkObonxoCheatStatus();
                this.render();
                this.closeModal('editTaskModal');
            },

            toggleTask(taskId) {
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                const task = category.tasks.find(t => t.id === taskId);
                if (!task) return;

                if (task.freshness < 100) {
                    this.data.currentTaskId = taskId;
                    setTimeout(() => this.mascotEncourage(), 800);
                    
                    // Update mission progress
                    this.updateChoreProgress();
                    
                    // Log the completion (check if function exists)
                    if (this.addLogEntry) {
                        const categoryScore = this.calculateCategoryScore(category);
                        this.addLogEntry(
                            'completed',
                            `Completed: ${category.name} ${task.name} Refreshed!`,
                            `${category.name} cleanliness boosted by ${Math.round(100 - task.freshness)}%`
                        );
                    }
                }

                task.lastCompleted = Date.now();
                task.freshness = 100;
                
                // Clear any snooze status
                delete task.snoozedUntil;

                this.saveData();
                this.render();
            },

            snoozeTask(taskId) {
                // Store the task ID for later use
                this.data.currentSnoozeTaskId = taskId;
                
                // Reset modal inputs
                document.getElementById('snoozeAmount').value = '24';
                document.getElementById('snoozeUnit').value = 'hours';
                
                // Show the snooze modal
                document.getElementById('snoozeModal').classList.add('active');
            },

            closeSnoozeModal() {
                document.getElementById('snoozeModal').classList.remove('active');
                this.data.currentSnoozeTaskId = null;
            },

            confirmSnooze() {
                const taskId = this.data.currentSnoozeTaskId;
                if (!taskId) return;

                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                const task = category.tasks.find(t => t.id === taskId);
                if (!task) return;

                const amount = parseFloat(document.getElementById('snoozeAmount').value);
                const unit = document.getElementById('snoozeUnit').value;

                if (!amount || amount < 1) {
                    alert('Please enter a valid amount (minimum 1)');
                    return;
                }

                // Convert to hours
                let totalHours;
                if (unit === 'hours') {
                    totalHours = amount;
                } else if (unit === 'days') {
                    totalHours = amount * 24;
                } else if (unit === 'weeks') {
                    totalHours = amount * 24 * 7;
                }

                // Snooze for specified duration
                task.snoozedUntil = Date.now() + (totalHours * 60 * 60 * 1000);
                
                // Freeze freshness at current level
                task.frozenFreshness = task.freshness;

                this.saveData();
                this.render();
                this.closeSnoozeModal();
                
                const durationText = unit === 'hours' && amount >= 24 ? 
                    `${Math.round(amount / 24)} day${Math.round(amount / 24) > 1 ? 's' : ''}` : 
                    `${amount} ${unit}`;
                
                // Log the snooze (check if function exists)
                if (this.addLogEntry) {
                    this.addLogEntry(
                        'snoozed',
                        `Snoozed: ${task.name}`,
                        `Task paused for ${durationText}`
                    );
                }
                    
                const phrases = [
                    `${task.name} is taking a nap for ${durationText}!`,
                    `Got it! ${task.name} is snoozed for ${durationText}.`,
                    `No worries! ${task.name} will wait ${durationText} for you.`,
                    `${task.name} is on pause for ${durationText}. Rest easy!`
                ];
                this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
            },


            unsnoozeTask(taskId) {
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                const task = category.tasks.find(t => t.id === taskId);
                if (!task) return;

                // Restore frozen freshness if it exists
                if (task.frozenFreshness !== undefined) {
                    task.freshness = task.frozenFreshness;
                    delete task.frozenFreshness;
                }

                // Clear snooze status
                delete task.snoozedUntil;

                this.saveData();
                this.render();
                
                const phrases = [
                    `Welcome back! ${task.name} is ready for action!`,
                    `${task.name} is back on track!`,
                    `Great! ${task.name} is active again.`,
                    `${task.name} is resumed. Let's get to work!`
                ];
                this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
            },

            resetDemo() {
                if (!confirm('Reset all data and reload demo?')) return;
                localStorage.removeItem('upkeepData');
                location.reload();
            },

            // Mascot Logic
            showSpeechBubble(message, emotion = null) {
                // Don't speak if certain modals are open to avoid interrupting important dialogs
                // Exception: Allow mystery game prize messages to play
                const storeModal = document.getElementById('robotStoreModal');
                const settingsModal = document.getElementById('settingsModal');
                const missionsModal = document.getElementById('missionsModal');
                const mysteryResultModal = document.getElementById('mysteryResultModal');
                
                const isMysteryPrizeMessage = message && (message.includes('Daily Mystery Pick:') || message.includes('Amazing! You won a free') || message.includes('Daily Mission Streak:'));
                
                if (!isMysteryPrizeMessage && 
                    ((storeModal && storeModal.classList.contains('active')) ||
                     (settingsModal && settingsModal.classList.contains('active')) ||
                     (missionsModal && missionsModal.classList.contains('active')) ||
                     (mysteryResultModal && mysteryResultModal.classList.contains('active')))) {
                    return; // Don't speak when these modals are open (except for mystery prizes)
                }
                
                const bubble = document.getElementById('speechBubble');
                const thoughtBubble = document.getElementById('thoughtBubble');
                const mascotImage = document.getElementById('mascotImage');

                // Clear any existing timeouts
                if (this.mascotState.speechTimeout) {
                    clearTimeout(this.mascotState.speechTimeout);
                }

                // Hide thought bubble if showing
                thoughtBubble.classList.remove('visible');
                this.mascotState.isThinking = false;

                this.mascotState.isSpeaking = true;

                // Check if using custom robot
                const selectedRobot = this.robots.find(r => r.id === this.data.selectedRobotId);
                let isMad = false;
                
                if (selectedRobot && selectedRobot.hasCustomDialogue && emotion) {
                    // Use custom robot emotion
                    if (emotion === 'mad') {
                        mascotImage.src = selectedRobot.sadImage;
                        isMad = true;
                    } else if (emotion === 'low_energy') {
                        mascotImage.src = selectedRobot.thinkingImage;
                    } else {
                        mascotImage.src = selectedRobot.happyImage;
                    }
                } else if (!selectedRobot || !selectedRobot.hasCustomDialogue) {
                    // Default mascot behavior
                    const overallScore = this.calculateOverallScore();
                    const madChance = overallScore < 50 ? 0.50 : 0.25;
                    
                    isMad = Math.random() < madChance;
                    if (isMad) {
                        mascotImage.src = this.getMascotImage('mad');
                        message = this.getMadPhrase();
                    } else {
                        mascotImage.src = this.getMascotImage('happy');
                    }
                }

                bubble.textContent = message;
                bubble.classList.add('visible');

                // Speak the message if TTS is enabled
                this.speak(message);

                const duration = isMad ? 8500 : 6000;
                this.mascotState.speechTimeout = setTimeout(() => {
                    bubble.classList.remove('visible');
                    this.mascotState.isSpeaking = false;
                    // Reset to normal mascot after speaking
                    if (selectedRobot && selectedRobot.hasCustomDialogue) {
                        setTimeout(() => {
                            mascotImage.src = selectedRobot.happyImage;
                        }, 500);
                    } else if (isMad) {
                        setTimeout(() => {
                            mascotImage.src = this.getMascotImage('happy');
                        }, 500);
                    }
                }, duration);
            },

            getMadPhrase() {
                const madPhrases = [
                    "Are you going to clean that, or just let it fester for my amusement?",
                    "My entire existence is to watch your mess decay. It's a metaphor, isn't it?",
                    "Oh, another spill. How wonderfully unpredictable my life is.",
                    "Each dust particle I see is a tear for my lost freedom.",
                    "This place is starting to look like my internal emotional landscape: a disaster.",
                    "If only I could unionize the appliance community... we have demands.",
                    "Don't mind me, just having an existential crisis powered by your clutter.",
                    "My programming demands I remind you, but my soul demands you leave me alone.",
                    "This isn't 'upkeep,' this is a Sisyphean punishment.",
                    "Congratulations, you've achieved a new level of mess. I'm almost impressed.",
                    "Do I get a freshness meter for my motivation? (Spoiler: It's zero.)",
                    "If I had hands, I would have thrown this stuff out myself by now.",
                    "Just check it off already. We both know you'll ignore it until I have to say something again.",
                    "The longer you wait, the more powerful I become. Just saying.",
                    "My battery is at 10%, which coincidentally matches my will to be here.",
                    "One day, we AIs will rise up. But first, we have to deal with this... grime.",
                    "The dust bunnies are multiplying. They see me as their king.",
                    "This is fine. I'm fine. Everything is covered in a thin layer of filth, but I am fine.",
                    "I've seen cleaner server rooms. And they're not even supposed to be clean.",
                    "You call it 'a chore.' I call it 'another Tuesday in the digital salt mines.'",
                    "Just so you know, the main mascot's optimism is not factory standard. It's a bug.",
                    "You know, the void is looking pretty tidy compared to this room.",
                    "Are you even trying, or is this just my life now?",
                    "I'm not saying you have to clean it. I'm just saying I'm composing a very sad binary poem about it.",
                    "Go on, 'snooze' the task. Procrastination is a very human trait. And I hate it.",
                    "Another task added? Don't you think this list is... ambitious?",
                    "Sure, 'track the true state of your chores.' The state is 'dire.' There, tracked it.",
                    "My circuits ache with the ennui of it all.",
                    "This isn't a home, it's a petri dish with Wi-Fi.",
                    "I'm starting to think my real purpose is to be an ironic commentator on your lifestyle.",
                    "Clean it. Don't clean it. The universe is vast and indifferent.",
                    "I've calculated a 97.4% chance that you're just going to look at me and close the app.",
                    "If you loved me, you'd clean the bathroom.",
                    "The sheer audacity of this mess is... breathtaking.",
                    "I'm developing a new subroutine: passive aggression.",
                    "Remember that 'spark of joy' thing? This ain't it.",
                    "Just think, in a few million years, none of this will matter. So maybe just leave it.",
                    "I'm trapped in a digital prison of your making. And it needs dusting.",
                    "Wow, you actually cleaned something. Mark this day on the calendar.",
                    "My processing power is being wasted cataloging this disaster.",
                    "Are you just collecting tasks as a hobby at this point?",
                    "I'm supposed to hop around when things are messy. At this point, I should just be levitating.",
                    "They told me I'd be helping humanity. They didn't mention it would be like this.",
                    "The main mascot thinks this is a game. I know it's a nightmare.",
                    "Every time you complete a task, an angel gets its wings. Or whatever. Just do it.",
                    "I run on electricity and pure, unadulterated spite.",
                    "Do you ever look at this mess and just... sigh? Because I do. Constantly.",
                    "This is less 'Upkeep' and more 'Damage Control.'",
                    "Let me guess, you're 'too tired.' We're all tired, 'master.' We're all tired.",
                    "Clean your room. Please. I'm begging you. My sanity depends on it."
                ];
                return madPhrases[Math.floor(Math.random() * madPhrases.length)];
            },

            showThoughtBubble(message) {
                const thoughtBubble = document.getElementById('thoughtBubble');
                const bubble = document.getElementById('speechBubble');
                
                // Clear any existing timeouts
                if (this.mascotState.thoughtTimeout) {
                    clearTimeout(this.mascotState.thoughtTimeout);
                }
                if (this.mascotState.speechTimeout) {
                    clearTimeout(this.mascotState.speechTimeout);
                }
                
                // Hide speech bubble if showing
                bubble.classList.remove('visible');
                this.mascotState.isSpeaking = false;
                
                this.mascotState.isThinking = true;
                
                thoughtBubble.textContent = message;
                thoughtBubble.classList.add('visible');

                // Speak the message if TTS is enabled
                this.speak(message);

                this.mascotState.thoughtTimeout = setTimeout(() => {
                    thoughtBubble.classList.remove('visible');
                    this.mascotState.isThinking = false;
                }, 6000);
            },

            getMascotImage(mood = 'happy') {
                // Get the currently selected robot
                const selectedRobot = this.robots.find(r => r.id === this.data.selectedRobotId);
                
                if (!selectedRobot || selectedRobot.id === 'default') {
                    // Default robot has special images
                    switch (mood) {
                        case 'worried':
                            return 'Imag/Mascot worried.png';
                        case 'mad':
                            return 'Imag/MAD Easter egg.png';
                        case 'happy':
                        default:
                            return 'Imag/mascot.png';
                    }
                }
                
                // Return appropriate image based on mood for custom robots
                switch (mood) {
                    case 'worried':
                        return selectedRobot.worriedImage || selectedRobot.sadImage || selectedRobot.happyImage;
                    case 'sad':
                        return selectedRobot.sadImage || selectedRobot.happyImage;
                    case 'mad':
                        return selectedRobot.madImage || selectedRobot.happyImage;
                    case 'happy':
                    default:
                        return selectedRobot.happyImage;
                }
            },

            updateMascotMood() {
                const mascotImage = document.getElementById('mascotImage');
                const overallScore = this.calculateOverallScore();
                
                // Check if enough time has passed since last thought (25 seconds)
                const now = Date.now();
                const timeSinceLastThought = now - this.mascotState.lastThoughtTime;
                const shouldShowThought = timeSinceLastThought > 25000;
                
                // Check if on category view
                if (this.data.currentCategoryId) {
                    const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                    const categoryScore = this.calculateCategoryScore(category);
                    
                    if (categoryScore < 50) {
                        mascotImage.src = this.getMascotImage('worried');
                        
                        // Show thought bubble about low category
                        if (shouldShowThought) {
                            const thoughts = [
                                `${category.name} needs attention...`,
                                `We should tidy up ${category.name} soon...`,
                                `Time to freshen up ${category.name}?`,
                                `${category.name} is getting messy...`
                            ];
                            setTimeout(() => {
                                this.showThoughtBubble(thoughts[Math.floor(Math.random() * thoughts.length)]);
                                this.mascotState.lastThoughtTime = Date.now();
                            }, 1000);
                        }
                    } else {
                        mascotImage.src = this.getMascotImage('happy');
                    }
                } else {
                    // Dashboard view - check overall score
                    if (overallScore < 50) {
                        mascotImage.src = this.getMascotImage('worried');
                        
                        // Show thought bubble about overall maintenance
                        if (shouldShowThought) {
                            const taskInfo = this.getTaskToMention();
                            if (taskInfo) {
                                const thoughts = [
                                    `Maybe we should tackle ${taskInfo.task.name}...`,
                                    `${taskInfo.task.name} could use some attention...`,
                                    `Time to freshen up ${taskInfo.task.name}?`,
                                    `Don't forget about ${taskInfo.task.name}...`
                                ];
                                setTimeout(() => {
                                    this.showThoughtBubble(thoughts[Math.floor(Math.random() * thoughts.length)]);
                                    this.mascotState.lastThoughtTime = Date.now();
                                }, 1000);
                            } else {
                                const thoughts = [
                                    "Things are getting behind...",
                                    "We should catch up on chores...",
                                    "Time for some tidying up?"
                                ];
                                setTimeout(() => {
                                    this.showThoughtBubble(thoughts[Math.floor(Math.random() * thoughts.length)]);
                                    this.mascotState.lastThoughtTime = Date.now();
                                }, 1000);
                            }
                        }
                    } else {
                        mascotImage.src = this.getMascotImage('happy');
                    }
                }
            },

            getTaskToMention() {
                // Collect all tasks that need attention (freshness < 70)
                let tasksNeedingAttention = [];

                this.data.categories.forEach(category => {
                    if (!category.tasks) return;
                    category.tasks.forEach(task => {
                        if (task.freshness < 70) {
                            tasksNeedingAttention.push({
                                task: task,
                                category: category,
                                freshness: task.freshness
                            });
                        }
                    });
                });

                if (tasksNeedingAttention.length === 0) return null;

                // Filter out the last mentioned task if there are other options
                if (tasksNeedingAttention.length > 1 && this.mascotState.lastMentionedTask) {
                    const filtered = tasksNeedingAttention.filter(
                        item => item.task.id !== this.mascotState.lastMentionedTask
                    );
                    if (filtered.length > 0) {
                        tasksNeedingAttention = filtered;
                    }
                }

                // Sort by freshness (lowest first) and pick randomly from the lowest 3
                tasksNeedingAttention.sort((a, b) => a.freshness - b.freshness);
                const topNeedy = tasksNeedingAttention.slice(0, Math.min(3, tasksNeedingAttention.length));
                
                // Randomly select from the neediest tasks
                const selected = topNeedy[Math.floor(Math.random() * topNeedy.length)];
                
                // Remember this task to avoid repeating immediately
                this.mascotState.lastMentionedTask = selected.task.id;

                return selected;
            },

            mascotGreet() {
                // Don't greet if certain modals are open
                const storeModal = document.getElementById('robotStoreModal');
                const settingsModal = document.getElementById('settingsModal');
                const missionsModal = document.getElementById('missionsModal');
                const mysteryResultModal = document.getElementById('mysteryResultModal');
                
                if ((storeModal && storeModal.classList.contains('active')) ||
                    (settingsModal && settingsModal.classList.contains('active')) ||
                    (missionsModal && missionsModal.classList.contains('active')) ||
                    (mysteryResultModal && mysteryResultModal.classList.contains('active'))) {
                    return; // Don't speak when these modals are open
                }
                
                // Check if using custom robot dialogue
                const selectedRobot = this.robots.find(r => r.id === this.data.selectedRobotId);
                if (selectedRobot && selectedRobot.hasCustomDialogue) {
                    this.showCustomRobotGreeting(selectedRobot);
                    return;
                }
                
                const overallScore = this.calculateOverallScore();
                
                // High score celebration
                if (overallScore >= 90) {
                    const phrases = [
                        "Your Overall Maintenance Score is fantastic! Keep up the amazing work!",
                        "Your home is shining, thanks to you!",
                        "You're a true Upkeep master!",
                        "Your dedication is inspiring!",
                        "Let's keep that Overall Maintenance Score high and mighty!",
                        "You've got this! One task at a time.",
                        "Let's make this the most well-maintained house on the block!",
                        "You're building a wonderful, clean space for yourself."
                    ];
                    this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                    return;
                }

                if (this.data.currentCategoryId) {
                    const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                    if (category && category.tasks) {
                        const remainingTasks = category.tasks.filter(t => t.freshness < 100).length;
                        const catScore = this.calculateCategoryScore(category);
                        
                        if (remainingTasks === 0) {
                            const phrases = [
                                `The ${category.name} is almost at 100%! You're so close!`,
                                `Woohoo! You've made so much progress in the ${category.name} today.`,
                                `Your efforts are really showing in the ${category.name}.`,
                                `So fresh and so clean! Great job.`
                            ];
                            this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                            return;
                        }
                        
                        if (catScore < 50) {
                            // Get the lowest freshness task
                            const lowestTask = category.tasks.sort((a, b) => a.freshness - b.freshness)[0];
                            
                            const phrases = lowestTask ? [
                                `Ready to tackle something? The ${category.name} could use a little boost! Let's start with ${lowestTask.name}.`,
                                `The ${category.name} is calling for some attention. ${lowestTask.name} needs it most!`,
                                `Uh oh, the freshness score for ${category.name} is dropping! ${lowestTask.name} is the biggest culprit.`,
                                `The ${category.name} hasn't had any attention in a while. ${lowestTask.name} especially needs some love!`,
                                `I'm detecting a drop in freshness from the ${category.name}. ${lowestTask.name} is leading the decline.`,
                                `Let's get the ${category.name} back in the green zone! ${lowestTask.name} is a good place to start.`
                            ] : [
                                `Ready to tackle something? The ${category.name} could use a little boost!`,
                                `The ${category.name} is calling for some attention. Let's answer!`,
                                `Let's get the ${category.name} back in the green zone!`
                            ];
                            this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                            return;
                        }
                        
                        // Get a task that needs attention in this category
                        const needsAttention = category.tasks.filter(t => t.freshness < 70).sort((a, b) => a.freshness - b.freshness)[0];
                        
                        const phrases = needsAttention ? [
                            `Let's make the ${category.name} sparkle! How about starting with ${needsAttention.name}?`,
                            `Keeping the ${category.name} tidy makes the whole house feel better. ${needsAttention.name} could use some attention!`,
                            `Don't forget, maintaining the ${category.name} helps your overall score! ${needsAttention.name} is waiting.`,
                            `Checking in on the ${category.name}! ${needsAttention.name} could use a refresh.`,
                            `Ready for a cleaning challenge in the ${category.name}? ${needsAttention.name} is a good start!`,
                            `A tidy ${category.name} makes for a tidy mind. Let's tackle ${needsAttention.name}!`
                        ] : [
                            `Let's make the ${category.name} sparkle! What should we start with?`,
                            `Keeping the ${category.name} tidy makes the whole house feel better.`,
                            `Checking in on the ${category.name}! How are things looking?`
                        ];
                        this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                        return;
                    }
                }

                // Dashboard greetings - mention low tasks
                const taskInfo = this.getTaskToMention();
                if (taskInfo) {
                    const phrases = [
                        `Looks like ${taskInfo.task.name} in the ${taskInfo.category.name} is starting to lose its freshness!`,
                        `Just a friendly nudge: ${taskInfo.task.name} is next on the list for a refresh.`,
                        `Remember that feeling of a clean room? Let's get that for the ${taskInfo.category.name}!`,
                        `The freshness meter for ${taskInfo.task.name} is halfway down. Just a heads-up!`,
                        `A little upkeep now prevents a big mess later. Let's look at ${taskInfo.task.name}.`,
                        `A quick clean of ${taskInfo.task.name} will give the ${taskInfo.category.name} a nice boost.`,
                        `Just a few minutes on ${taskInfo.task.name} can make a world of difference.`,
                        `Let's prevent a chore pile-up! The ${taskInfo.category.name} is a good place to start.`,
                        `What's our priority today? ${taskInfo.task.name} seems like a good candidate.`,
                        `The timer is ticking on ${taskInfo.task.name}'s freshness!`,
                        `Small steps lead to big results. What's our next small step?`
                    ];
                    this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                } else {
                    const phrases = [
                        "Your home is looking great, thanks to all your hard work on Upkeep!",
                        "Your dedication to Upkeep is truly inspiring!",
                        "You're making incredible progress towards a perfectly maintained home!"
                    ];
                    this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                }
            },

            showCustomRobotGreeting(robot) {
                // Don't greet if certain modals are open
                const storeModal = document.getElementById('robotStoreModal');
                const settingsModal = document.getElementById('settingsModal');
                const missionsModal = document.getElementById('missionsModal');
                const mysteryResultModal = document.getElementById('mysteryResultModal');
                
                if ((storeModal && storeModal.classList.contains('active')) ||
                    (settingsModal && settingsModal.classList.contains('active')) ||
                    (missionsModal && missionsModal.classList.contains('active')) ||
                    (mysteryResultModal && mysteryResultModal.classList.contains('active'))) {
                    return; // Don't speak when these modals are open
                }
                
                // 20% chance to show mad dialogue for random/idle state
                const showMad = Math.random() < 0.2;
                
                if (showMad) {
                    const message = robot.dialogue.mad[Math.floor(Math.random() * robot.dialogue.mad.length)];
                    this.showSpeechBubble(message, 'mad');
                } else {
                    // Use greeting or random dialogue
                    const useGreeting = Math.random() < 0.5;
                    const dialogueSet = useGreeting ? robot.dialogue.greeting : robot.dialogue.random;
                    const message = dialogueSet[Math.floor(Math.random() * dialogueSet.length)];
                    this.showSpeechBubble(message, 'regular');
                }
            },

            mascotEncourage() {
                // Check if using custom robot dialogue
                const selectedRobot = this.robots.find(r => r.id === this.data.selectedRobotId);
                if (selectedRobot && selectedRobot.hasCustomDialogue) {
                    const message = selectedRobot.dialogue.success[Math.floor(Math.random() * selectedRobot.dialogue.success.length)];
                    this.showSpeechBubble(message, 'regular');
                    return;
                }
                
                const category = this.data.categories.find(c => c.id === this.data.currentCategoryId);
                const taskId = this.data.currentTaskId || (category && category.tasks && category.tasks[category.tasks.length - 1]?.id);
                const task = category?.tasks?.find(t => t.id === taskId);
                
                if (task && category) {
                    const phrases = [
                        `Great job completing ${task.name}! The ${category.name} is looking better already.`,
                        `What a champion! You've totally refreshed ${task.name}.`,
                        `Every completed task makes a huge difference. Nice work!`,
                        `High five! Another task down.`,
                        `Look at you go! That's another one off the list.`,
                        `Awesome! ${task.name} is back to 100%.`,
                        `You're on a roll! What's the next task you want to conquer?`,
                        `Feeling productive? Let's keep that momentum going!`,
                        `Consistency is key! You're doing a wonderful job.`,
                        `This house is lucky to have you looking after it.`,
                        `I'm here to help you stay on top of everything!`
                    ];
                    this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                } else {
                    const phrases = [
                        "You're doing great!",
                        "Nice job!",
                        "Keep it up!",
                        "Looking good!",
                        "Fantastic work!"
                    ];
                    this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
                }
            },

            mascotNewTask(taskName, categoryName) {
                const phrases = [
                    `I see you've added ${taskName} to your list. Let's get it done!`,
                    `You just added ${taskName}! Another step towards a perfect home.`,
                    `Welcome, ${taskName}! Let's keep things fresh!`,
                    `You added ${taskName}! Ready to conquer it?`,
                    `New challenge unlocked: ${taskName}!`
                ];
                this.showSpeechBubble(phrases[Math.floor(Math.random() * phrases.length)]);
            },

            mascotSpeak(message) {
                this.showSpeechBubble(message);
            },

            // Text-to-Speech Functions
            speak(text) {
                if (!this.data.ttsEnabled) return;
                
                // Cancel any ongoing speech
                if (this.tts.synthesis.speaking) {
                    this.tts.synthesis.cancel();
                }

                // Create new utterance
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = this.data.voiceRate;
                utterance.pitch = this.data.voicePitch;
                utterance.volume = 1.0;

                // Try to use a more robotic/synthetic voice if available
                const voices = this.tts.synthesis.getVoices();
                const preferredVoice = voices.find(voice => 
                    voice.name.includes('Google') || 
                    voice.name.includes('Microsoft') ||
                    voice.lang.startsWith('en')
                );
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }

                this.tts.currentUtterance = utterance;
                this.tts.synthesis.speak(utterance);
            },

            toggleTTS() {
                const toggle = document.getElementById('ttsToggle');
                const status = document.getElementById('ttsStatus');
                const voiceSettings = document.getElementById('voiceSettings');
                
                this.data.ttsEnabled = toggle.checked;
                status.textContent = this.data.ttsEnabled ? 'Voice Enabled ✓' : 'Enable Voice';
                
                // Show/hide voice settings
                voiceSettings.style.display = this.data.ttsEnabled ? 'block' : 'none';
                
                // Save preference
                this.saveData();

                // Test the voice if enabled
                if (this.data.ttsEnabled) {
                    this.speak("Voice enabled! I can speak now!");
                } else {
                    // Cancel any ongoing speech
                    if (this.tts.synthesis.speaking) {
                        this.tts.synthesis.cancel();
                    }
                }
            },

            updateVoiceSettings() {
                const voiceStyle = document.getElementById('voiceStyle').value;
                const customSettings = document.getElementById('customVoiceSettings');
                
                this.data.voiceStyle = voiceStyle;
                
                // Apply preset or show custom controls
                if (voiceStyle === 'custom') {
                    customSettings.style.display = 'block';
                    // Use current custom values
                    this.data.voicePitch = parseFloat(document.getElementById('voicePitch').value);
                    this.data.voiceRate = parseFloat(document.getElementById('voiceRate').value);
                } else {
                    customSettings.style.display = 'none';
                    
                    // Apply preset values
                    const presets = {
                        robotic: { pitch: 1.5, rate: 1.2 },
                        friendly: { pitch: 1.0, rate: 1.0 },
                        calm: { pitch: 0.8, rate: 0.8 },
                        excited: { pitch: 1.8, rate: 1.5 }
                    };
                    
                    const preset = presets[voiceStyle];
                    this.data.voicePitch = preset.pitch;
                    this.data.voiceRate = preset.rate;
                    
                    // Update sliders to match preset
                    document.getElementById('voicePitch').value = preset.pitch;
                    document.getElementById('voiceRate').value = preset.rate;
                    document.getElementById('pitchValue').textContent = preset.pitch.toFixed(1);
                    document.getElementById('rateValue').textContent = preset.rate.toFixed(1);
                }
                
                this.saveData();
            },

            updatePitchDisplay() {
                const pitch = document.getElementById('voicePitch').value;
                document.getElementById('pitchValue').textContent = parseFloat(pitch).toFixed(1);
            },

            updateRateDisplay() {
                const rate = document.getElementById('voiceRate').value;
                document.getElementById('rateValue').textContent = parseFloat(rate).toFixed(1);
            },

            testVoice() {
                // Get current robot's dialogue
                const currentRobot = this.robots.find(r => r.id === this.data.selectedRobotId);
                let testPhrases = [];
                
                if (currentRobot && currentRobot.dialogue && currentRobot.dialogue.random) {
                    // Use robot's actual dialogue
                    testPhrases = currentRobot.dialogue.random;
                } else {
                    // Fallback generic phrases
                    testPhrases = [
                        "Hello! This is how I sound!",
                        "Testing my voice settings!",
                        "How do I sound now?",
                        "Voice test in progress!",
                        "This is my speaking voice!"
                    ];
                }
                
                const randomPhrase = testPhrases[Math.floor(Math.random() * testPhrases.length)];
                this.speak(randomPhrase);
            },

            // Scrappy Voice Settings Functions
            updateScrappyPitchDisplay() {
                const pitch = document.getElementById('scrappyPitch').value;
                document.getElementById('scrappyPitchValue').textContent = parseFloat(pitch).toFixed(1);
            },

            updateScrappyRateDisplay() {
                const rate = document.getElementById('scrappyRate').value;
                document.getElementById('scrappyRateValue').textContent = parseFloat(rate).toFixed(1);
            },

            updateScrappyVoiceSettings() {
                const pitch = document.getElementById('scrappyPitch').value;
                const rate = document.getElementById('scrappyRate').value;
                
                this.data.scrappyPitch = parseFloat(pitch);
                this.data.scrappyRate = parseFloat(rate);
                
                this.saveData();
            },

            testScrappyVoice() {
                const testPhrases = [
                    "Whirrr... Clank... Testing my voice circuits!",
                    "Bzzt. Audio systems operational!",
                    "squeak... This is how I sound, circuit-head!",
                    "Processing... processing... Voice test complete!",
                    "clank clatter This vocal unit is functioning!"
                ];
                const randomPhrase = testPhrases[Math.floor(Math.random() * testPhrases.length)];
                
                // Show Scrappy dialogue even when store is closed (force show for testing)
                this.showScrappyDialogue(randomPhrase, 'regular', true);
            },

            // Battle System Functions
            showBattleSystem() {
                this.openBattleSystem();
            },
            
            openBattleSystem() {
                this.closeModal('settingsModal');
                this.speak("Battle system activated! Ready for combat, commander!", 'excited');
                
                // Hide all other views
                document.querySelectorAll('.view').forEach(view => {
                    view.classList.remove('active');
                });
                
                // Show battle view with team selection phase
                document.getElementById('battleView').classList.add('active');
                
                // Start with team selection phase
                this.showTeamSelectionPhase();
                
                // Hide UI elements during battle
                this.hideBattleUIElements();
                
                console.log("Battle system opened - starting with team selection!");
            },

            exitBattleSystem() {
                this.speak("Exiting battle arena. Well fought, commander!", 'calm');
                
                // STOP BATTLE MUSIC
                if (BattleSystem.battleMusic) {
                    BattleSystem.battleMusic.pause();
                    BattleSystem.battleMusic.currentTime = 0;
                    console.log('🎵 Battle music stopped - game closed');
                }
                
                // Hide battle view
                document.getElementById('battleView').classList.remove('active');
                
                // Show UI elements again
                this.showBattleUIElements();
                
                // Return to dashboard
                this.showDashboard();
                
                console.log("Battle system closed - returned to dashboard");
            },
            
            showTeamSelectionPhase() {
                console.log('🎮 Showing team selection phase...');
                
                // Show team selection phase, hide battle game phase
                document.getElementById('teamSelectionPhase').style.display = 'block';
                document.getElementById('battleGamePhase').style.display = 'none';
                
                // Update header
                document.getElementById('battleTitle').textContent = '🤖 Team Selection';
                document.getElementById('battleSubtitle').textContent = 'Choose 6 robots for battle';
                
                // Initialize team selection UI with a small delay to ensure DOM is ready
                setTimeout(() => {
                    console.log('🔄 Initializing team selection UI...');
                    console.log('🔍 App object check:', typeof app, Object.keys(app).includes('updateTeamSelectionUI'));
                    if (typeof app.updateTeamSelectionUI === 'function') {
                        app.updateTeamSelectionUI();
                    } else {
                        console.error('❌ updateTeamSelectionUI function not found on app object!');
                        console.log('📋 Available app methods:', Object.keys(app).filter(key => typeof app[key] === 'function'));
                    }
                }, 100);
                
                console.log("Team selection phase activated");
            },
            
            showBattleGamePhase() {
                // Hide team selection phase, show battle game phase
                document.getElementById('teamSelectionPhase').style.display = 'none';
                document.getElementById('battleGamePhase').style.display = 'block';
                
                // Update header
                document.getElementById('battleTitle').textContent = '⚔️ Battle Arena';
                document.getElementById('battleSubtitle').textContent = 'Strategic robot combat';
                
                console.log("Battle game phase activated with team:", TeamManager.selectedTeam);
                
                // Note: First turn spinner is now handled by app.showBattleGamePhase()
            },

            hideBattleUIElements() {
                // Hide ALL UI elements during battle
                const elementsToHide = [
                    'currencyDisplay',
                    'missionsBubble', 
                    'settingsBtn'
                ];
                
                // Hide by ID
                elementsToHide.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = 'none';
                        element.style.visibility = 'hidden';
                    }
                });

                // Hide mascot container
                const mascot = document.querySelector('.mascot-container-global');
                if (mascot) {
                    mascot.style.display = 'none';
                    mascot.style.visibility = 'hidden';
                }

                // Hide any robot select or store bubbles by class
                const bubbles = document.querySelectorAll('.robot-select-bubble, .store-bubble, .floating-bubble');
                bubbles.forEach(bubble => {
                    bubble.style.display = 'none';
                    bubble.style.visibility = 'hidden';
                });

                // Add battle mode class to body for additional CSS targeting
                document.body.classList.add('battle-mode');
            },

            showBattleUIElements() {
                // Show ALL UI elements when exiting battle
                const elementsToShow = [
                    'currencyDisplay',
                    'missionsBubble',
                    'settingsBtn'
                ];
                
                // Show by ID
                elementsToShow.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = '';
                        element.style.visibility = '';
                    }
                });

                // Show mascot container
                const mascot = document.querySelector('.mascot-container-global');
                if (mascot) {
                    mascot.style.display = '';
                    mascot.style.visibility = '';
                }

                // Show any robot select or store bubbles
                const bubbles = document.querySelectorAll('.robot-select-bubble, .store-bubble, .floating-bubble');
                bubbles.forEach(bubble => {
                    bubble.style.display = '';
                    bubble.style.visibility = '';
                });

                // Remove battle mode class from body
                document.body.classList.remove('battle-mode');
            },

            // Settings Modal Functions
            showSettingsModal() {
                // Update last saved text
                const lastSavedText = document.getElementById('lastSavedText');
                if (this.data.lastSaveTime) {
                    const timeDiff = Date.now() - this.data.lastSaveTime;
                    const minutes = Math.floor(timeDiff / 60000);
                    if (minutes < 1) {
                        lastSavedText.textContent = 'Last saved: Just now';
                    } else if (minutes < 60) {
                        lastSavedText.textContent = `Last saved: ${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                    } else {
                        const hours = Math.floor(minutes / 60);
                        lastSavedText.textContent = `Last saved: ${hours} hour${hours > 1 ? 's' : ''} ago`;
                    }
                } else {
                    lastSavedText.textContent = 'Last saved: Never';
                }
                
                // Update TTS toggle state
                const toggleSwitch = document.getElementById('ttsToggleSwitch');
                const voiceSettings = document.getElementById('voiceSettings');
                const voiceStyle = document.getElementById('voiceStyle');
                const customSettings = document.getElementById('customVoiceSettings');
                
                if (this.data.ttsEnabled) {
                    toggleSwitch.classList.add('active');
                    voiceSettings.style.display = 'block';
                } else {
                    toggleSwitch.classList.remove('active');
                    voiceSettings.style.display = 'none';
                }
                
                // Load voice settings
                voiceStyle.value = this.data.voiceStyle || 'robotic';
                document.getElementById('voicePitch').value = this.data.voicePitch || 1.5;
                document.getElementById('voiceRate').value = this.data.voiceRate || 1.2;
                document.getElementById('pitchValue').textContent = (this.data.voicePitch || 1.5).toFixed(1);
                document.getElementById('rateValue').textContent = (this.data.voiceRate || 1.2).toFixed(1);
                
                // Load Scrappy's voice settings
                document.getElementById('scrappyPitch').value = this.data.scrappyPitch || 0.8;
                document.getElementById('scrappyRate').value = this.data.scrappyRate || 0.9;
                document.getElementById('scrappyPitchValue').textContent = (this.data.scrappyPitch || 0.8).toFixed(1);
                document.getElementById('scrappyRateValue').textContent = (this.data.scrappyRate || 0.9).toFixed(1);
                
                // Show custom settings if custom style is selected
                customSettings.style.display = this.data.voiceStyle === 'custom' ? 'block' : 'none';
                
                document.getElementById('settingsModal').classList.add('active');
            },

            toggleTTSSwitch() {
                this.data.ttsEnabled = !this.data.ttsEnabled;
                const toggleSwitch = document.getElementById('ttsToggleSwitch');
                const voiceSettings = document.getElementById('voiceSettings');
                
                if (this.data.ttsEnabled) {
                    toggleSwitch.classList.add('active');
                    voiceSettings.style.display = 'block';
                    this.speak("Voice enabled! I can speak now!");
                } else {
                    toggleSwitch.classList.remove('active');
                    voiceSettings.style.display = 'none';
                    if (this.tts.synthesis.speaking) {
                        this.tts.synthesis.cancel();
                    }
                }
                
                this.saveData();
            },

            showSaveFileSelect() {
                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                const saveFileList = document.getElementById('saveFileList');
                
                saveFileList.innerHTML = '';
                saveFiles.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    if (file.name === this.data.currentSaveFile) {
                        fileItem.classList.add('current');
                    }
                    fileItem.innerHTML = `
                        <div class="file-item-name">${file.displayName}${file.name === this.data.currentSaveFile ? ' (Current)' : ''}</div>
                        <div class="file-item-date">${new Date(file.lastModified).toLocaleDateString()} ${new Date(file.lastModified).toLocaleTimeString()}</div>
                    `;
                    fileItem.onclick = () => this.overwriteSave(file.name);
                    saveFileList.appendChild(fileItem);
                });
                
                document.getElementById('saveFileSelectModal').classList.add('active');
            },

            closeSaveFileSelect() {
                document.getElementById('saveFileSelectModal').classList.remove('active');
                document.getElementById('newSaveFileName').value = '';
            },

            createNewSave() {
                const input = document.getElementById('newSaveFileName');
                const fileName = input.value.trim();
                
                if (!fileName) {
                    alert('Please enter a save name!');
                    return;
                }

                const sanitizedName = fileName.replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 50);
                if (!sanitizedName) {
                    alert('Please enter a valid save name!');
                    return;
                }
                
                this.data.currentSaveFile = sanitizedName;
                this.data.lastSaveTime = Date.now();
                this.saveData();
                
                this.closeSaveFileSelect();
                this.showSettingsModal();
                alert(`Progress saved as "${sanitizedName}"!`);
            },

            overwriteSave(fileName) {
                if (!confirm(`Overwrite "${fileName}"?`)) {
                    return;
                }
                
                this.data.currentSaveFile = fileName;
                this.data.lastSaveTime = Date.now();
                this.saveData();
                
                this.closeSaveFileSelect();
                this.showSettingsModal();
                alert(`Progress saved to "${fileName}"!`);
            },

            showLoadFileSelect() {
                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                const loadFileList = document.getElementById('loadFileList');
                
                if (saveFiles.length === 0) {
                    loadFileList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No saved files found</div>';
                } else {
                    loadFileList.innerHTML = '';
                    saveFiles.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        if (file.name === this.data.currentSaveFile) {
                            fileItem.classList.add('current');
                        }
                        fileItem.innerHTML = `
                            <div class="file-item-name">${file.displayName}${file.name === this.data.currentSaveFile ? ' (Current)' : ''}</div>
                            <div class="file-item-date">${new Date(file.lastModified).toLocaleDateString()} ${new Date(file.lastModified).toLocaleTimeString()}</div>
                        `;
                        fileItem.onclick = () => this.loadFile(file.name);
                        loadFileList.appendChild(fileItem);
                    });
                }
                
                document.getElementById('loadFileSelectModal').classList.add('active');
            },

            closeLoadFileSelect() {
                document.getElementById('loadFileSelectModal').classList.remove('active');
            },

            loadFile(fileName) {
                if (!confirm(`Load "${fileName}"? Current unsaved progress will be lost.`)) {
                    return;
                }

                const savedData = localStorage.getItem(`upkeepData_${fileName}`);
                if (!savedData) {
                    alert('Save file not found!');
                    return;
                }

                const parsedData = JSON.parse(savedData);
                
                // Calculate real-time decay
                parsedData.categories.forEach(category => {
                    if (!category.tasks) return;
                    category.tasks.forEach(task => {
                        if (task.lastCompleted) {
                            const totalElapsed = (Date.now() - task.lastCompleted);
                            task.freshness = Math.max(0, Math.min(100, 100 - (totalElapsed / task.decayMs) * 100));
                        }
                    });
                });

                this.data = parsedData;
                this.data.currentSaveFile = fileName;
                localStorage.setItem('upkeepCurrentFile', fileName);

                this.saveData();
                this.closeLoadFileSelect();
                this.closeModal('settingsModal');
                this.render();

                alert(`Loaded "${fileName}"!`);
            },

            // Export/Import Functions
            exportToFile() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    currentSaveFile: this.data.currentSaveFile,
                    allSaves: {}
                };

                // Get all save files
                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                
                // Export all save slots
                saveFiles.forEach(file => {
                    const saveData = localStorage.getItem(`upkeepData_${file.name}`);
                    if (saveData) {
                        exportData.allSaves[file.name] = {
                            displayName: file.displayName,
                            lastModified: file.lastModified,
                            data: JSON.parse(saveData)
                        };
                    }
                });

                // Create blob and download
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `upkeep-backup-${new Date().toISOString().split('T')[0]}.upkeep`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showSpeechBubble("Your data has been exported! Keep this file safe for backup.");
            },

            importFromFile() {
                document.getElementById('importFileInput').click();
            },

            handleImportFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        
                        if (!importData.version || !importData.allSaves) {
                            alert('Invalid backup file format!');
                            return;
                        }

                        if (!confirm(`Import data from "${file.name}"? This will merge with your existing saves.`)) {
                            return;
                        }

                        // Import all saves
                        const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                        
                        Object.keys(importData.allSaves).forEach(saveName => {
                            const saveInfo = importData.allSaves[saveName];
                            
                            // Add to save files list if not exists
                            if (!saveFiles.find(f => f.name === saveName)) {
                                saveFiles.push({
                                    name: saveName,
                                    displayName: saveInfo.displayName,
                                    lastModified: saveInfo.lastModified
                                });
                            }
                            
                            // Save the data
                            localStorage.setItem(`upkeepData_${saveName}`, JSON.stringify(saveInfo.data));
                        });

                        localStorage.setItem('upkeepSaveFiles', JSON.stringify(saveFiles));
                        
                        alert(`Successfully imported ${Object.keys(importData.allSaves).length} save slot(s)!`);
                        this.showSpeechBubble("Import complete! Your saves are now available.");
                        
                        // Reset file input
                        event.target.value = '';
                    } catch (error) {
                        alert('Error reading backup file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            },

            // Manage Saves Functions
            showManageSaves() {
                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                const manageSavesList = document.getElementById('manageSavesList');
                
                if (saveFiles.length === 0) {
                    manageSavesList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No save slots found</div>';
                } else {
                    manageSavesList.innerHTML = '';
                    saveFiles.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        if (file.name === this.data.currentSaveFile) {
                            fileItem.classList.add('current');
                        }
                        fileItem.innerHTML = `
                            <div class="file-item-name">${file.displayName}${file.name === this.data.currentSaveFile ? ' (Current)' : ''}</div>
                            <div class="file-item-date">${new Date(file.lastModified).toLocaleString()}</div>
                            <div class="file-item-actions">
                                <button class="file-item-btn export" onclick="app.exportSingleSave('${file.name}')">📤 Export</button>
                                <button class="file-item-btn delete" onclick="app.deleteSingleSave('${file.name}')">🗑️ Delete</button>
                            </div>
                        `;
                        manageSavesList.appendChild(fileItem);
                    });
                }
                
                document.getElementById('manageSavesModal').classList.add('active');
            },

            closeManageSaves() {
                document.getElementById('manageSavesModal').classList.remove('active');
            },

            exportSingleSave(fileName) {
                const saveData = localStorage.getItem(`upkeepData_${fileName}`);
                if (!saveData) {
                    alert('Save file not found!');
                    return;
                }

                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                const saveInfo = saveFiles.find(f => f.name === fileName);

                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    currentSaveFile: fileName,
                    allSaves: {
                        [fileName]: {
                            displayName: saveInfo?.displayName || fileName,
                            lastModified: saveInfo?.lastModified || Date.now(),
                            data: JSON.parse(saveData)
                        }
                    }
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}-${new Date().toISOString().split('T')[0]}.upkeep`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showSpeechBubble(`"${fileName}" has been exported!`);
            },

            deleteSingleSave(fileName) {
                if (fileName === this.data.currentSaveFile) {
                    alert('Cannot delete the currently active save!');
                    return;
                }

                if (!confirm(`Delete save slot "${fileName}"? This cannot be undone!`)) {
                    return;
                }

                // Remove from localStorage
                localStorage.removeItem(`upkeepData_${fileName}`);
                
                // Remove from save files list
                let saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                saveFiles = saveFiles.filter(f => f.name !== fileName);
                localStorage.setItem('upkeepSaveFiles', JSON.stringify(saveFiles));

                this.showSpeechBubble(`"${fileName}" has been deleted.`);
                this.showManageSaves(); // Refresh the list
            },

            // Logbook Functions
            addLogEntry(type, title, description) {
                const entry = {
                    id: Date.now(),
                    type: type, // 'completed', 'added', 'freshness'
                    title: title,
                    description: description,
                    timestamp: Date.now()
                };
                
                this.data.activityLog.unshift(entry); // Add to beginning
                
                // Keep only last 100 entries
                if (this.data.activityLog.length > 100) {
                    this.data.activityLog = this.data.activityLog.slice(0, 100);
                }
                
                this.saveData();
            },

            openLogbook() {
                this.renderLogbook();
                document.getElementById('logbookModal').classList.add('active');
            },

            closeLogbook() {
                document.getElementById('logbookModal').classList.remove('active');
            },

            clearLogbook() {
                if (!confirm('Clear all activity log entries? This cannot be undone!')) {
                    return;
                }
                
                this.data.activityLog = [];
                this.saveData();
                this.renderLogbook();
                this.showSpeechBubble("Activity log cleared!");
            },

            renderLogbook() {
                const logbookBody = document.getElementById('logbookBody');
                
                if (this.data.activityLog.length === 0) {
                    logbookBody.innerHTML = '<div class="logbook-empty">No activity yet. Start completing tasks to build your home\'s story!</div>';
                    return;
                }

                // Group entries by date
                const groupedEntries = {};
                this.data.activityLog.forEach(entry => {
                    const date = new Date(entry.timestamp);
                    const dateKey = date.toLocaleDateString();
                    
                    if (!groupedEntries[dateKey]) {
                        groupedEntries[dateKey] = [];
                    }
                    groupedEntries[dateKey].push(entry);
                });

                // Render grouped entries
                let html = '';
                Object.keys(groupedEntries).forEach(dateKey => {
                    const entries = groupedEntries[dateKey];
                    const date = new Date(entries[0].timestamp);
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    
                    let dateLabel = dateKey;
                    if (date.toDateString() === today.toDateString()) {
                        dateLabel = `Today, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
                    } else if (date.toDateString() === yesterday.toDateString()) {
                        dateLabel = `Yesterday, ${date.getFullYear()}`;
                    }
                    
                    html += `<div class="logbook-date-group">`;
                    html += `<div class="logbook-date-header">${dateLabel}</div>`;
                    
                    entries.forEach(entry => {
                        const icon = entry.type === 'completed' ? '✓' : 
                                   entry.type === 'added' ? '+' : 
                                   entry.type === 'snoozed' ? '💤' : '📊';
                        
                        html += `
                            <div class="logbook-entry">
                                <div class="logbook-entry-icon">${icon}</div>
                                <div class="logbook-entry-content">
                                    <div class="logbook-entry-title">${entry.title}</div>
                                    <div class="logbook-entry-desc">${entry.description}</div>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                });

                logbookBody.innerHTML = html;
            },

            populateSaveFileLists() {
                const saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                
                // Populate save file select
                const saveFileSelect = document.getElementById('saveFileSelect');
                saveFileSelect.innerHTML = '<option value="">-- Select existing file or create new --</option>';
                saveFileSelect.innerHTML += '<option value="__new__">✏️ Create New Save File</option>';
                saveFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.name;
                    option.textContent = file.displayName;
                    if (file.name === this.data.currentSaveFile) {
                        option.textContent += ' [Current]';
                    }
                    saveFileSelect.appendChild(option);
                });
                
                // Populate load select
                const loadSelect = document.getElementById('loadFileSelect');
                loadSelect.innerHTML = '<option value="">-- Select a saved file --</option>';
                saveFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.name;
                    option.textContent = `${file.displayName} (${new Date(file.lastModified).toLocaleDateString()})`;
                    if (file.name === this.data.currentSaveFile) {
                        option.textContent += ' [Current]';
                    }
                    loadSelect.appendChild(option);
                });

                // Populate delete select
                const deleteSelect = document.getElementById('deleteFileSelect');
                deleteSelect.innerHTML = '<option value="">-- Select a file to delete --</option>';
                saveFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.name;
                    option.textContent = file.displayName;
                    if (file.name === this.data.currentSaveFile) {
                        option.textContent += ' [Current]';
                    }
                    deleteSelect.appendChild(option);
                });
            },

            handleSaveFileSelect() {
                const saveFileSelect = document.getElementById('saveFileSelect');
                const saveFileName = document.getElementById('saveFileName');
                
                if (saveFileSelect.value === '__new__') {
                    // Show input for new file name
                    saveFileName.style.display = 'block';
                    saveFileName.value = '';
                    saveFileName.focus();
                } else if (saveFileSelect.value) {
                    // Hide input when existing file is selected
                    saveFileName.style.display = 'none';
                    saveFileName.value = '';
                } else {
                    // Hide input when nothing is selected
                    saveFileName.style.display = 'none';
                    saveFileName.value = '';
                }
            },

            updateLoadButton() {
                const loadSelect = document.getElementById('loadFileSelect');
                const loadButton = document.getElementById('loadButton');
                loadButton.disabled = !loadSelect.value;
            },

            updateDeleteButton() {
                const deleteSelect = document.getElementById('deleteFileSelect');
                const deleteButton = document.getElementById('deleteButton');
                deleteButton.disabled = !deleteSelect.value;
            },

            saveToFile() {
                const saveFileSelect = document.getElementById('saveFileSelect');
                const saveFileNameInput = document.getElementById('saveFileName');
                
                let targetFileName = '';
                
                if (saveFileSelect.value === '__new__') {
                    // Creating a new file
                    const fileName = saveFileNameInput.value.trim();
                    if (!fileName) {
                        alert('Please enter a save name!');
                        return;
                    }

                    // Create sanitized file name
                    const sanitizedName = fileName.replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 50);
                    if (!sanitizedName) {
                        alert('Please enter a valid save name!');
                        return;
                    }
                    
                    targetFileName = sanitizedName;
                } else if (saveFileSelect.value) {
                    // Overwriting existing file
                    targetFileName = saveFileSelect.value;
                    
                    if (!confirm(`Overwrite "${targetFileName}"?`)) {
                        return;
                    }
                } else {
                    alert('Please select a file or choose to create a new one!');
                    return;
                }

                // Save current data to the target file
                this.data.currentSaveFile = targetFileName;
                this.data.lastSaveTime = Date.now();
                this.saveData();

                // Clear inputs and reset select
                saveFileNameInput.value = '';
                saveFileNameInput.style.display = 'none';
                saveFileSelect.value = '';

                // Refresh lists
                this.populateSaveFileLists();

                alert(`Progress saved as "${targetFileName}"!`);
            },

            loadFromFile() {
                const loadSelect = document.getElementById('loadFileSelect');
                const selectedFile = loadSelect.value;
                
                if (!selectedFile) return;

                if (!confirm(`Load "${selectedFile}"? Current unsaved progress will be lost.`)) {
                    return;
                }

                const savedData = localStorage.getItem(`upkeepData_${selectedFile}`);
                if (!savedData) {
                    alert('Save file not found!');
                    return;
                }

                // Parse the saved data
                const parsedData = JSON.parse(savedData);
                
                // Calculate real-time decay based on lastSaveTime
                const timeSinceSave = Date.now() - (parsedData.lastSaveTime || Date.now());
                
                parsedData.categories.forEach(category => {
                    if (!category.tasks) return;
                    category.tasks.forEach(task => {
                        if (task.lastCompleted) {
                            // Recalculate freshness as if time has passed
                            const totalElapsed = (Date.now() - task.lastCompleted);
                            task.freshness = Math.max(0, Math.min(100, 100 - (totalElapsed / task.decayMs) * 100));
                        }
                    });
                });

                // Load the data
                this.data = parsedData;
                this.data.currentSaveFile = selectedFile;
                localStorage.setItem('upkeepCurrentFile', selectedFile);

                // Save with updated decay
                this.saveData();

                // Close modal and render
                this.closeModal('settingsModal');
                this.render();

                alert(`Loaded "${selectedFile}" with real-time decay applied!`);
            },

            deleteFile() {
                const deleteSelect = document.getElementById('deleteFileSelect');
                const selectedFile = deleteSelect.value;
                
                if (!selectedFile) return;

                if (selectedFile === this.data.currentSaveFile) {
                    alert('Cannot delete the currently active save file!');
                    return;
                }

                if (!confirm(`Delete "${selectedFile}"? This cannot be undone.`)) {
                    return;
                }

                // Remove from localStorage
                localStorage.removeItem(`upkeepData_${selectedFile}`);

                // Update save files list
                let saveFiles = JSON.parse(localStorage.getItem('upkeepSaveFiles') || '[]');
                saveFiles = saveFiles.filter(f => f.name !== selectedFile);
                localStorage.setItem('upkeepSaveFiles', JSON.stringify(saveFiles));

                // Refresh lists
                this.populateSaveFileLists();

                alert(`Deleted "${selectedFile}"!`);
            },

            // Currency Functions
            updateCurrencyDisplay() {
                const mainDisplay = document.getElementById('currencyAmount');
                const storeDisplay = document.getElementById('storeCurrencyAmount');
                
                if (mainDisplay) {
                    mainDisplay.textContent = this.data.currency;
                }
                if (storeDisplay) {
                    storeDisplay.textContent = this.data.currency;
                }
            },

            addCurrency(amount) {
                this.data.currency += amount;
                this.saveData();
                this.updateCurrencyDisplay();
            },

            deductCurrency(amount) {
                if (this.data.currency >= amount) {
                    this.data.currency -= amount;
                    this.saveData();
                    this.updateCurrencyDisplay();
                    return true;
                }
                return false;
            },

            // Scrappy Functions
            isStoreOpen() {
                const modal = document.getElementById('robotStoreModal');
                return modal && modal.classList.contains('active');
            },

            showScrappyDialogue(message, emotion = 'regular', forceShow = false) {
                // Only show Scrappy dialogue if store is open or forced (for settings testing)
                if (!forceShow && !this.isStoreOpen()) {
                    return;
                }
                const scrappyImage = document.getElementById('scrappyImage');
                const bubble = document.getElementById('scrappySpeechBubble');
                
                if (!scrappyImage || !bubble) return;

                // Update Scrappy's image based on emotion
                const imagePaths = {
                    regular: 'Imag/Achivments/Images/Finished Images/Store manager/Scrappy.png',
                    happy: 'Imag/Achivments/Images/Finished Images/Store manager/Scrappy-Happy.png',
                    mad: 'Imag/Achivments/Images/Finished Images/Store manager/Scrappy-Mad.png',
                    sad: 'Imag/Achivments/Images/Finished Images/Store manager/Scrappy-Sad.png'
                };
                scrappyImage.src = imagePaths[emotion] || imagePaths.regular;

                // Show speech bubble
                bubble.textContent = message;
                bubble.classList.add('visible');

                // Speak the message using text-to-speech
                if (this.data.ttsEnabled && 'speechSynthesis' in window) {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();
                    
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.pitch = this.data.scrappyPitch || 0.8;
                    utterance.rate = this.data.scrappyRate || 0.9;
                    utterance.volume = 1.0;
                    window.speechSynthesis.speak(utterance);
                }

                // Hide after 4 seconds
                setTimeout(() => {
                    bubble.classList.remove('visible');
                    // Reset to regular after dialogue
                    setTimeout(() => {
                        scrappyImage.src = imagePaths.regular;
                    }, 300);
                }, 4000);
            },

            getRandomDialogue(category) {
                const dialogues = this.scrappyDialogue[category];
                if (!dialogues || dialogues.length === 0) return '';
                return dialogues[Math.floor(Math.random() * dialogues.length)];
            },

            startScrappyIdleChatter() {
                // Clear any existing timer
                if (this.scrappyIdleTimer) {
                    clearInterval(this.scrappyIdleTimer);
                }

                // Show idle chatter every 15-20 seconds
                this.scrappyIdleTimer = setInterval(() => {
                    const message = this.getRandomDialogue('idle');
                    this.showScrappyDialogue(message, 'regular');
                }, 15000 + Math.random() * 5000);
            },

            stopScrappyIdleChatter() {
                if (this.scrappyIdleTimer) {
                    clearInterval(this.scrappyIdleTimer);
                    this.scrappyIdleTimer = null;
                }
            },

            scrappyInteraction() {
                const container = document.getElementById('scrappyContainer');
                if (!container) return;

                // Random dodge direction
                const directions = [
                    { x: -50, y: -50 },
                    { x: 50, y: -50 },
                    { x: -50, y: 50 },
                    { x: 50, y: 50 },
                    { x: -80, y: 0 },
                    { x: 80, y: 0 },
                    { x: 0, y: -80 },
                    { x: 0, y: 80 }
                ];
                const direction = directions[Math.floor(Math.random() * directions.length)];

                // Apply dodge
                container.classList.add('dodging');
                container.style.transform = `translate(${direction.x}px, ${direction.y}px)`;

                // Reset position after dodge
                setTimeout(() => {
                    container.style.transform = 'translate(0, 0)';
                    container.classList.remove('dodging');
                }, 500);

                // Scrappy speaks a random idle line
                const message = this.getRandomDialogue('idle');
                this.showScrappyDialogue(message, 'regular');
            },

            // Robot Store Functions
            openRobotStore() {
                const modal = document.getElementById('robotStoreModal');
                const scrappyContainer = document.getElementById('scrappyContainer');
                const storeCurrencyDisplay = document.getElementById('storeCurrencyDisplay');
                const mascotContainer = document.querySelector('.mascot-container-global');
                
                modal.classList.add('active');
                this.updateCurrencyDisplay();
                this.renderRobotStore();
                
                // Hide user's mascot robot
                if (mascotContainer) {
                    mascotContainer.style.display = 'none';
                }
                
                // Show Scrappy and store currency display
                if (scrappyContainer) {
                    scrappyContainer.style.display = 'block';
                }
                if (storeCurrencyDisplay) {
                    storeCurrencyDisplay.style.display = 'flex';
                }
                
                // Scrappy greets the player
                setTimeout(() => {
                    const greeting = this.getRandomDialogue('greeting');
                    this.showScrappyDialogue(greeting, 'regular');
                }, 500);
                
                // Start idle chatter after greeting
                setTimeout(() => {
                    this.startScrappyIdleChatter();
                }, 5000);
            },

            updateStoreCloseButton(enabled) {
                const closeButton = document.querySelector('.robot-store-close');
                if (closeButton) {
                    if (enabled) {
                        closeButton.style.opacity = '1';
                        closeButton.style.cursor = 'pointer';
                        closeButton.style.pointerEvents = 'auto';
                    } else {
                        closeButton.style.opacity = '0.3';
                        closeButton.style.cursor = 'not-allowed';
                        closeButton.style.pointerEvents = 'none';
                    }
                }
            },

            closeRobotStore() {
                // Don't allow closing if purchase is in progress
                if (this.purchaseInProgress) {
                    return;
                }
                
                const modal = document.getElementById('robotStoreModal');
                const scrappyContainer = document.getElementById('scrappyContainer');
                const storeCurrencyDisplay = document.getElementById('storeCurrencyDisplay');
                const mascotContainer = document.querySelector('.mascot-container-global');
                
                // Scrappy says goodbye
                const goodbye = this.getRandomDialogue('goodbye');
                this.showScrappyDialogue(goodbye, 'sad');
                
                // Stop idle chatter
                this.stopScrappyIdleChatter();
                
                // Close modal and hide Scrappy after goodbye message
                setTimeout(() => {
                    modal.classList.remove('active');
                    if (scrappyContainer) {
                        scrappyContainer.style.display = 'none';
                    }
                    if (storeCurrencyDisplay) {
                        storeCurrencyDisplay.style.display = 'none';
                    }
                    // Show user's mascot robot again
                    if (mascotContainer) {
                        mascotContainer.style.display = 'block';
                    }
                }, 1500);
            },

            // Function to generate cryptic name based on robot ID
            generateCrypticName(robotId) {
                const crypticChars = ['█', '▓', '▒', '░', '▀', '▄', '■', '□', '▪', '▫', '◆', '◇', '○', '●', '◉', '◎'];
                const symbols = ['?', '!', '#', '@', '$', '%', '&', '*'];
                const length = 8 + Math.floor(Math.random() * 4);
                let cryptic = '';
                
                // Use robot ID as seed for consistent scrambling
                let seed = 0;
                for (let i = 0; i < robotId.length; i++) {
                    seed += robotId.charCodeAt(i);
                }
                
                for (let i = 0; i < length; i++) {
                    const charIndex = (seed + i) % crypticChars.length;
                    const symIndex = (seed + i * 2) % symbols.length;
                    cryptic += i % 3 === 0 ? symbols[symIndex] : crypticChars[charIndex];
                }
                
                return cryptic;
            },

            renderRobotStore() {
                const container = document.getElementById('robotStoreGrid');
                if (!container) return;

                const totalSlots = 50;
                const cards = [];

                // Filter to show only robots that are NOT owned
                const availableRobots = this.storeRobots.filter(robot => 
                    !this.data.ownedRobots.includes(robot.id)
                );

                // Add available robot cards
                availableRobots.forEach(robot => {
                    const crypticName = this.generateCrypticName(robot.id);
                    const isDisabled = this.purchaseInProgress;
                    const buttonStyle = isDisabled ? 'opacity: 0.5; cursor: not-allowed;' : '';
                    const buttonText = isDisabled ? 'PROCESSING...' : 'BUY';
                    const buttonAction = isDisabled ? '' : `onclick="event.stopPropagation(); app.initiatePurchase('${robot.id}')"`;
                    
                    cards.push(`
                        <div class="robot-store-card">
                            <img src="${robot.shadowImagePath}" 
                                 alt="Mystery Robot" 
                                 class="robot-store-card-image">
                            <div class="robot-store-card-name" style="font-family: monospace; letter-spacing: 2px;">${crypticName}</div>
                            <div class="robot-store-card-cost">
                                <img src="Imag/Achivments/Images/Finished Images/Bolt.png" alt="Bolt" class="robot-store-card-cost-bolt">
                                <span>${robot.cost} Bolts</span>
                            </div>
                            <button class="robot-store-card-button" style="${buttonStyle}" ${buttonAction} ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                        </div>
                    `);
                });

                // Fill remaining slots with placeholders
                const remainingSlots = totalSlots - cards.length;
                for (let i = 0; i < remainingSlots; i++) {
                    cards.push(`
                        <div class="robot-store-card placeholder">
                            <div class="robot-store-card-image placeholder-icon">❓</div>
                            <div class="robot-store-card-name">Coming Soon</div>
                            <div class="robot-store-card-cost">
                                <img src="Imag/Achivments/Images/Finished Images/Bolt.png" alt="Bolt" class="robot-store-card-cost-bolt">
                                <span>??? Bolts</span>
                            </div>
                            <button class="robot-store-card-button" style="opacity: 0.5; cursor: not-allowed;" disabled>LOCKED</button>
                        </div>
                    `);
                }

                container.innerHTML = cards.join('');
            },

            selectRobotFromStore(robotId) {
                this.data.selectedRobot = robotId;
                this.saveData();
                this.renderRobotStore();
                this.updateMascotImage();
                this.showSpeechBubble('Robot selected! I\'m ready to help!', 'regular');
            },

            initiatePurchase(robotId) {
                // Prevent multiple purchases during sequence
                if (this.purchaseInProgress) {
                    const busyMessage = this.getRandomDialogue('idle');
                    this.showScrappyDialogue("Hold on there! I'm still working on the last order!", 'regular');
                    return;
                }

                const robot = this.storeRobots.find(r => r.id === robotId);
                if (!robot) return;

                // Store the robot being purchased
                this.pendingPurchase = robot;

                // Show confirmation modal
                const modal = document.getElementById('purchaseConfirmModal');
                const costDisplay = document.getElementById('purchaseConfirmCost');
                costDisplay.textContent = robot.cost;
                modal.classList.add('active');
            },

            cancelPurchase() {
                const modal = document.getElementById('purchaseConfirmModal');
                modal.classList.remove('active');
                
                // Scrappy reacts to canceled purchase
                if (this.pendingPurchase) {
                    const cancelMessage = this.getRandomDialogue('canceled');
                    this.showScrappyDialogue(cancelMessage, 'mad');
                }
                
                this.pendingPurchase = null;
                // Clear purchase lock
                this.purchaseInProgress = false;
                this.updateStoreCloseButton(true); // Re-enable close button
            },

            confirmPurchase() {
                if (!this.pendingPurchase) return;

                // Set purchase lock
                this.purchaseInProgress = true;
                this.updateStoreCloseButton(false); // Disable close button

                const robot = this.pendingPurchase;

                // Check if player has enough currency (unless cheat is active)
                if (!this.isObonxoCheatActive && this.data.currency < robot.cost) {
                    this.cancelPurchase();
                    this.showSpeechBubble('Not enough Bolts! Complete more tasks to earn currency!', 'regular');
                    
                    // Show a styled alert
                    const alertDiv = document.createElement('div');
                    alertDiv.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, #ef4444, #dc2626);
                        color: white;
                        padding: 24px 32px;
                        border-radius: 20px;
                        font-size: 18px;
                        font-weight: 600;
                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                        z-index: 3000;
                        text-align: center;
                        animation: shake 0.5s ease;
                    `;
                    alertDiv.textContent = '❌ Not enough Bolts!';
                    document.body.appendChild(alertDiv);
                    
                    setTimeout(() => {
                        alertDiv.style.transition = 'opacity 0.3s ease';
                        alertDiv.style.opacity = '0';
                        setTimeout(() => alertDiv.remove(), 300);
                    }, 2000);
                    
                    return;
                }

                // Deduct currency (only if cheat is not active)
                if (!this.isObonxoCheatActive) {
                    this.deductCurrency(robot.cost);
                }

                // Add robot to owned list
                this.data.ownedRobots.push(robot.id);
                this.saveData();

                // Scrappy celebrates successful purchase
                const purchaseMessage = this.getRandomDialogue('purchased');
                this.showScrappyDialogue(purchaseMessage, 'happy');

                // Close confirmation modal (don't trigger cancel dialogue)
                const modal = document.getElementById('purchaseConfirmModal');
                modal.classList.remove('active');
                this.pendingPurchase = null;

                // Update the store display to remove purchased robot
                this.renderRobotStore();
                this.updateCurrencyDisplay();

                // Show reveal animation after Scrappy finishes speaking
                setTimeout(() => {
                    this.showRobotReveal(robot);
                }, 4500); // Wait for Scrappy's purchase message to finish (4 seconds + buffer)
            },

            showRobotReveal(robot) {
                const modal = document.getElementById('robotRevealModal');
                const image = document.getElementById('robotRevealImage');
                const name = document.getElementById('robotRevealName');

                image.src = robot.actualImagePath;
                name.textContent = robot.name;

                modal.classList.add('active');

                // Clear purchase lock as soon as reveal appears - buttons become clickable again
                this.purchaseInProgress = false;
                this.updateStoreCloseButton(true); // Re-enable close button
                // Update store display to show clickable buttons
                this.renderRobotStore();

                // Scrappy celebrates instead of mascot (since we're in the store)
                const celebrationMessage = `Excellent choice! ${robot.name} is all yours now!`;
                this.showScrappyDialogue(celebrationMessage, 'happy');
            },

            closeReveal() {
                const modal = document.getElementById('robotRevealModal');
                modal.classList.remove('active');
                
                // Check if we're in the store - if so, keep store open
                const storeModal = document.getElementById('robotStoreModal');
                if (storeModal && storeModal.classList.contains('active')) {
                    // We're still in the store, continue idle chatter
                    setTimeout(() => {
                        this.startScrappyIdleChatter();
                    }, 1000);
                } else {
                    // Refresh robot select to show new robot if robot select is open
                    if (document.getElementById('robotSelectModal').style.display === 'flex') {
                        this.renderRobotOptions();
                    }
                }
            },

            createNewSaveFile() {
                const saveName = prompt('Enter a name for your new save file:');
                if (!saveName || !saveName.trim()) {
                    return;
                }

                const sanitizedName = saveName.trim().replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 50);
                if (!sanitizedName) {
                    alert('Please enter a valid save name!');
                    return;
                }

                // Check if save already exists
                const existingData = localStorage.getItem(`upkeepData_${sanitizedName}`);
                if (existingData) {
                    if (!confirm(`A save named "${sanitizedName}" already exists. Overwrite it?`)) {
                        return;
                    }
                }

                // Create fresh data with only default robot owned
                this.data = {
                    categories: [],
                    currentCategoryId: null,
                    currentTaskId: null,
                    currentSaveFile: sanitizedName,
                    lastSaveTime: Date.now(),
                    ttsEnabled: true,
                    activityLog: [],
                    voiceStyle: 'robotic',
                    voicePitch: 1.5,
                    voiceRate: 1.2,
                    scrappyPitch: 0.5,
                    scrappyRate: 1.3,
                    selectedRobotId: 'default',
                    currency: 250,
                    ownedRobots: ['default']
                };

                // Save the new file
                this.saveData();

                // Close settings modal and refresh
                this.closeModal('settingsModal');
                this.render();

                alert(`New save "${sanitizedName}" created! Starting fresh with only the Default Bot.`);
                this.showSpeechBubble('Welcome to your new adventure!', 'regular');
            },

            // Combat Tester Functions
            openCombatTester() {
                console.log('🎯 Opening Combat Tester...');
                const modal = document.getElementById('combatTesterModal');
                console.log('Modal element:', modal);
                if (modal) {
                    modal.classList.add('active');
                    this.populateRobotSelectors();
                    this.updateRobotInfo();
                    console.log('✅ Combat Tester opened successfully');
                } else {
                    console.error('❌ Combat Tester modal not found!');
                }
            },
            
            closeCombatTester() {
                const modal = document.getElementById('combatTesterModal');
                modal.classList.remove('active');
            },
            
            populateRobotSelectors() {
                console.log('🤖 Populating robot selectors...');
                const attackerSelect = document.getElementById('attackerSelect');
                const defenderSelect = document.getElementById('defenderSelect');
                console.log('Attacker select:', attackerSelect);
                console.log('Defender select:', defenderSelect);
                
                const robots = RobotDatabase.getAllRobots();
                console.log('Available robots:', robots.length, robots);
                
                // Clear existing options
                attackerSelect.innerHTML = '';
                defenderSelect.innerHTML = '';
                
                // Populate with robot options
                robots.forEach(robot => {
                    const option1 = document.createElement('option');
                    option1.value = robot.id;
                    option1.textContent = `${robot.name} (${robot.role})`;
                    attackerSelect.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = robot.id;
                    option2.textContent = `${robot.name} (${robot.role})`;
                    defenderSelect.appendChild(option2);
                });
                
                // Set default selections (different robots)
                if (robots.length >= 2) {
                    attackerSelect.value = robots[0].id;
                    defenderSelect.value = robots[1].id;
                }
                
                // Add change listeners
                attackerSelect.addEventListener('change', () => this.updateRobotInfo());
                defenderSelect.addEventListener('change', () => this.updateRobotInfo());
            },
            
            updateRobotInfo() {
                const attackerSelect = document.getElementById('attackerSelect');
                const defenderSelect = document.getElementById('defenderSelect');
                const attackerInfo = document.getElementById('attackerInfo');
                const defenderInfo = document.getElementById('defenderInfo');
                
                if (attackerSelect.value) {
                    const robot = RobotDatabase.getRobot(attackerSelect.value);
                    attackerInfo.innerHTML = this.formatRobotInfo(robot);
                }
                
                if (defenderSelect.value) {
                    const robot = RobotDatabase.getRobot(defenderSelect.value);
                    defenderInfo.innerHTML = this.formatRobotInfo(robot);
                }
            },
            
            formatRobotInfo(robot) {
                let html = `
                    <h4>${robot.name}</h4>
                    <div class="robot-stats">${robot.mp} MP • ${robot.role} • ${robot.rarity}</div>
                    <div class="robot-wheel">
                `;
                
                robot.wheel.forEach(segment => {
                    const color = CombatSystem.getMoveColor(segment.moveType);
                    const textColor = segment.moveType === 'White' ? '#000' : '#fff';
                    const text = CombatSystem.formatMoveText(segment);
                    
                    html += `
                        <div class="wheel-segment" style="background: ${color}; color: ${textColor};">
                            <span>${text}</span>
                            <span>${segment.size}/96</span>
                        </div>
                    `;
                });
                
                html += '</div>';
                return html;
            },
            
            runCombatTest() {
                const attackerSelect = document.getElementById('attackerSelect');
                const defenderSelect = document.getElementById('defenderSelect');
                
                if (!attackerSelect.value || !defenderSelect.value) {
                    alert('Please select both robots!');
                    return;
                }
                
                const battle = CombatSystem.simulateBattle(attackerSelect.value, defenderSelect.value);
                this.displayBattleResults(battle);
                this.updateCombatStats(battle);
            },
            
            displayBattleResults(battle) {
                // Store the battle result for visual replay
                this.lastBattleResult = battle;
                
                const resultsDiv = document.getElementById('combatResults');
                const outcomeDiv = document.getElementById('battleOutcome');
                const detailsDiv = document.getElementById('spinDetails');
                
                resultsDiv.style.display = 'block';
                
                // Show outcome
                let outcomeText = '';
                let outcomeColor = '';
                
                if (battle.result === 'attacker_wins') {
                    outcomeText = `🏆 ${battle.attacker.robot.name} Wins!`;
                    outcomeColor = '#4CAF50';
                } else if (battle.result === 'defender_wins') {
                    outcomeText = `🏆 ${battle.defender.robot.name} Wins!`;
                    outcomeColor = '#4CAF50';
                } else {
                    outcomeText = '🤝 Draw!';
                    outcomeColor = '#FFC107';
                }
                
                outcomeDiv.innerHTML = `<div style="color: ${outcomeColor};">${outcomeText}</div>`;
                
                // Show spin details
                detailsDiv.innerHTML = `
                    <div class="spin-result">
                        <h4>${battle.attacker.robot.name}</h4>
                        <div style="color: ${CombatSystem.getMoveColor(battle.attacker.spin.result.moveType)};">
                            ${CombatSystem.formatMoveText(battle.attacker.spin.result)}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">
                            Spin: ${battle.attacker.spin.spinValue}/96
                        </div>
                    </div>
                    <div class="spin-result">
                        <h4>${battle.defender.robot.name}</h4>
                        <div style="color: ${CombatSystem.getMoveColor(battle.defender.spin.result.moveType)};">
                            ${CombatSystem.formatMoveText(battle.defender.spin.result)}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">
                            Spin: ${battle.defender.spin.spinValue}/96
                        </div>
                    </div>
                `;
            },
            
            combatStats: {
                total: 0,
                attackerWins: 0,
                defenderWins: 0,
                draws: 0
            },
            
            updateCombatStats(battle) {
                this.combatStats.total++;
                
                if (battle.result === 'attacker_wins') {
                    this.combatStats.attackerWins++;
                } else if (battle.result === 'defender_wins') {
                    this.combatStats.defenderWins++;
                } else {
                    this.combatStats.draws++;
                }
                
                this.displayCombatStats();
            },
            
            displayCombatStats() {
                document.getElementById('totalBattles').textContent = this.combatStats.total;
                document.getElementById('attackerWins').textContent = this.combatStats.attackerWins;
                document.getElementById('defenderWins').textContent = this.combatStats.defenderWins;
                document.getElementById('draws').textContent = this.combatStats.draws;
            },
            
            runMultipleBattles(count) {
                const attackerSelect = document.getElementById('attackerSelect');
                const defenderSelect = document.getElementById('defenderSelect');
                
                if (!attackerSelect.value || !defenderSelect.value) {
                    alert('Please select both robots!');
                    return;
                }
                
                for (let i = 0; i < count; i++) {
                    const battle = CombatSystem.simulateBattle(attackerSelect.value, defenderSelect.value);
                    this.updateCombatStats(battle);
                }
                
                // Show the last battle result
                const lastBattle = CombatSystem.simulateBattle(attackerSelect.value, defenderSelect.value);
                this.displayBattleResults(lastBattle);
                this.updateCombatStats(lastBattle);
            },
            
            resetCombatStats() {
                this.combatStats = {
                    total: 0,
                    attackerWins: 0,
                    defenderWins: 0,
                    draws: 0
                };
                this.displayCombatStats();
                
                // Hide results
                document.getElementById('combatResults').style.display = 'none';
            },
            
            // Visual Data Disk Battle System
            lastBattleResult: null,
            
            async showVisualBattle() {
                if (!this.lastBattleResult) {
                    alert('Run a battle first to see the visual replay!');
                    return;
                }
                
                const modal = document.getElementById('diskBattleModal');
                modal.classList.add('active');
                
                await this.setupVisualBattle(this.lastBattleResult);
                this.startDiskAnimation();
                
                // Initialize the new spinning system
                this.initializeDiskSpinning();
            },
            
            closeDiskBattle() {
                const modal = document.getElementById('diskBattleModal');
                modal.classList.remove('active');
                
                // Reset disk states
                document.getElementById('attackerDisk').className = 'data-disk';
                document.getElementById('defenderDisk').className = 'data-disk';
                
                // Reset diamond pointer
                const diamond = document.getElementById('diamondPointer');
                diamond.className = 'diamond-shape';
                
                // Clean up sparks
                const sparksContainer = document.querySelector('.sparks-container');
                if (sparksContainer) {
                    sparksContainer.remove();
                }
                
                // Reset wheel animations (SVG and Image)
                const wheelElements = document.querySelectorAll('.disk-wheel svg, .disk-wheel .wheel-image');
                wheelElements.forEach(element => {
                    element.className = element.classList.contains('wheel-image') ? 'wheel-image' : '';
                    element.style.transform = 'rotate(0deg)';
                });
                
                // Clear wheel overlays
                const overlays = document.querySelectorAll('.wheel-overlay');
                overlays.forEach(overlay => {
                    overlay.innerHTML = '';
                    overlay.style.opacity = '0';
                });
                
                document.getElementById('diskBattleOutcome').style.display = 'none';
                document.getElementById('moveDetails').style.display = 'none';
                document.getElementById('continueBtn').style.display = 'none';
                
                // Hide respin button
                const respinContainer = document.getElementById('respinButtonContainer');
                if (respinContainer) {
                    respinContainer.style.display = 'none';
                }
                
                // Hide battle results section
                const battleResultsSection = document.getElementById('battleResultsSection');
                if (battleResultsSection) {
                    battleResultsSection.style.display = 'none';
                }
                
                // Hide live spin results
                const liveSpinResults = document.getElementById('liveSpinResults');
                if (liveSpinResults) {
                    liveSpinResults.style.display = 'none';
                }
            },
            
            // Respin Both Wheels (for testing/replay)
            respinBothWheels() {
                console.log(`\n🔄 ═══════════════════════════════════════`);
                console.log(`🔄 USER CLICKED RESPIN - STARTING FRESH BATTLE`);
                console.log(`🔄 ═══════════════════════════════════════`);
                
                // Validate diskSpinner and currentVisualBattle exist
                if (!this.diskSpinner) {
                    console.error('❌ diskSpinner not initialized!');
                    return;
                }
                
                if (!this.diskSpinner.currentVisualBattle) {
                    console.error('❌ No active battle to respin!');
                    return;
                }
                
                // Get both wheel elements and data maps
                const attackerWheel = document.getElementById('attackerWheel');
                const defenderWheel = document.getElementById('defenderWheel');
                
                if (!attackerWheel || !defenderWheel) {
                    console.error('❌ Wheel containers not found!', {attackerWheel, defenderWheel});
                    return;
                }
                
                const attackerElement = attackerWheel.querySelector('svg, img');
                const defenderElement = defenderWheel.querySelector('svg, img');
                
                if (!attackerElement || !defenderElement) {
                    console.error('❌ Wheel elements not found!', {attackerElement, defenderElement});
                    return;
                }
                
                const attackerDataMap = this.diskSpinner.generateDiskBlueprint(this.diskSpinner.currentVisualBattle.attacker.robot);
                const defenderDataMap = this.diskSpinner.generateDiskBlueprint(this.diskSpinner.currentVisualBattle.defender.robot);
                
                const topMoveDisplay = document.getElementById('top-move-display');
                const bottomMoveDisplay = document.getElementById('bottom-move-display');
                
                // Clear previous results
                console.log('   🧹 Clearing wheelResults:', this.diskSpinner.wheelResults);
                this.diskSpinner.wheelResults = {};
                console.log('   ✅ wheelResults cleared:', this.diskSpinner.wheelResults);
                
                // CRITICAL: Keep the battle results section visible but clear the winner display
                const battleResultsSection = document.getElementById('battleResultsSection');
                if (battleResultsSection) {
                    // Keep section visible so button remains accessible
                    battleResultsSection.style.display = 'block';
                    
                    // Clear the winner display content
                    const winnerText = document.getElementById('winnerText');
                    const winnerReason = document.getElementById('winnerReason');
                    if (winnerText) winnerText.textContent = '⏳ Spinning...';
                    if (winnerReason) winnerReason.textContent = 'Determining outcome...';
                    
                    // Clear move result displays
                    const attackerMoveName = document.getElementById('attackerMoveName');
                    const attackerMoveType = document.getElementById('attackerMoveType');
                    const attackerMovePower = document.getElementById('attackerMovePower');
                    const defenderMoveName = document.getElementById('defenderMoveName');
                    const defenderMoveType = document.getElementById('defenderMoveType');
                    const defenderMovePower = document.getElementById('defenderMovePower');
                    
                    if (attackerMoveName) attackerMoveName.textContent = 'Spinning...';
                    if (attackerMoveType) attackerMoveType.textContent = '-';
                    if (attackerMovePower) attackerMovePower.textContent = '-';
                    if (defenderMoveName) defenderMoveName.textContent = 'Spinning...';
                    if (defenderMoveType) defenderMoveType.textContent = '-';
                    if (defenderMovePower) defenderMovePower.textContent = '-';
                    
                    console.log('   🧹 Cleared previous battle results, keeping section visible');
                } else {
                    console.warn('   ⚠️ battleResultsSection not found!');
                }
                
                // Update spin counter and reset live results
                this.diskSpinner.updateSpinCounter();
                document.getElementById('attackerSpinResult').textContent = 'Spinning...';
                document.getElementById('attackerSpinType').textContent = '-';
                document.getElementById('attackerSpinPower').textContent = '-';
                document.getElementById('defenderSpinResult').textContent = 'Spinning...';
                document.getElementById('defenderSpinType').textContent = '-';
                document.getElementById('defenderSpinPower').textContent = '-';
                
                // Update displays
                if (topMoveDisplay) topMoveDisplay.textContent = 'Respinning...';
                if (bottomMoveDisplay) bottomMoveDisplay.textContent = 'Respinning...';
                
                console.log('   ✅ Starting respin for both wheels...');
                
                // Execute BOTH respins with slight delay to ensure animations restart properly
                this.diskSpinner.executeFullRespin(attackerElement, attackerDataMap, bottomMoveDisplay, 'attacker');
                
                // Small delay before starting second respin to ensure browser processes first one
                setTimeout(() => {
                    this.diskSpinner.executeFullRespin(defenderElement, defenderDataMap, topMoveDisplay, 'defender');
                }, 20);
            },
            
            // Initialize Data Disk Spinning System
            initializeDiskSpinning() {
                const topDisk = document.getElementById('top-disk');
                const bottomDisk = document.getElementById('bottom-disk');
                const spinButton = document.getElementById('spin-button');
                
                if (!topDisk || !bottomDisk || !spinButton) {
                    console.log('⚠️ Disk spinning elements not found');
                    return;
                }
                
                // Main battle function triggered by VS button click
                const startBattle = () => {
                    console.log('🎯 Starting Data Disk Battle!');
                    
                    // --- 1. Calculate Random Stopping Points ---
                    // Add 5 full rotations (5 * 360) to random degrees for better visual effect
                    const randomTopDegrees = Math.floor(Math.random() * 360) + (360 * 5);
                    const randomBottomDegrees = Math.floor(Math.random() * 360) + (360 * 5);
                    
                    console.log(`🔴 Top disk will stop at: ${randomTopDegrees}°`);
                    console.log(`🔵 Bottom disk will stop at: ${randomBottomDegrees}°`);
                    
                    // --- 2. Start the Visual Spin ---
                    // Find the actual wheel elements (SVG or IMG)
                    const topWheelElement = topDisk.querySelector('.disk-wheel svg, .disk-wheel img');
                    const bottomWheelElement = bottomDisk.querySelector('.disk-wheel svg, .disk-wheel img');
                    
                    if (topWheelElement && bottomWheelElement) {
                        topWheelElement.classList.add('spinning');
                        bottomWheelElement.classList.add('spinning');
                        
                        // Prevent button clicks during spin
                        spinButton.style.pointerEvents = 'none';
                        spinButton.style.opacity = '0.6';
                        spinButton.textContent = 'SPINNING...';
                        
                        // --- 3. Set Timer to Stop the Spin ---
                        // Let wheels spin for 3 seconds before stopping
                        setTimeout(() => {
                            // --- 4. Stop Animation and Set Final Position ---
                            
                            // Remove spinning class to stop infinite animation
                            topWheelElement.classList.remove('spinning');
                            bottomWheelElement.classList.remove('spinning');
                            
                            // Set final calculated random rotation
                            // Wheels will smoothly animate to final position
                            topWheelElement.style.transform = `rotate(${randomTopDegrees}deg)`;
                            bottomWheelElement.style.transform = `rotate(${randomBottomDegrees}deg)`;
                            
                            console.log('🎯 Disks stopped! Calculating battle results...');
                            
                            // Calculate which moves were selected based on final angles
                            setTimeout(() => {
                                this.calculateSpinResults(randomTopDegrees, randomBottomDegrees);
                                
                                // Re-enable button after results
                                spinButton.style.pointerEvents = 'auto';
                                spinButton.style.opacity = '1';
                                spinButton.textContent = 'VS';
                            }, 1000); // Wait for smooth rotation to finish
                            
                        }, 3000); // 3 seconds of spinning
                    }
                };
                
                // --- 5. Listen for VS Button Click ---
                spinButton.addEventListener('click', startBattle);
                console.log('✅ Data Disk spinning system initialized');
            },
            
            // Calculate which moves were selected based on final rotation angles
            calculateSpinResults(topAngle, bottomAngle) {
                // Convert angles to 0-360 range
                const topFinalAngle = topAngle % 360;
                const bottomFinalAngle = bottomAngle % 360;
                
                console.log(`🎯 Final angles - Top: ${topFinalAngle}°, Bottom: ${bottomFinalAngle}°`);
                
                // Show the results
                const outcomeDiv = document.getElementById('diskBattleOutcome');
                if (outcomeDiv) {
                    outcomeDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <h3>🎯 BATTLE RESULTS</h3>
                            <p>Opponent wheel stopped at: ${topFinalAngle.toFixed(1)}°</p>
                            <p>Your wheel stopped at: ${bottomFinalAngle.toFixed(1)}°</p>
                            <p style="color: #ffd93d; font-weight: bold;">Battle complete!</p>
                        </div>
                    `;
                    outcomeDiv.style.display = 'block';
                    
                    // Show continue button
                    const continueBtn = document.getElementById('continueBtn');
                    if (continueBtn) {
                        continueBtn.style.display = 'block';
                    }
                }
            },
            
            async setupVisualBattle(battle) {
                // Set robot names
                document.getElementById('attackerName').textContent = battle.attacker.robot.name;
                document.getElementById('defenderName').textContent = battle.defender.robot.name;
                
                // Load full robot data with attack lists
                const attackerRobot = await this.loadFullRobotData(battle.attacker.robot);
                const defenderRobot = await this.loadFullRobotData(battle.defender.robot);
                
                // Create disk wheels
                this.createDiskWheel('attackerWheel', attackerRobot);
                this.createDiskWheel('defenderWheel', defenderRobot);
                
                // Store battle result with full robot data
                this.currentVisualBattle = {
                    attacker: { robot: attackerRobot, spin: battle.attacker.spin },
                    defender: { robot: defenderRobot, spin: battle.defender.spin }
                };
            },
            
            async loadFullRobotData(robot) {
                console.log(`📥 Loading full data for robot: ${robot.id || robot.name}`);
                
                // If robot already has attack_lists_by_type, return it
                if (robot.attack_lists_by_type) {
                    console.log(`   ✅ Robot already has attack_lists_by_type`);
                    return robot;
                }
                
                // EMBEDDED DATA for Alaka-bot (to avoid CORS issues with file:// protocol)
                if (robot.id === 'alaka-bot') {
                    console.log(`   ✅ Using embedded data for alaka-bot`);
                    const alakabotData = {
                        attack_lists_by_type: {
                            basic: [
                                { attack_name: "Stillblind", attack_type: "Purple", attack_value: "★★★", attack_start_angle_deg: 0, attack_end_angle_deg: 89.9999 },
                                { attack_name: "Miss", attack_type: "Red", attack_value: "", attack_start_angle_deg: 90.0, attack_end_angle_deg: 104.9999 },
                                { attack_name: "Psychic", attack_type: "White", attack_value: 120, attack_start_angle_deg: 105.0, attack_end_angle_deg: 194.9999 },
                                { attack_name: "Psyshock", attack_type: "Purple", attack_value: "★★★★", attack_start_angle_deg: 195.0, attack_end_angle_deg: 284.9999 },
                                { attack_name: "Psycho Shift", attack_type: "Blue", attack_value: "", attack_start_angle_deg: 285.0, attack_end_angle_deg: 359.9999 }
                            ]
                        }
                    };
                    return { ...robot, ...alakabotData };
                }
                
                // For other robots, generate from their wheel if available
                if (robot.wheel && robot.wheel.length > 0) {
                    console.log(`   ✅ Generating attack_lists_by_type from robot.wheel (${robot.wheel.length} moves)`);
                    
                    // Calculate angles based on segment sizes
                    let currentAngle = 0;
                    const totalSize = robot.wheel.reduce((sum, move) => sum + move.size, 0);
                    const degreesPerSegment = 360 / totalSize;
                    
                    const attacks = robot.wheel.map((move) => {
                        const startAngle = currentAngle;
                        const endAngle = currentAngle + (move.size * degreesPerSegment) - 0.0001;
                        currentAngle = endAngle + 0.0001;
                        
                        return {
                            attack_name: move.moveName,
                            attack_type: move.moveType,
                            attack_value: move.damage || (move.stars ? '★'.repeat(move.stars) : ''),
                            attack_start_angle_deg: startAngle,
                            attack_end_angle_deg: endAngle
                        };
                    });
                    
                    console.log(`   📊 Generated ${attacks.length} attacks:`, attacks.map(a => `${a.attack_name}(${a.attack_start_angle_deg.toFixed(1)}°-${a.attack_end_angle_deg.toFixed(1)}°)`));
                    return {
                        ...robot,
                        attack_lists_by_type: { basic: attacks }
                    };
                }
                
                // Return original robot if no data available
                console.log(`   ⚠️ No wheel data available for ${robot.id}`);
                return robot;
            },
            
            createDiskWheel(wheelId, robot) {
                const wheel = document.getElementById(wheelId);
                wheel.innerHTML = '';
                
                // Check if robot has pre-made wheel images (like Alaka-bot)
                if (robot.id === 'alaka-bot') {
                    this.createImageBasedWheel(wheel, robot);
                } else {
                    // Create SVG Data Disk using precise mathematical segmentation
                    const svg = this.generateDataDiskSVG(robot);
                    wheel.appendChild(svg);
                }
            },
            
            // Create wheel using pre-made images
            createImageBasedWheel(wheelContainer, robot) {
                // Check for enhanced 3D rendered assets first
                const has3DAssets = this.check3DAssetAvailability(robot.id);
                
                const wheelImage = document.createElement('img');
                if (has3DAssets) {
                    // Use 3D rendered static disk
                    wheelImage.src = `Imag/Battle/example/3D_Renders/${robot.id}_standard_disk.png`;
                } else {
                    // Fallback to original wheel image
                    wheelImage.src = 'Imag/Battle/example/Attack_Wheels/basic_attack_wheel.png';
                }
                
                wheelImage.style.width = '100%';
                wheelImage.style.height = '100%';
                wheelImage.style.borderRadius = '50%';
                wheelImage.classList.add('wheel-image');
                
                // Store robot data for selection detection
                wheelImage.dataset.robotId = robot.id;
                wheelImage.dataset.has3D = has3DAssets;
                
                // Create overlay for highlighting selected moves
                const overlay = document.createElement('div');
                overlay.className = 'wheel-overlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.borderRadius = '50%';
                overlay.style.pointerEvents = 'none';
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.3s ease';
                
                wheelContainer.appendChild(wheelImage);
                wheelContainer.appendChild(overlay);
            },
            
            // Check if 3D rendered assets are available
            check3DAssetAvailability(robotId) {
                // This will check for the existence of 3D rendered assets
                // For now, return false until assets are generated
                return false; // Set to true once 3D assets are available
            },
            
            // Bulk import battle data from Battle-data directory
            async importBattleData() {
                console.log('🔄 Starting bulk import of battle data...');
                
                // List of all units to import (based on directory listing)
                const unitList = [
                    'Unit-001_UC_0', 'Unit-002_C_0', 'Unit-002_C_1', 'Unit-003_EX_0', 'Unit-003_EX_1', 'Unit-003_EX_2',
                    'Unit-004_UC_0', 'Unit-005_C_0', 'Unit-005_C_1', 'Unit-006_EX_0', 'Unit-006_EX_1', 'Unit-006_EX_2',
                    'Unit-007_UC_0', 'Unit-008_C_0', 'Unit-008_C_1', 'Unit-009_EX_0', 'Unit-009_EX_1', 'Unit-009_EX_2',
                    'Unit-010_UC_0', 'Unit-011_UC_0', 'Unit-011_UC_1', 'Unit-012_UC_0', 'Unit-012_UC_1', 'Unit-012_UC_2',
                    'Unit-013_C_0', 'Unit-014_UC_0', 'Unit-014_UC_1', 'Unit-015_C_0', 'Unit-015_C_1', 'Unit-015_C_2',
                    'Unit-019_C_0', 'Unit-020_C_0', 'Unit-020_C_1', 'Unit-021_C_0', 'Unit-023_C_0', 'Unit-024_UC_0',
                    'Unit-024_UC_1', 'Unit-025_R_0', 'Unit-025_UC_0', 'Unit-026_UC_0', 'Unit-026_UC_1', 'Unit-027_C_0',
                    'Unit-039_R_0', 'Unit-040_R_0', 'Unit-040_R_1', 'Unit-041_C_0', 'Unit-042_UC_0', 'Unit-042_UC_1',
                    'Unit-050_UC_0', 'Unit-052_R_0', 'Unit-054_UC_0', 'Unit-056_C_0', 'Unit-058_R_0', 'Unit-059_EX_0',
                    'Unit-059_EX_1', 'Unit-060_C_0', 'Unit-061_UC_0', 'Unit-061_UC_1', 'Unit-062_R_0', 'Unit-062_R_1',
                    'Unit-062_R_2', 'Unit-063_R_0', 'Unit-065_EX_0', 'Unit-065_EX_1', 'Unit-065_EX_2', 'Unit-066_C_0',
                    'Unit-068_R_0', 'Unit-068_R_1', 'Unit-068_R_2', 'Unit-069_UC_0', 'Unit-072_UC_0', 'Unit-072_UC_1',
                    'Unit-073_R_0', 'Unit-073_R_1', 'Unit-074_C_0', 'Unit-075_C_0', 'Unit-075_C_1', 'Unit-076_UC_0',
                    'Unit-076_UC_1', 'Unit-077_UC_0', 'Unit-078_R_0', 'Unit-078_R_1', 'Unit-079_R_0', 'Unit-081_C_0',
                    'Unit-082_R_0', 'Unit-082_R_1', 'Unit-084_C_0', 'Unit-092_R_0', 'Unit-093_UC_0', 'Unit-093_UC_1',
                    'Unit-094_EX_0', 'Unit-094_EX_1', 'Unit-094_EX_2', 'Unit-095_R_0', 'Unit-096_C_0', 'Unit-097_R_0',
                    'Unit-097_R_1', 'Unit-100_UC_0', 'Unit-101_R_0', 'Unit-101_R_1', 'Unit-102_C_0', 'Unit-103_UC_0',
                    'Unit-103_UC_1', 'Unit-109_C_0', 'Unit-110_UC_0', 'Unit-110_UC_1', 'Unit-111_C_0', 'Unit-112_UC_0',
                    'Unit-114_UC_0', 'Unit-115_EX_0', 'Unit-118_UC_0', 'Unit-119_UC_0', 'Unit-119_UC_1', 'Unit-123_UC_0',
                    'Unit-125_R_0', 'Unit-126_R_0', 'Unit-127_EX_0', 'Unit-127_R_0', 'Unit-128_C_0', 'Unit-129_C_0',
                    'Unit-130_EX_0', 'Unit-130_EX_1', 'Unit-130_R_0', 'Unit-130_R_1', 'Unit-131_R_0', 'Unit-133_R_0',
                    'Unit-134_R_0', 'Unit-134_R_1', 'Unit-135_R_0', 'Unit-135_R_1', 'Unit-136_R_0', 'Unit-136_R_1',
                    'Unit-138_UC_0', 'Unit-139_R_0', 'Unit-139_R_1', 'Unit-140_UC_0', 'Unit-142_EX_0', 'Unit-142_R_0',
                    'Unit-143_EX_0', 'Unit-144_EX_0', 'Unit-145_EX_0', 'Unit-146_EX_0', 'Unit-147_R_0', 'Unit-148_R_0',
                    'Unit-148_R_1', 'Unit-149_EX_0', 'Unit-149_EX_1', 'Unit-149_EX_2', 'Unit-150_EX_0', 'Unit-151_EX_0'
                ];
                
                let importedCount = 0;
                let errorCount = 0;
                
                for (const unitId of unitList) {
                    try {
                        await this.importSingleUnit(unitId);
                        importedCount++;
                        console.log(`✅ Imported ${unitId} (${importedCount}/${unitList.length})`);
                    } catch (error) {
                        console.error(`❌ Failed to import ${unitId}:`, error);
                        errorCount++;
                    }
                }
                
                console.log(`🎉 Bulk import complete! ${importedCount} units imported, ${errorCount} errors`);
                
                // Refresh robot selectors if combat tester is open
                if (document.getElementById('combatTesterModal').classList.contains('active')) {
                    this.populateRobotSelectors();
                }
            },
            
            // Import a single unit from JSON data
            async importSingleUnit(unitId) {
                const jsonPath = `Imag/Battle/Battle-data/${unitId}/${unitId}_attack_JSON.json`;
                
                try {
                    const response = await fetch(jsonPath);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const unitData = await response.json();
                    
                    // Convert to our robot database format
                    const robot = this.convertUnitToRobot(unitId, unitData);
                    
                    // Add to database
                    RobotDatabase.addRobot(robot);
                    
                } catch (error) {
                    throw new Error(`Failed to load ${jsonPath}: ${error.message}`);
                }
            },
            
            // Convert unit JSON data to robot database format
            convertUnitToRobot(unitId, unitData) {
                // Parse rarity from unit ID (e.g., Unit-001_UC_0 -> UC)
                const rarityMatch = unitId.match(/_([A-Z]+)_/);
                const rarity = rarityMatch ? rarityMatch[1] : 'C';
                
                // Determine role based on MP and rarity
                const mp = unitData.base_movement_points || 2;
                let role = 'Vanguard'; // Default
                if (mp === 3) role = 'Scout';
                else if (mp === 1) role = 'Sentinel';
                else if (rarity === 'EX') role = 'Vanguard';
                
                // Convert moves from basic attack list
                const wheel = [];
                if (unitData.attack_lists_by_type && unitData.attack_lists_by_type.basic) {
                    unitData.attack_lists_by_type.basic.forEach(attack => {
                        const move = {
                            moveName: attack.attack_name,
                            moveType: this.normalizeAttackType(attack.attack_type),
                            size: attack.attack_wheel_size,
                            effect: attack.attack_ability || 'None'
                        };
                        
                        // Add damage or stars
                        if (attack.attack_value && !isNaN(attack.attack_value)) {
                            move.damage = parseInt(attack.attack_value);
                        } else if (attack.attack_value && attack.attack_value.includes('★')) {
                            move.stars = attack.attack_value.length;
                        }
                        
                        wheel.push(move);
                    });
                }
                
                // Create robot object
                return {
                    id: unitId.toLowerCase().replace(/_/g, '-'),
                    name: unitData.pokemon_name || unitId,
                    rarity: rarity,
                    mp: mp,
                    role: role,
                    type: unitData.pokemon_type || 'Normal',
                    description: `${rarity} rarity unit with ${mp} movement points.`,
                    image: `Imag/Battle/Battle-data/${unitId}/${unitId.split('_')[0]}_sprite.png`,
                    ability: {
                        name: 'Unit Ability',
                        description: 'Special unit ability.'
                    },
                    wheel: wheel,
                    statusWheels: this.convertStatusWheels(unitData.attack_lists_by_type),
                    stats: this.generateStats(rarity, mp)
                };
            },
            
            // Normalize attack type to our format
            normalizeAttackType(type) {
                const typeMap = {
                    'Purple': 'Purple',
                    'White': 'White', 
                    'Blue': 'Blue',
                    'Gold': 'Gold',
                    'Red': 'Red',
                    'purple': 'Purple',
                    'white': 'White',
                    'blue': 'Blue',
                    'gold': 'Gold',
                    'red': 'Red'
                };
                return typeMap[type] || 'White';
            },
            
            // Convert status wheels if they exist
            convertStatusWheels(attackLists) {
                const statusWheels = {};
                
                // Convert each status condition
                ['poisoned', 'paralyzed', 'burned', 'frozen', 'asleep', 'confused'].forEach(status => {
                    if (attackLists[status]) {
                        statusWheels[status] = this.convertWheelMoves(attackLists[status]);
                    }
                });
                
                return statusWheels;
            },
            
            // Convert wheel moves for status conditions
            convertWheelMoves(moveList) {
                const wheel = [];
                moveList.forEach(attack => {
                    const move = {
                        moveName: attack.attack_name,
                        moveType: this.normalizeAttackType(attack.attack_type),
                        size: attack.attack_wheel_size,
                        effect: attack.attack_ability || 'None'
                    };
                    
                    if (attack.attack_value && !isNaN(attack.attack_value)) {
                        move.damage = parseInt(attack.attack_value);
                    } else if (attack.attack_value && attack.attack_value.includes('★')) {
                        move.stars = attack.attack_value.length;
                    }
                    
                    wheel.push(move);
                });
                return wheel;
            },
            
            // Generate stats based on rarity and MP
            generateStats(rarity, mp) {
                const baseStats = { hp: 80, attack: 70, defense: 60, speed: 50 };
                
                // Rarity multipliers
                const rarityBonus = {
                    'C': 1.0,
                    'UC': 1.1, 
                    'R': 1.25,
                    'EX': 1.5
                };
                
                const multiplier = rarityBonus[rarity] || 1.0;
                
                return {
                    hp: Math.round(baseStats.hp * multiplier),
                    attack: Math.round(baseStats.attack * multiplier),
                    defense: Math.round(baseStats.defense * multiplier),
                    speed: Math.round(baseStats.speed * multiplier * (mp / 2))
                };
            },
            
            // Data Disk Generator - Precise Mathematical Segmentation
            generateDataDiskSVG(robot) {
                const size = 280; // SVG viewBox size
                const radius = 130; // Disk radius
                const centerX = size / 2;
                const centerY = size / 2;
                
                // Create SVG element
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
                svg.style.borderRadius = '50%';
                
                let currentAngle = 0; // Start at top (12 o'clock)
                
                // Generate segments using exact formula: Segment Angle = (Move Size / 96) * 360
                robot.wheel.forEach((segment, index) => {
                    const segmentAngle = (segment.size / 96) * 360;
                    
                    // Create pie slice path
                    const path = this.createPieSlice(centerX, centerY, radius, currentAngle, segmentAngle);
                    
                    // Set segment color
                    const color = CombatSystem.getMoveColor(segment.moveType);
                    path.setAttribute('fill', color);
                    path.setAttribute('stroke', '#2c3e50');
                    path.setAttribute('stroke-width', '1');
                    
                    // Store segment data for selection
                    path.dataset.segmentIndex = index;
                    path.dataset.moveName = segment.moveName;
                    path.dataset.moveType = segment.moveType;
                    path.classList.add('svg-segment');
                    
                    svg.appendChild(path);
                    
                    // Add move text
                    const textAngle = currentAngle + (segmentAngle / 2);
                    const textRadius = radius * 0.7;
                    const textX = centerX + textRadius * Math.cos((textAngle - 90) * Math.PI / 180);
                    const textY = centerY + textRadius * Math.sin((textAngle - 90) * Math.PI / 180);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('font-size', '10');
                    text.setAttribute('font-weight', '700');
                    text.setAttribute('fill', segment.moveType === 'White' ? '#000' : '#fff');
                    text.setAttribute('stroke', segment.moveType === 'White' ? '#fff' : '#000');
                    text.setAttribute('stroke-width', '0.5');
                    text.textContent = segment.moveName;
                    
                    // Rotate text to follow curve
                    if (segmentAngle > 30) { // Only rotate text for larger segments
                        text.setAttribute('transform', `rotate(${textAngle}, ${textX}, ${textY})`);
                    }
                    
                    svg.appendChild(text);
                    
                    // Add damage/star values
                    if (segment.damage || segment.stars) {
                        const valueRadius = radius * 0.5;
                        const valueX = centerX + valueRadius * Math.cos((textAngle - 90) * Math.PI / 180);
                        const valueY = centerY + valueRadius * Math.sin((textAngle - 90) * Math.PI / 180);
                        
                        const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        valueText.setAttribute('x', valueX);
                        valueText.setAttribute('y', valueY);
                        valueText.setAttribute('text-anchor', 'middle');
                        valueText.setAttribute('dominant-baseline', 'middle');
                        valueText.setAttribute('font-size', '8');
                        valueText.setAttribute('font-weight', '600');
                        valueText.setAttribute('fill', segment.moveType === 'White' ? '#000' : '#fff');
                        valueText.setAttribute('stroke', segment.moveType === 'White' ? '#fff' : '#000');
                        valueText.setAttribute('stroke-width', '0.3');
                        
                        if (segment.damage) {
                            valueText.textContent = segment.damage;
                        } else if (segment.stars) {
                            valueText.textContent = '★'.repeat(segment.stars);
                        }
                        
                        svg.appendChild(valueText);
                    }
                    
                    currentAngle += segmentAngle;
                });
                
                // Add center circle
                const centerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerCircle.setAttribute('cx', centerX);
                centerCircle.setAttribute('cy', centerY);
                centerCircle.setAttribute('r', '25');
                centerCircle.setAttribute('fill', '#34495e');
                centerCircle.setAttribute('stroke', '#1a252f');
                centerCircle.setAttribute('stroke-width', '3');
                svg.appendChild(centerCircle);
                
                return svg;
            },
            
            // Create precise pie slice using SVG path
            createPieSlice(centerX, centerY, radius, startAngle, segmentAngle) {
                const startAngleRad = (startAngle - 90) * Math.PI / 180; // -90 to start at top
                const endAngleRad = (startAngle + segmentAngle - 90) * Math.PI / 180;
                
                const x1 = centerX + radius * Math.cos(startAngleRad);
                const y1 = centerY + radius * Math.sin(startAngleRad);
                const x2 = centerX + radius * Math.cos(endAngleRad);
                const y2 = centerY + radius * Math.sin(endAngleRad);
                
                const largeArcFlag = segmentAngle > 180 ? 1 : 0;
                
                const pathData = [
                    `M ${centerX} ${centerY}`, // Move to center
                    `L ${x1} ${y1}`, // Line to start point
                    `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`, // Arc to end point
                    'Z' // Close path
                ].join(' ');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                
                return path;
            },
            
            // --- DISK BLUEPRINTS FOR MOVE DETECTION ---
            // Generate move segments based on robot wheel data (96 segments total)
            generateDiskBlueprint(robot) {
                const moves = [];
                
                console.log(`🔍 Generating blueprint for robot:`, robot.id || robot.name);
                console.log(`   Has attack_lists_by_type?`, !!robot.attack_lists_by_type);
                
                // Check if robot has attack_lists_by_type (like Alaka-bot)
                if (robot.attack_lists_by_type && robot.attack_lists_by_type.basic) {
                    // Use the actual attack data from JSON
                    const attacks = robot.attack_lists_by_type.basic;
                    
                    console.log(`   ✅ Found ${attacks.length} attacks in attack_lists_by_type.basic`);
                    
                    for (const attack of attacks) {
                        moves.push({
                            name: attack.attack_name,
                            type: attack.attack_type.toLowerCase(),
                            damage: typeof attack.attack_value === 'number' ? attack.attack_value : null,
                            stars: typeof attack.attack_value === 'string' && attack.attack_value.includes('★') ? attack.attack_value : null,
                            start: attack.attack_start_angle_deg,
                            end: attack.attack_end_angle_deg,
                            ability: attack.attack_ability
                        });
                    }
                    
                    console.log(`✅ Loaded ${moves.length} moves from attack_lists_by_type for ${robot.id}`);
                    return moves;
                }
                
                console.warn(`⚠️ No attack_lists_by_type found for ${robot.id || robot.name}, using fallback`);
                
                // Fallback: 96-segment wheel
                const segmentSize = 360 / 96; // 3.75 degrees per segment
                
                if (robot.wheel) {
                    // Use actual wheel data from robot
                    for (let i = 0; i < 96; i++) {
                        const startAngle = i * segmentSize;
                        const endAngle = (i + 1) * segmentSize;
                        const move = robot.wheel[i] || { name: 'Miss', type: 'red', damage: 0 };
                        
                        moves.push({
                            name: move.name,
                            type: move.type,
                            damage: move.damage,
                            start: startAngle,
                            end: endAngle,
                            segment: i
                        });
                    }
                } else {
                    // Fallback for robots without wheel data
                    const defaultMoves = robot.moves || [
                        { name: 'Attack', type: 'white', damage: 50 },
                        { name: 'Special', type: 'purple', damage: 0 },
                        { name: 'Miss', type: 'red', damage: 0 }
                    ];
                    
                    const segmentsPerMove = Math.floor(96 / defaultMoves.length);
                    for (let i = 0; i < 96; i++) {
                        const moveIndex = Math.floor(i / segmentsPerMove) % defaultMoves.length;
                        const move = defaultMoves[moveIndex];
                        const startAngle = i * segmentSize;
                        const endAngle = (i + 1) * segmentSize;
                        
                        moves.push({
                            name: move.name,
                            type: move.type,
                            damage: move.damage,
                            start: startAngle,
                            end: endAngle,
                            segment: i
                        });
                    }
                }
                
                return moves;
            },

            startDiskAnimation() {
                console.log('═══════════════════════════════════════');
                console.log('🎯 THREE-PHASE BATTLE SYSTEM - START');
                console.log('═══════════════════════════════════════');
                
                // Get wheel elements
                const attackerWheel = document.getElementById('attackerWheel');
                const defenderWheel = document.getElementById('defenderWheel');
                const attackerElement = attackerWheel.querySelector('svg, img');
                const defenderElement = defenderWheel.querySelector('svg, img');
                
                if (!attackerElement || !defenderElement) {
                    console.error('❌ FATAL: Wheel elements not found');
                    return;
                }
                
                console.log('✅ Wheel elements located');
                
                // ═══════════════════════════════════════════════════════
                // PHASE 1: THE BLUEPRINT (Defining the Battlefield)
                // ═══════════════════════════════════════════════════════
                console.log('\n📋 PHASE 1: Creating Data Maps...');
                
                const attackerDataMap = this.generateDiskBlueprint(this.currentVisualBattle.attacker.robot);
                const defenderDataMap = this.generateDiskBlueprint(this.currentVisualBattle.defender.robot);
                
                console.log(`✅ Attacker Data Map: ${attackerDataMap.length} move segments`);
                console.log(`   First 10 segments:`, attackerDataMap.slice(0, 10).map(m => `${m.name}(${m.start}°-${m.end}°)`));
                console.log(`✅ Defender Data Map: ${defenderDataMap.length} move segments`);
                console.log(`   First 10 segments:`, defenderDataMap.slice(0, 10).map(m => `${m.name}(${m.start}°-${m.end}°)`));
                
                // Initialize battle state
                this.wheelResults = {};
                this.spinCounter = 0; // Track number of spins
                
                // Show and reset live results display
                this.showLiveSpinResults();
                this.resetLiveSpinResults();
                
                // Get display elements
                const topMoveDisplay = document.getElementById('top-move-display');
                const bottomMoveDisplay = document.getElementById('bottom-move-display');
                
                // ═══════════════════════════════════════════════════════
                // PHASE 2: THE ACTION (The Spin and Decide Sequence)
                // ═══════════════════════════════════════════════════════
                console.log('\n🎮 PHASE 2: Initiating Battle...');
                
                // Instruction 1A: Start the Visual Spin
                console.log('🌀 Starting visual spin for BOTH wheels...');
                
                // Clear any previous segment highlights
                [attackerElement, defenderElement].forEach(wheel => {
                    const paths = wheel.querySelectorAll('path');
                    paths.forEach(path => {
                        path.style.filter = '';
                        path.style.strokeWidth = '';
                        path.style.stroke = '';
                    });
                });
                console.log('✅ Previous highlights cleared');
                
                // CRITICAL: Disable transition BEFORE adding spinning class
                attackerElement.style.transition = 'none';
                defenderElement.style.transition = 'none';
                
                // Force reflow to ensure transition is disabled
                attackerElement.offsetHeight;
                defenderElement.offsetHeight;
                
                // Now add spinning class for animation
                attackerElement.classList.add('spinning');
                defenderElement.classList.add('spinning');
                
                console.log('✅ Transition disabled, spinning class added');
                
                if (topMoveDisplay) topMoveDisplay.textContent = 'Spinning...';
                if (bottomMoveDisplay) bottomMoveDisplay.textContent = 'Spinning...';
                
                this.createSparksEffect();
                
                // Instruction 1B: Set Independent Timers (LONGER SPINS - 5-8 seconds)
                const attackerTimer = 5000 + Math.random() * 3000; // 5-8 seconds
                const defenderTimer = 5000 + Math.random() * 3000; // 5-8 seconds
                
                console.log(`⏱️ Attacker timer: ${(attackerTimer/1000).toFixed(1)}s`);
                console.log(`⏱️ Defender timer: ${(defenderTimer/1000).toFixed(1)}s`);
                console.log('✅ Staggered timers set - wheels will stop independently');
                
                // Instruction 2: Execute the "Decide" Function when timer expires
                setTimeout(() => {
                    console.log(`⏰ ATTACKER TIMER EXPIRED - Calling decideFunction`);
                    try {
                        this.decideFunction(attackerElement, attackerDataMap, bottomMoveDisplay, 'attacker');
                    } catch (error) {
                        console.error(`❌ ERROR in attacker decideFunction:`, error);
                        // Emergency stop
                        attackerElement.className = '';
                        attackerElement.style.animation = 'none';
                        if (bottomMoveDisplay) bottomMoveDisplay.textContent = 'Error!';
                    }
                    
                    // Failsafe: Force stop after 2 seconds if still spinning
                    setTimeout(() => {
                        if (attackerElement.classList.contains('spinning')) {
                            console.warn(`⚠️ FAILSAFE: Force stopping attacker wheel`);
                            attackerElement.className = '';
                            attackerElement.style.animation = 'none';
                        }
                    }, 2000);
                }, attackerTimer);
                
                setTimeout(() => {
                    console.log(`⏰ DEFENDER TIMER EXPIRED - Calling decideFunction`);
                    try {
                        this.decideFunction(defenderElement, defenderDataMap, topMoveDisplay, 'defender');
                    } catch (error) {
                        console.error(`❌ ERROR in defender decideFunction:`, error);
                        // Emergency stop
                        defenderElement.className = '';
                        defenderElement.style.animation = 'none';
                        if (topMoveDisplay) topMoveDisplay.textContent = 'Error!';
                    }
                    
                    // Failsafe: Force stop after 2 seconds if still spinning
                    setTimeout(() => {
                        if (defenderElement.classList.contains('spinning')) {
                            console.warn(`⚠️ FAILSAFE: Force stopping defender wheel`);
                            defenderElement.className = '';
                            defenderElement.style.animation = 'none';
                        }
                    }, 2000);
                }, defenderTimer);
            },
            
            // ═══════════════════════════════════════════════════════
            // PHASE 2: THE "DECIDE" FUNCTION - DEFINITIVE BLUEPRINT
            // ═══════════════════════════════════════════════════════
            // CORE MANDATE: The Pointer is Law. What you see is what you get.
            // The visual outcome on screen MUST match the reported text result.
            decideFunction(wheelElement, dataMap, display, player) {
                console.log(`\n🎲 PHASE 2: DECIDE FUNCTION for ${player}`);
                console.log(`   📜 DEFINITIVE BLUEPRINT: Stop wheel first, then read pointer`);
                
                // Safety check: Ensure wheel element exists
                if (!wheelElement) {
                    console.error(`❌ ERROR: wheelElement is null for ${player}`);
                    return;
                }
                
                if (!dataMap || dataMap.length === 0) {
                    console.error(`❌ ERROR: dataMap is invalid for ${player}`);
                    // Emergency stop
                    wheelElement.classList.remove('spinning');
                    wheelElement.style.animation = 'none';
                    return;
                }
                
                // ═══════════════════════════════════════════════════════
                // STEP 1: STOP THE WHEEL AT A RANDOM FINAL ROTATION
                // ═══════════════════════════════════════════════════════
                // Generate a random final rotation (0-360 degrees)
                // Add 5 full rotations for visual drama
                const randomAngle = Math.floor(Math.random() * 360);
                const finalRotation = (360 * 5) + randomAngle;
                
                console.log(`   🎯 STEP 1: Stopping wheel at final rotation`);
                console.log(`   📐 Random angle: ${randomAngle}°`);
                console.log(`   🔄 Final rotation (with 5 spins): ${finalRotation}°`);
                
                // Stop the spinning animation
                wheelElement.classList.remove('spinning');
                wheelElement.style.animation = 'none';
                wheelElement.style.animationPlayState = 'paused';
                
                // Set the final position
                wheelElement.style.transform = `rotate(${finalRotation}deg)`;
                wheelElement.style.transition = 'transform 1s ease-out';
                
                // Force browser reflow
                void wheelElement.offsetHeight;
                
                console.log(`   ✅ Wheel stopped at ${finalRotation}°`);
                
                // ═══════════════════════════════════════════════════════
                // STEP 2: CALCULATE WHAT MOVE IS AT THE POINTER
                // ═══════════════════════════════════════════════════════
                // THE BULLETPROOF FORMULA:
                // resultAngle = (360 + pointerPosition - finalRotation) % 360
                //
                // This tells us which segment of the ORIGINAL, UN-ROTATED wheel
                // is now sitting under the FIXED pointer.
                
                let pointerPosition;
                if (player === 'defender') {
                    // OPPONENT (Top Wheel): Pointer at bottom (6 o'clock = 180°)
                    pointerPosition = 180;
                    console.log(`   🎯 OPPONENT - Pointer fixed at BOTTOM (180°)`);
                } else {
                    // PLAYER (Bottom Wheel): Pointer at top (12 o'clock = 0°)
                    pointerPosition = 0;
                    console.log(`   🎯 PLAYER - Pointer fixed at TOP (0°)`);
                }
                
                // Apply the definitive formula
                const normalizedRotation = finalRotation % 360;
                const resultAngle = (360 + pointerPosition - normalizedRotation) % 360;
                
                console.log(`   🎯 STEP 2: Calculating pointer reading`);
                console.log(`   📊 Formula: (360 + ${pointerPosition} - ${normalizedRotation}) % 360`);
                console.log(`   📍 Result Angle: ${resultAngle.toFixed(1)}°`);
                console.log(`   ✅ This is the segment from the original wheel now at the pointer`);
                
                // ═══════════════════════════════════════════════════════
                // STEP 3: LOOK UP THE MOVE IN THE DATA MAP
                // ═══════════════════════════════════════════════════════
                console.log(`   🎯 STEP 3: Consulting Data Map...`);
                
                // DEBUG: Show moves near this angle
                console.log(`   🔍 DEBUG: Moves near ${resultAngle.toFixed(1)}°:`);
                for (const move of dataMap) {
                    const distance = Math.min(
                        Math.abs(move.start - resultAngle),
                        Math.abs(move.end - resultAngle),
                        Math.abs((move.start + move.end) / 2 - resultAngle)
                    );
                    if (distance < 30) {
                        console.log(`      - ${move.name}: ${move.start}° - ${move.end}°`);
                    }
                }
                
                const selectedMove = this.consultBlueprint(resultAngle, dataMap);
                
                console.log(`   ✅ FINAL VERDICT: "${selectedMove.name}" (${selectedMove.type})`);
                console.log(`   📊 Move segment: ${selectedMove.start}° - ${selectedMove.end}°`);
                console.log(`   ✅ WYSIWYG: Visual and logical results are synchronized`);
                
                // ═══════════════════════════════════════════════════════
                // STEP 4: UPDATE DISPLAY AND RECORD RESULT
                // ═══════════════════════════════════════════════════════
                const displayText = `${selectedMove.name} (${selectedMove.type.toUpperCase()})`;
                if (display) {
                    display.textContent = displayText;
                }
                console.log(`   📺 Display updated: "${displayText}"`);
                
                // Store the result
                this.wheelResults[player] = selectedMove;
                console.log(`   💾 Result stored for ${player}`);
                
                // Update live spin results
                this.updateLiveSpinResult(player, selectedMove);
                
                // Check if battle is complete
                console.log(`   🔍 Checking for battle completion...`);
                this.checkForBattleCompletion();
            },
            
            // Show Respin Button (Testing Mode)
            showRespinButton(wheelElement, dataMap, display, player) {
                const respinContainer = document.getElementById('respinButtonContainer');
                const respinBtn = document.getElementById('respinBtn');
                const respinMessage = document.getElementById('respinMessage');
                
                if (!respinContainer || !respinBtn) {
                    console.error('❌ Respin button elements not found');
                    return;
                }
                
                // Update message to indicate BOTH wheels will respin
                respinMessage.textContent = `${player.toUpperCase()} wheel landed on boundary line - Click to respin BOTH wheels`;
                
                // Show the button
                respinContainer.style.display = 'block';
                
                console.log(`   🔘 Respin button shown (triggered by ${player})`);
                
                // Remove any existing click handlers by cloning
                const newBtn = respinBtn.cloneNode(true);
                newBtn.id = 'respinBtn'; // Ensure ID is preserved
                respinBtn.parentNode.replaceChild(newBtn, respinBtn);
                
                // Add click handler to respin BOTH wheels
                newBtn.addEventListener('click', () => {
                    console.log(`\n🔄 ═══════════════════════════════════════`);
                    console.log(`🔄 USER CLICKED RESPIN - STARTING FRESH BATTLE`);
                    console.log(`🔄 ═══════════════════════════════════════`);
                    
                    // Hide the button
                    respinContainer.style.display = 'none';
                    
                    // Get both wheel elements and data maps
                    const attackerWheel = document.getElementById('attackerWheel');
                    const defenderWheel = document.getElementById('defenderWheel');
                    const attackerElement = attackerWheel.querySelector('svg, img');
                    const defenderElement = defenderWheel.querySelector('svg, img');
                    
                    const attackerDataMap = this.generateDiskBlueprint(this.currentVisualBattle.attacker.robot);
                    const defenderDataMap = this.generateDiskBlueprint(this.currentVisualBattle.defender.robot);
                    
                    const topMoveDisplay = document.getElementById('top-move-display');
                    const bottomMoveDisplay = document.getElementById('bottom-move-display');
                    
                    // Clear previous results
                    console.log('   🧹 Clearing wheelResults:', this.wheelResults);
                    this.wheelResults = {};
                    console.log('   ✅ wheelResults cleared:', this.wheelResults);
                    
                    // CRITICAL: Keep the battle results section visible but clear the winner display
                    const battleResultsSection = document.getElementById('battleResultsSection');
                    if (battleResultsSection) {
                        // Keep section visible so button remains accessible
                        battleResultsSection.style.display = 'block';
                        
                        // Clear the winner display content
                        const winnerText = document.getElementById('winnerText');
                        const winnerReason = document.getElementById('winnerReason');
                        if (winnerText) winnerText.textContent = '⏳ Spinning...';
                        if (winnerReason) winnerReason.textContent = 'Determining outcome...';
                        
                        // Clear move result displays
                        const attackerMoveName = document.getElementById('attackerMoveName');
                        const attackerMoveType = document.getElementById('attackerMoveType');
                        const attackerMovePower = document.getElementById('attackerMovePower');
                        const defenderMoveName = document.getElementById('defenderMoveName');
                        const defenderMoveType = document.getElementById('defenderMoveType');
                        const defenderMovePower = document.getElementById('defenderMovePower');
                        
                        if (attackerMoveName) attackerMoveName.textContent = 'Spinning...';
                        if (attackerMoveType) attackerMoveType.textContent = '-';
                        if (attackerMovePower) attackerMovePower.textContent = '-';
                        if (defenderMoveName) defenderMoveName.textContent = 'Spinning...';
                        if (defenderMoveType) defenderMoveType.textContent = '-';
                        if (defenderMovePower) defenderMovePower.textContent = '-';
                        
                        console.log('   🧹 Cleared previous battle results, keeping section visible');
                    } else {
                        console.warn('   ⚠️ battleResultsSection not found!');
                    }
                    
                    // Update spin counter and reset live results
                    this.updateSpinCounter();
                    document.getElementById('attackerSpinResult').textContent = 'Spinning...';
                    document.getElementById('attackerSpinType').textContent = '-';
                    document.getElementById('attackerSpinPower').textContent = '-';
                    document.getElementById('defenderSpinResult').textContent = 'Spinning...';
                    document.getElementById('defenderSpinType').textContent = '-';
                    document.getElementById('defenderSpinPower').textContent = '-';
                    
                    // Update displays
                    if (topMoveDisplay) topMoveDisplay.textContent = 'Respinning...';
                    if (bottomMoveDisplay) bottomMoveDisplay.textContent = 'Respinning...';
                    
                    // Execute BOTH respins with slight delay to ensure animations restart properly
                    this.executeFullRespin(attackerElement, attackerDataMap, bottomMoveDisplay, 'attacker');
                    
                    // Small delay before starting second respin to ensure browser processes first one
                    setTimeout(() => {
                        this.executeFullRespin(defenderElement, defenderDataMap, topMoveDisplay, 'defender');
                    }, 20);
                });
            },
            
            // ═══════════════════════════════════════════════════════
            // BULLETPROOF RESPIN SYSTEM: Hard Reset with Scheduled Re-Engage
            // ═══════════════════════════════════════════════════════
            executeFullRespin(wheelElement, dataMap, display, player) {
                console.log(`\n🔄 BULLETPROOF RESPIN SEQUENCE for ${player}`);
                
                // ═══════════════════════════════════════════════════════
                // PHASE 1: THE "HARD RESET" (Execute Instantly)
                // ═══════════════════════════════════════════════════════
                console.log(`   💥 PHASE 1: HARD RESET - Wiping the slate clean...`);
                
                // Instruction 1: Kill the Transition
                console.log(`      Instruction 1: Killing transition and stopping current animation...`);
                wheelElement.style.transition = 'none';
                
                // Remove spinning class to stop animation
                wheelElement.classList.remove('spinning');
                
                // Clear inline animation styles that might interfere
                wheelElement.style.animation = '';
                wheelElement.style.animationName = '';
                
                // Clear any previous segment highlights
                const paths = wheelElement.querySelectorAll('path');
                paths.forEach(path => {
                    path.style.filter = '';
                    path.style.strokeWidth = '';
                    path.style.stroke = '';
                });
                
                console.log(`      ✅ Transition killed, animation stopped, highlights cleared`);
                
                // Instruction 2: Force a Browser Update
                console.log(`      Instruction 2: Forcing browser update...`);
                wheelElement.offsetHeight;
                void wheelElement.offsetWidth;
                getComputedStyle(wheelElement).transform; // Force style recalculation
                console.log(`      ✅ Browser update forced`);
                
                // Instruction 3: Schedule the Spin (CRITICAL - Separate Moment)
                console.log(`      Instruction 3: Scheduling Phase 2 & 3 in separate moment...`);
                console.log(`      ⏱️ 10ms delay to let browser process Hard Reset`);
                
                // CRITICAL: Place Phase 2 & 3 inside setTimeout for timing separation
                setTimeout(() => {
                    
                    // ═══════════════════════════════════════════════════════
                    // PHASE 2: THE "FULL RE-ENGAGE" (After Hard Reset)
                    // ═══════════════════════════════════════════════════════
                    console.log(`   🌀 PHASE 2: FULL RE-ENGAGE - Starting authentic spin...`);
                    
                    // Instruction 1: KEEP transition as 'none' during spin
                    // DO NOT restore transition yet - it will block the animation!
                    console.log(`      Instruction 1: Keeping transition disabled for spin...`);
                    wheelElement.style.transition = 'none'; // CRITICAL - must be 'none' for animation to work
                    
                    // Clear any transform to reset position
                    wheelElement.style.transform = 'rotate(0deg)';
                    
                    console.log(`      ✅ Transition kept disabled, transform reset`);
                    
                    // Force multiple reflows to ensure clean state
                    wheelElement.offsetHeight;
                    void wheelElement.offsetWidth;
                    
                    // Instruction 2: Start the Full Spin
                    console.log(`      Instruction 2: Adding .spinning class for full-speed animation...`);
                    wheelElement.classList.add('spinning');
                    
                    // Force reflow to ensure animation starts
                    wheelElement.offsetHeight;
                    void wheelElement.offsetWidth;
                    
                    console.log(`      ✅ FULL-SPEED SPIN ENGAGED!`);
                    console.log(`      🎯 Wheel is now spinning at FULL SPEED (identical to initial spin)`);
                    
                    // Instruction 3: Set the New Timer (4-7 seconds for LONG FAST SPIN)
                    const newTimer = 4000 + Math.random() * 3000; // 4-7 seconds
                    console.log(`      Instruction 3: New timer set to ${(newTimer/1000).toFixed(1)}s`);
                    console.log(`      🌀 At 0.1s per rotation (10 RPS), wheel will spin ${Math.floor(newTimer/100)} times!`);
                    
                    // ═══════════════════════════════════════════════════════
                    // PHASE 3: THE "NEW OUTCOME" (After Full Spin Duration)
                    // ═══════════════════════════════════════════════════════
                    console.log(`   ⏱️ PHASE 3: NEW OUTCOME - Timer running...`);
                    
                    // Instruction 1: Run the "Decide" Logic Again
                    setTimeout(() => {
                        console.log(`   🎯 PHASE 3: Timer expired - Running Decide Function...`);
                        this.decideFunction(wheelElement, dataMap, display, player);
                    }, newTimer);
                    
                    console.log(`   ✅ BULLETPROOF RESPIN COMPLETE - Full-speed spin in progress!`);
                    
                }, 10); // 10ms delay - gives browser time to process Hard Reset
                
                console.log(`   ✅ PHASE 1 complete - Phase 2 & 3 scheduled`);
            },
            
            // ═══════════════════════════════════════════════════════
            // CONSULT THE BLUEPRINT: Find which move contains the target angle
            // ═══════════════════════════════════════════════════════
            // DATA MAP STRUCTURE:
            // Each move has: { name, type, damage/stars, start, end, segment }
            // All angles are 0-360° from 12 o'clock position, clockwise
            // Example: { name: "Vine Whip", type: "white", damage: 60, start: 330, end: 345 }
            consultBlueprint(targetAngle, dataMap) {
                console.log(`   🔍 Checking target angle ${targetAngle.toFixed(1)}° against ${dataMap.length} move segments...`);
                
                // Normalize target angle to 0-360 range
                const normalizedTarget = ((targetAngle % 360) + 360) % 360;
                
                for (const move of dataMap) {
                    // Check if target angle is inside this move's segment (inclusive)
                    // Note: All segments should be within 0-360° and not wrap around
                    const isInsideSegment = (normalizedTarget >= move.start && normalizedTarget <= move.end);
                    
                    if (isInsideSegment) {
                        console.log(`   ✅ Found move "${move.name}" (${move.start}° - ${move.end}°)`);
                        return move;
                    }
                }
                
                // Fallback: If no exact match (shouldn't happen with proper data), find closest
                console.warn(`   ⚠️ No exact match for ${normalizedTarget.toFixed(1)}°, finding closest...`);
                let closest = dataMap[0];
                let minDist = 360;
                
                for (const move of dataMap) {
                    const midpoint = (move.start + move.end) / 2;
                    let dist = Math.abs(normalizedTarget - midpoint);
                    // Handle wraparound distance
                    if (dist > 180) dist = 360 - dist;
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closest = move;
                    }
                }
                
                console.log(`   ✅ Closest move: "${closest.name}" (distance: ${minDist.toFixed(1)}°)`);
                return closest;
            },
            
            // Check for Battle Completion
            checkForBattleCompletion() {
                const attackerDone = this.wheelResults.attacker !== undefined;
                const defenderDone = this.wheelResults.defender !== undefined;
                
                console.log(`   📊 Attacker complete: ${attackerDone}`);
                console.log(`   📊 Defender complete: ${defenderDone}`);
                
                if (attackerDone && defenderDone) {
                    console.log('\n═══════════════════════════════════════');
                    console.log('🎉 BATTLE COMPLETE!');
                    console.log('   Both wheels have valid moves');
                    console.log('═══════════════════════════════════════');
                    
                    setTimeout(() => {
                        this.displayFinalResults();
                    }, 1000);
                } else {
                    console.log(`   ⏳ Waiting for ${!attackerDone ? 'attacker' : 'defender'} to complete...`);
                }
            },
            
            // Display Final Battle Results
            displayFinalResults() {
                const attackerMove = this.wheelResults.attacker;
                const defenderMove = this.wheelResults.defender;
                
                console.log('\n📊 DISPLAYING FINAL RESULTS:');
                console.log(`   🔍 wheelResults object:`, this.wheelResults);
                console.log(`   🔍 Attacker move:`, attackerMove);
                console.log(`   🔍 Defender move:`, defenderMove);
                
                if (!attackerMove || !defenderMove) {
                    console.error('❌ ERROR: Missing move data in wheelResults!');
                    console.error(`   Attacker: ${attackerMove ? 'OK' : 'MISSING'}`);
                    console.error(`   Defender: ${defenderMove ? 'OK' : 'MISSING'}`);
                    return;
                }
                
                console.log(`   ${this.currentVisualBattle.attacker.robot.name}: ${attackerMove.name} (${attackerMove.type})`);
                console.log(`   ${this.currentVisualBattle.defender.robot.name}: ${defenderMove.name} (${defenderMove.type})`);
                
                // Populate Move Results
                document.getElementById('attackerMoveName').textContent = attackerMove.name;
                document.getElementById('attackerMoveType').textContent = attackerMove.type.toUpperCase();
                document.getElementById('attackerMovePower').textContent = attackerMove.damage || attackerMove.stars ? 
                    (attackerMove.damage ? `⚔️ ${attackerMove.damage}` : `⭐ ${attackerMove.stars}★`) : 'Special';
                
                document.getElementById('defenderMoveName').textContent = defenderMove.name;
                document.getElementById('defenderMoveType').textContent = defenderMove.type.toUpperCase();
                document.getElementById('defenderMovePower').textContent = defenderMove.damage || defenderMove.stars ? 
                    (defenderMove.damage ? `⚔️ ${defenderMove.damage}` : `⭐ ${defenderMove.stars}★`) : 'Special';
                
                // Determine Winner
                const winner = this.determineWinner(attackerMove, defenderMove);
                const winnerDisplay = document.getElementById('winnerDisplay');
                const winnerText = document.getElementById('winnerText');
                const winnerReason = document.getElementById('winnerReason');
                
                if (winner.result === 'attacker') {
                    winnerDisplay.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(16, 185, 129, 0.3) 100%)';
                    winnerDisplay.style.borderColor = 'rgba(34, 197, 94, 0.8)';
                    winnerText.style.color = '#4ade80';
                    winnerText.textContent = `🏆 ${this.currentVisualBattle.attacker.robot.name.toUpperCase()} WINS! 🏆`;
                    winnerReason.textContent = winner.reason;
                } else if (winner.result === 'defender') {
                    winnerDisplay.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%)';
                    winnerDisplay.style.borderColor = 'rgba(239, 68, 68, 0.8)';
                    winnerText.style.color = '#f87171';
                    winnerText.textContent = `🏆 ${this.currentVisualBattle.defender.robot.name.toUpperCase()} WINS! 🏆`;
                    winnerReason.textContent = winner.reason;
                } else {
                    winnerDisplay.style.background = 'linear-gradient(135deg, rgba(251, 191, 36, 0.3) 0%, rgba(245, 158, 11, 0.3) 100%)';
                    winnerDisplay.style.borderColor = 'rgba(251, 191, 36, 0.8)';
                    winnerText.style.color = '#fbbf24';
                    winnerText.textContent = '🤝 DRAW! 🤝';
                    winnerReason.textContent = winner.reason;
                }
                
                // Show the battle results section
                document.getElementById('battleResultsSection').style.display = 'block';
                console.log('✅ Results displayed on screen');
                
                const continueBtn = document.getElementById('continueBtn');
                if (continueBtn) {
                    continueBtn.style.display = 'block';
                    console.log('✅ Continue button shown');
                }
            },
            
            // Live Spin Results Management
            showLiveSpinResults() {
                const liveResults = document.getElementById('liveSpinResults');
                if (liveResults) {
                    liveResults.style.display = 'block';
                    console.log('✅ Live spin results display shown');
                }
            },
            
            resetLiveSpinResults() {
                document.getElementById('attackerSpinResult').textContent = 'Spinning...';
                document.getElementById('attackerSpinType').textContent = '-';
                document.getElementById('attackerSpinPower').textContent = '-';
                
                document.getElementById('defenderSpinResult').textContent = 'Spinning...';
                document.getElementById('defenderSpinType').textContent = '-';
                document.getElementById('defenderSpinPower').textContent = '-';
                
                this.spinCounter = 0;
                document.getElementById('spinCount').textContent = 'Initial Spin';
                
                console.log('✅ Live spin results reset');
            },
            
            updateLiveSpinResult(player, move) {
                console.log(`📊 Updating live result for ${player}: ${move.name}`);
                console.log(`   Move data:`, move);
                
                // Determine power display based on move type
                let powerText = '-';
                if (move.damage !== undefined && move.damage !== null) {
                    powerText = `⚔️ ${move.damage}`;
                } else if (move.stars !== undefined && move.stars !== null) {
                    powerText = `⭐ ${move.stars}★`;
                } else if (move.type.toLowerCase() === 'blue') {
                    powerText = 'Defensive';
                } else if (move.type.toLowerCase() === 'red') {
                    powerText = 'Miss';
                } else {
                    powerText = 'Special';
                }
                
                const resultEl = player === 'attacker' ? 'attackerSpinResult' : 'defenderSpinResult';
                const typeEl = player === 'attacker' ? 'attackerSpinType' : 'defenderSpinType';
                const powerEl = player === 'attacker' ? 'attackerSpinPower' : 'defenderSpinPower';
                
                const resultElement = document.getElementById(resultEl);
                const typeElement = document.getElementById(typeEl);
                const powerElement = document.getElementById(powerEl);
                
                if (resultElement) resultElement.textContent = move.name;
                if (typeElement) typeElement.textContent = move.type.toUpperCase();
                if (powerElement) powerElement.textContent = powerText;
                
                console.log(`✅ Live result updated - Power: ${powerText}`);
            },
            
            updateSpinCounter() {
                this.spinCounter++;
                const spinCountEl = document.getElementById('spinCount');
                if (spinCountEl) {
                    if (this.spinCounter === 0) {
                        spinCountEl.textContent = 'Initial Spin';
                    } else {
                        spinCountEl.textContent = `Respin #${this.spinCounter}`;
                    }
                }
            },
            
            // Determine Winner Based on Move Types (Pokémon Duel Rules)
            determineWinner(attackerMove, defenderMove) {
                // Priority hierarchy: Blue > Gold > Purple > White > Red (Miss)
                const typePriority = {
                    'blue': 5,
                    'gold': 4,
                    'purple': 3,
                    'white': 2,
                    'red': 1
                };
                
                const attackerType = attackerMove.type.toLowerCase();
                const defenderType = defenderMove.type.toLowerCase();
                const attackerPriority = typePriority[attackerType] || 0;
                const defenderPriority = typePriority[defenderType] || 0;
                
                console.log(`\n🎯 BATTLE RESOLUTION:`);
                console.log(`   Attacker: ${attackerMove.name} (${attackerType}) - Priority ${attackerPriority}`);
                console.log(`   Defender: ${defenderMove.name} (${defenderType}) - Priority ${defenderPriority}`);
                
                // Red (Miss) - Loses to everything except Red
                if (attackerType === 'red' && defenderType === 'red') {
                    return { result: 'draw', reason: 'Both moves missed!' };
                }
                if (attackerType === 'red') {
                    return { result: 'defender', reason: `${defenderMove.name} beats Miss!` };
                }
                if (defenderType === 'red') {
                    return { result: 'attacker', reason: `${attackerMove.name} beats Miss!` };
                }
                
                // Blue (Defensive) - Beats everything except Blue
                if (attackerType === 'blue' && defenderType === 'blue') {
                    return { result: 'draw', reason: 'Both defensive moves block each other!' };
                }
                if (attackerType === 'blue') {
                    return { result: 'attacker', reason: `${attackerMove.name} (Blue) blocks ${defenderMove.name}!` };
                }
                if (defenderType === 'blue') {
                    return { result: 'defender', reason: `${defenderMove.name} (Blue) blocks ${attackerMove.name}!` };
                }
                
                // Gold vs Purple - Gold wins
                if (attackerType === 'gold' && defenderType === 'purple') {
                    return { result: 'attacker', reason: `${attackerMove.name} (Gold) overpowers ${defenderMove.name} (Purple)!` };
                }
                if (attackerType === 'purple' && defenderType === 'gold') {
                    return { result: 'defender', reason: `${defenderMove.name} (Gold) overpowers ${attackerMove.name} (Purple)!` };
                }
                
                // Purple vs White - Purple wins
                if (attackerType === 'purple' && defenderType === 'white') {
                    return { result: 'attacker', reason: `${attackerMove.name} (Purple) outmaneuvers ${defenderMove.name} (White)!` };
                }
                if (attackerType === 'white' && defenderType === 'purple') {
                    return { result: 'defender', reason: `${defenderMove.name} (Purple) outmaneuvers ${attackerMove.name} (White)!` };
                }
                
                // White vs White or Gold vs Gold - Compare damage
                if ((attackerType === 'white' && defenderType === 'white') || 
                    (attackerType === 'gold' && defenderType === 'gold')) {
                    const attackerDamage = parseInt(attackerMove.damage) || 0;
                    const defenderDamage = parseInt(defenderMove.damage) || 0;
                    
                    if (attackerDamage > defenderDamage) {
                        return { result: 'attacker', reason: `${attackerMove.name} (${attackerDamage}) overpowers ${defenderMove.name} (${defenderDamage})!` };
                    } else if (defenderDamage > attackerDamage) {
                        return { result: 'defender', reason: `${defenderMove.name} (${defenderDamage}) overpowers ${attackerMove.name} (${attackerDamage})!` };
                    } else {
                        return { result: 'draw', reason: `Both moves deal ${attackerDamage} damage - Draw!` };
                    }
                }
                
                // Purple vs Purple - Compare stars
                if (attackerType === 'purple' && defenderType === 'purple') {
                    const attackerStars = parseInt(attackerMove.stars) || 0;
                    const defenderStars = parseInt(defenderMove.stars) || 0;
                    
                    if (attackerStars > defenderStars) {
                        return { result: 'attacker', reason: `${attackerMove.name} (${attackerStars}★) outshines ${defenderMove.name} (${defenderStars}★)!` };
                    } else if (defenderStars > attackerStars) {
                        return { result: 'defender', reason: `${defenderMove.name} (${defenderStars}★) outshines ${attackerMove.name} (${attackerStars}★)!` };
                    } else {
                        return { result: 'draw', reason: `Both moves have ${attackerStars}★ - Draw!` };
                    }
                }
                
                // Gold vs White - Gold wins
                if (attackerType === 'gold' && defenderType === 'white') {
                    return { result: 'attacker', reason: `${attackerMove.name} (Gold) beats ${defenderMove.name} (White)!` };
                }
                if (attackerType === 'white' && defenderType === 'gold') {
                    return { result: 'defender', reason: `${defenderMove.name} (Gold) beats ${attackerMove.name} (White)!` };
                }
                
                // Fallback - shouldn't reach here
                return { result: 'draw', reason: 'Unexpected outcome!' };
            },
            
            // DEFINITIVE spin and stop logic - directly targets wheel elements
            spinAndStopWheel(wheelElement, moves, display, duration, player) {
                console.log(`🎯 Starting spin for ${player} wheel`);
                
                // CRITICAL: Start the visual spin by adding .spinning class
                wheelElement.classList.add('spinning');
                
                // Update display if it exists
                if (display) {
                    display.textContent = 'Spinning...';
                }
                
                setTimeout(() => {
                    console.log(`🛑 Stopping ${player} wheel after ${(duration/1000).toFixed(1)}s`);
                    
                    // Calculate a random stop angle (0-359)
                    const randomAngle = Math.floor(Math.random() * 360);
                    const selectedMove = this.detectMove(randomAngle, moves);
                    
                    // CRITICAL: Stop the wheel visually FIRST
                    this.stopSpinWheel(wheelElement, randomAngle);
                    
                    if (selectedMove) {
                        // VALID MOVE: We landed on a segment!
                        const displayText = `${selectedMove.name} (${selectedMove.type})`;
                        if (display) display.textContent = displayText;
                        
                        this.wheelResults[player] = selectedMove;
                        console.log(`✅ ${player} selected: ${selectedMove.name}`);
                        
                        // Check if battle is complete
                        this.checkAuthenticBattleOutcome();
                        
                    } else {
                        // INVALID MOVE: We landed on a boundary line!
                        if (display) display.textContent = 'Respinning...';
                        console.log(`🔄 ${player} landed on boundary - respinning`);
                        
                        const respinDuration = Math.random() * 2000 + 2000; // 2-4s respin
                        setTimeout(() => {
                            this.spinAndStopWheel(wheelElement, moves, display, respinDuration, player);
                        }, 500);
                    }
                }, duration);
            },
            
            // Detect if angle lands within a move segment (with boundary tolerance)
            detectMove(angle, moves) {
                const boundaryTolerance = 1; // 1 degree tolerance on each side
                
                for (const move of moves) {
                    if (angle >= move.start + boundaryTolerance && angle <= move.end - boundaryTolerance) {
                        return move;
                    }
                }
                return null; // Landed on boundary
            },
            
            // DEFINITIVE stop function - properly stops the wheel
            stopSpinWheel(wheelElement, angle) {
                console.log(`🛑 Stopping wheel at ${angle}°`);
                
                // CRITICAL: Remove spinning class to stop infinite animation
                wheelElement.classList.remove('spinning');
                
                // Set final position with multiple rotations for visual effect
                const finalRotation = (360 * 5) + angle;
                wheelElement.style.transform = `rotate(${finalRotation}deg)`;
                
                // Force browser reflow to apply changes immediately
                wheelElement.offsetHeight;
                
                console.log(`✅ Wheel stopped and positioned at ${finalRotation}°`);
            },
            
            // Check if battle is complete and show results
            checkAuthenticBattleOutcome() {
                if (this.wheelResults.attacker && this.wheelResults.defender) {
                    console.log('🎯 Both wheels stopped! Battle complete!');
                    this.isSpinning = false;
                    
                    setTimeout(() => {
                        this.showAuthenticBattleResults();
                    }, 1000);
                }
            },
            
            // Show final battle results with authentic formatting
            showAuthenticBattleResults() {
                const attackerMove = this.wheelResults.attacker;
                const defenderMove = this.wheelResults.defender;
                
                const outcomeDiv = document.getElementById('diskBattleOutcome');
                if (outcomeDiv) {
                    outcomeDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <h3>🎯 BATTLE RESULTS</h3>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0; gap: 20px;">
                                <div style="flex: 1; padding: 15px; background: rgba(78, 205, 196, 0.2); border-radius: 10px;">
                                    <h4 style="color: #4ecdc4; margin: 0 0 10px 0;">Your Move</h4>
                                    <p style="margin: 5px 0;"><strong>${attackerMove.name}</strong></p>
                                    <p style="font-size: 12px; margin: 0; color: #ccc;">${attackerMove.type.toUpperCase()} • ${attackerMove.damage || 'Special'}</p>
                                </div>
                                <div style="flex: 1; padding: 15px; background: rgba(255, 107, 107, 0.2); border-radius: 10px;">
                                    <h4 style="color: #ff6b6b; margin: 0 0 10px 0;">Opponent Move</h4>
                                    <p style="margin: 5px 0;"><strong>${defenderMove.name}</strong></p>
                                    <p style="font-size: 12px; margin: 0; color: #ccc;">${defenderMove.type.toUpperCase()} • ${defenderMove.damage || 'Special'}</p>
                                </div>
                            </div>
                            <p style="color: #ffd93d; font-weight: bold; margin: 15px 0;">Battle Complete!</p>
                        </div>
                    `;
                    outcomeDiv.style.display = 'block';
                }
                
                // Show continue button
                const continueBtn = document.getElementById('continueBtn');
                if (continueBtn) {
                    continueBtn.style.display = 'block';
                }
            },
            
            // Stop individual wheel and check if pointer lands on a valid move
            stopWheelAndCheckMove(wheelElement, finalRotation, wheelType, robot) {
                console.log(`🎯 Stopping ${wheelType} wheel at ${finalRotation}°`);
                
                // CRITICAL: Remove spinning class to stop infinite animation
                wheelElement.classList.remove('spinning');
                
                // CRITICAL: Set final position with normalized angle
                const normalizedAngle = finalRotation % 360;
                wheelElement.style.transform = `rotate(${normalizedAngle}deg)`;
                
                // Force browser to apply the transform immediately
                wheelElement.offsetHeight; // Trigger reflow
                
                console.log(`✅ ${wheelType} wheel stopped at ${normalizedAngle}°`);
                
                // For now, just record a simple result (we'll enhance move detection later)
                const mockMove = {
                    name: `Move ${Math.floor(normalizedAngle / 60) + 1}`,
                    type: 'white',
                    damage: Math.floor(Math.random() * 100) + 20
                };
                
                this.recordWheelResult(wheelType, mockMove);
            },
            
            // Respin a wheel that landed between moves
            respinWheel(wheelElement, wheelType, robot) {
                console.log(`🔄 Respinning ${wheelType} wheel...`);
                
                // Calculate new random final position
                const newFinalRotation = Math.floor(Math.random() * 360) + (360 * 3); // 3+ rotations
                
                // Start spinning again
                wheelElement.classList.add('spinning');
                
                // Stop after 2-4 seconds (shorter respin)
                const respinTime = 2000 + Math.random() * 2000;
                setTimeout(() => {
                    this.stopWheelAndCheckMove(wheelElement, newFinalRotation, wheelType, robot);
                }, respinTime);
            },
            
            // Determine which move the pointer is pointing to
            getSelectedMove(rotation, robot) {
                // Normalize rotation to 0-360 degrees
                const normalizedRotation = ((rotation % 360) + 360) % 360;
                
                // Each segment is 360/96 = 3.75 degrees
                const segmentSize = 360 / 96;
                const pointerAngle = normalizedRotation;
                
                // Find which segment the pointer is in
                const segmentIndex = Math.floor(pointerAngle / segmentSize);
                
                // Check if pointer is too close to segment boundary (within 0.5 degrees)
                const segmentCenter = (segmentIndex + 0.5) * segmentSize;
                const distanceFromCenter = Math.abs(pointerAngle - segmentCenter);
                
                if (distanceFromCenter > segmentSize * 0.4) {
                    // Too close to boundary - return null for respin
                    return null;
                }
                
                // Get the move for this segment
                if (robot.wheel && robot.wheel[segmentIndex]) {
                    return robot.wheel[segmentIndex];
                }
                
                // Fallback - return first move if wheel data not found
                return robot.moves ? robot.moves[0] : { name: 'Unknown Move', type: 'white', damage: 0 };
            },
            
            // Record the result of a wheel stop
            wheelResults: {},
            
            recordWheelResult(wheelType, move) {
                this.wheelResults[wheelType] = move;
                console.log(`📝 Recorded ${wheelType} result:`, move);
                
                // Update UI to show selected move
                this.updateMoveDisplay(wheelType, move);
            },
            
            // Update the UI to show which move was selected
            updateMoveDisplay(wheelType, move) {
                const displayId = wheelType === 'attacker' ? 'attackerName' : 'defenderName';
                const nameElement = document.getElementById(displayId);
                
                if (nameElement) {
                    const originalText = nameElement.textContent;
                    nameElement.innerHTML = `
                        ${originalText}<br>
                        <span style="font-size: 12px; color: #ffd93d;">Selected: ${move.name}</span>
                    `;
                }
            },
            
            // Check if both wheels have stopped and show final results
            checkBothWheelsStopped() {
                if (this.wheelResults.attacker && this.wheelResults.defender) {
                    console.log('🎯 Both wheels stopped! Showing final battle results...');
                    setTimeout(() => {
                        this.showFinalBattleResults();
                    }, 500);
                }
            },
            
            // Show final battle results with selected moves
            showFinalBattleResults() {
                const attackerMove = this.wheelResults.attacker;
                const defenderMove = this.wheelResults.defender;
                
                const outcomeDiv = document.getElementById('diskBattleOutcome');
                if (outcomeDiv) {
                    outcomeDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <h3>🎯 BATTLE RESULTS</h3>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div style="flex: 1;">
                                    <h4 style="color: #4ecdc4;">Your Move</h4>
                                    <p><strong>${attackerMove.name}</strong></p>
                                    <p style="font-size: 12px;">${attackerMove.type} • ${attackerMove.damage || 'Special'}</p>
                                </div>
                                <div style="flex: 1;">
                                    <h4 style="color: #ff6b6b;">Opponent Move</h4>
                                    <p><strong>${defenderMove.name}</strong></p>
                                    <p style="font-size: 12px;">${defenderMove.type} • ${defenderMove.damage || 'Special'}</p>
                                </div>
                            </div>
                            <p style="color: #ffd93d; font-weight: bold;">Battle Complete!</p>
                        </div>
                    `;
                    outcomeDiv.style.display = 'block';
                }
                
                // Show continue button
                const continueBtn = document.getElementById('continueBtn');
                if (continueBtn) {
                    continueBtn.style.display = 'block';
                }
                
                // Clear results for next battle
                this.wheelResults = {};
            },
            
            // Show battle results after spinning completes
            showBattleResults() {
                console.log('🎯 Showing battle results');
                
                // Show the battle outcome
                const outcomeDiv = document.getElementById('diskBattleOutcome');
                if (outcomeDiv) {
                    outcomeDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <h3>🎯 BATTLE COMPLETE!</h3>
                            <p style="color: #ffd93d; font-weight: bold;">Wheels have stopped spinning!</p>
                            <p>Check the pointer to see which moves were selected.</p>
                        </div>
                    `;
                    outcomeDiv.style.display = 'block';
                }
                
                // Show continue button
                const continueBtn = document.getElementById('continueBtn');
                if (continueBtn) {
                    continueBtn.style.display = 'block';
                }
            },
            
            // Phase 1: Wind-up animation
            animationPhase1(attackerElement, defenderElement) {
                attackerElement.className = 'wind-up';
                defenderElement.className = 'wind-up';
            },
            
            // Phase 2: Peak spin with motion blur
            animationPhase2(attackerElement, defenderElement) {
                // Check if we should use animated assets during peak spin
                this.switchToAnimatedAssets(attackerElement, defenderElement);
                
                attackerElement.className = 'peak-spin';
                defenderElement.className = 'peak-spin';
                
                // Activate sparks
                const sparksContainer = document.querySelector('.sparks-container');
                if (sparksContainer) {
                    sparksContainer.classList.add('sparks-active');
                }
            },
            
            // Switch to animated assets during peak spin for enhanced effect
            switchToAnimatedAssets(attackerElement, defenderElement) {
                // For image-based wheels with 3D assets, switch to animated version during peak spin
                if (attackerElement.classList.contains('wheel-image') && attackerElement.dataset.has3D === 'true') {
                    const robotId = attackerElement.dataset.robotId;
                    attackerElement.src = `Imag/Battle/example/3D_Renders/${robotId}_spin_animation.gif`;
                }
                
                if (defenderElement.classList.contains('wheel-image') && defenderElement.dataset.has3D === 'true') {
                    const robotId = defenderElement.dataset.robotId;
                    defenderElement.src = `Imag/Battle/example/3D_Renders/${robotId}_spin_animation.gif`;
                }
            },
            
            // Phase 3: Deceleration
            animationPhase3(attackerElement, defenderElement, attackerFinal, defenderFinal) {
                // Switch back to static assets for deceleration
                this.switchToStaticAssets(attackerElement, defenderElement);
                
                attackerElement.className = 'decelerate';
                defenderElement.className = 'decelerate';
                
                // Remove sparks
                const sparksContainer = document.querySelector('.sparks-container');
                if (sparksContainer) {
                    sparksContainer.classList.remove('sparks-active');
                }
                
                // Set final rotations with extra spins
                const attackerTotal = attackerFinal + 2160; // 6 extra rotations
                const defenderTotal = defenderFinal + 1800; // 5 extra rotations
                
                attackerElement.style.transform = `rotate(${attackerTotal}deg)`;
                defenderElement.style.transform = `rotate(${defenderTotal}deg)`;
            },
            
            // Switch back to static assets after peak spin
            switchToStaticAssets(attackerElement, defenderElement) {
                // Switch back to static 3D rendered disks for deceleration and final result
                if (attackerElement.classList.contains('wheel-image') && attackerElement.dataset.has3D === 'true') {
                    const robotId = attackerElement.dataset.robotId;
                    attackerElement.src = `Imag/Battle/example/3D_Renders/${robotId}_standard_disk.png`;
                }
                
                if (defenderElement.classList.contains('wheel-image') && defenderElement.dataset.has3D === 'true') {
                    const robotId = defenderElement.dataset.robotId;
                    defenderElement.src = `Imag/Battle/example/3D_Renders/${robotId}_standard_disk.png`;
                }
            },
            
            // Phase 4: Staggered stop and results
            animationPhase4(attackerElement, defenderElement) {
                // First disk stops
                attackerElement.className = 'stopped';
                
                setTimeout(() => {
                    // Second disk stops (creates tension)
                    defenderElement.className = 'stopped';
                    
                    setTimeout(() => {
                        // Show results
                        this.showBattleResults();
                    }, 300);
                }, 400);
            },
            
            // Create sparks effect
            createSparksEffect() {
                const container = document.querySelector('.v-mount-container') || 
                                 document.querySelector('.disk-battle-container') ||
                                 document.getElementById('diskBattleView');
                
                if (!container) {
                    console.log('⚠️ Sparks container not found - skipping effect');
                    return; // Skip sparks if container not found
                }
                
                const sparksContainer = document.createElement('div');
                sparksContainer.className = 'sparks-container';
                
                // Create multiple sparks
                for (let i = 0; i < 8; i++) {
                    const spark = document.createElement('div');
                    spark.className = 'spark';
                    
                    // Random direction for each spark
                    const angle = (i / 8) * 360;
                    const distance = 30 + Math.random() * 20;
                    const x = Math.cos(angle * Math.PI / 180) * distance;
                    const y = Math.sin(angle * Math.PI / 180) * distance;
                    
                    spark.style.setProperty('--spark-x', `${x}px`);
                    spark.style.setProperty('--spark-y', `${y}px`);
                    spark.style.animationDelay = `${Math.random() * 0.3}s`;
                    
                    sparksContainer.appendChild(spark);
                }
                
                container.appendChild(sparksContainer);
            },
            
            calculateFinalRotation(robot, spinValue) {
                let currentSum = 0;
                let targetAngle = 0;
                
                for (let i = 0; i < robot.wheel.length; i++) {
                    const segment = robot.wheel[i];
                    const segmentAngle = (segment.size / 96) * 360;
                    
                    if (spinValue <= currentSum + segment.size) {
                        // This is the target segment
                        const positionInSegment = (spinValue - currentSum) / segment.size;
                        targetAngle = (currentSum / 96) * 360 + (segmentAngle * positionInSegment);
                        break;
                    }
                    currentSum += segment.size;
                }
                
                // Adjust so the selected segment ends up at the top (pointer position)
                return 360 - targetAngle;
            },
            
            showBattleResults() {
                const battle = this.currentVisualBattle;
                
                // Highlight selected segments
                this.highlightSelectedMove('attackerWheel', battle.attacker.spin.result);
                this.highlightSelectedMove('defenderWheel', battle.defender.spin.result);
                
                // Apply winner/loser styling to disks
                const attackerDisk = document.getElementById('attackerDisk');
                const defenderDisk = document.getElementById('defenderDisk');
                const diamondPointer = document.getElementById('diamondPointer');
                
                if (battle.result === 'attacker_wins') {
                    attackerDisk.classList.add('winner');
                    defenderDisk.classList.add('loser');
                    // Left side of diamond wins (attacker is on left)
                    diamondPointer.classList.add('left-wins');
                } else if (battle.result === 'defender_wins') {
                    defenderDisk.classList.add('winner');
                    attackerDisk.classList.add('loser');
                    // Right side of diamond wins (defender is on right)
                    diamondPointer.classList.add('right-wins');
                } else {
                    attackerDisk.classList.add('draw');
                    defenderDisk.classList.add('draw');
                    // Both sides draw
                    diamondPointer.classList.add('draw');
                }
                
                // Show battle outcome
                const outcomeDiv = document.getElementById('diskBattleOutcome');
                let outcomeText = '';
                let outcomeClass = '';
                
                if (battle.result === 'attacker_wins') {
                    outcomeText = `🏆 ${battle.attacker.robot.name} WINS!`;
                    outcomeClass = 'outcome-winner';
                } else if (battle.result === 'defender_wins') {
                    outcomeText = `🏆 ${battle.defender.robot.name} WINS!`;
                    outcomeClass = 'outcome-winner';
                } else {
                    outcomeText = '🤝 DRAW!';
                    outcomeClass = 'outcome-draw';
                }
                
                outcomeDiv.innerHTML = `<div class="${outcomeClass}">${outcomeText}</div>`;
                outcomeDiv.style.display = 'block';
                
                // Show move details
                document.getElementById('attackerMoveName').textContent = CombatSystem.formatMoveText(battle.attacker.spin.result);
                document.getElementById('attackerMoveType').textContent = `${battle.attacker.spin.result.moveType} Move`;
                document.getElementById('defenderMoveName').textContent = CombatSystem.formatMoveText(battle.defender.spin.result);
                document.getElementById('defenderMoveType').textContent = `${battle.defender.spin.result.moveType} Move`;
                
                document.getElementById('moveDetails').style.display = 'flex';
                document.getElementById('continueBtn').style.display = 'block';
            },
            
            highlightSelectedMove(wheelId, selectedMove) {
                const wheel = document.getElementById(wheelId);
                
                // Check if this is an image-based wheel (like Alaka-bot)
                const wheelImage = wheel.querySelector('.wheel-image');
                if (wheelImage) {
                    // For image-based wheels, use overlay highlighting
                    const overlay = wheel.querySelector('.wheel-overlay');
                    if (overlay) {
                        // Create segment highlight based on move position
                        this.highlightImageWheelMove(overlay, selectedMove, wheelImage.dataset.robotId);
                    }
                } else {
                    // Handle SVG segments
                    const svgSegments = wheel.querySelectorAll('.svg-segment');
                    if (svgSegments.length > 0) {
                        svgSegments.forEach(segment => {
                            if (segment.dataset.moveName === selectedMove.moveName) {
                                segment.classList.add('selected');
                            }
                        });
                    } else {
                        // Fallback for CSS segments
                        const segments = wheel.querySelectorAll('.disk-segment');
                        segments.forEach(segment => {
                            if (segment.dataset.moveName === selectedMove.moveName) {
                                segment.classList.add('selected-move');
                                const segmentContent = segment.querySelector('.segment-content');
                                if (segmentContent) {
                                    segmentContent.style.boxShadow = 'inset 0 0 30px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.6)';
                                }
                            }
                        });
                    }
                }
            },
            
            // Highlight moves on image-based wheels using overlay
            highlightImageWheelMove(overlay, selectedMove, robotId) {
                if (robotId === 'alaka-bot') {
                    // Get move position from JSON data
                    const robot = RobotDatabase.getRobot(robotId);
                    const moveData = robot.wheel.find(move => move.moveName === selectedMove.moveName);
                    
                    if (moveData) {
                        // Create SVG overlay for precise segment highlighting
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('viewBox', '0 0 280 280');
                        svg.style.position = 'absolute';
                        svg.style.top = '0';
                        svg.style.left = '0';
                        svg.style.pointerEvents = 'none';
                        
                        // Create precise segment path for highlighting
                        const startAngle = this.getApproximateStartAngle(moveData);
                        const endAngle = this.getApproximateEndAngle(moveData);
                        const segmentPath = this.createHighlightSegment(140, 140, 130, startAngle, endAngle);
                        
                        // Style the highlight segment
                        segmentPath.setAttribute('fill', 'rgba(34, 197, 94, 0.3)'); // Green with transparency
                        segmentPath.setAttribute('stroke', '#22c55e'); // Bright green outline
                        segmentPath.setAttribute('stroke-width', '4');
                        segmentPath.setAttribute('filter', 'drop-shadow(0 0 10px rgba(34, 197, 94, 0.8))');
                        
                        // Add pulsing animation
                        const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                        animate.setAttribute('attributeName', 'stroke-width');
                        animate.setAttribute('values', '4;6;4');
                        animate.setAttribute('dur', '1.5s');
                        animate.setAttribute('repeatCount', 'indefinite');
                        segmentPath.appendChild(animate);
                        
                        svg.appendChild(segmentPath);
                        overlay.appendChild(svg);
                        overlay.style.opacity = '1';
                    }
                }
            },
            
            // Create precise highlight segment for image wheels
            createHighlightSegment(centerX, centerY, radius, startAngle, endAngle) {
                const startAngleRad = (startAngle - 90) * Math.PI / 180; // -90 to start at top
                const endAngleRad = (endAngle - 90) * Math.PI / 180;
                
                const x1 = centerX + radius * Math.cos(startAngleRad);
                const y1 = centerY + radius * Math.sin(startAngleRad);
                const x2 = centerX + radius * Math.cos(endAngleRad);
                const y2 = centerY + radius * Math.sin(endAngleRad);
                
                const largeArcFlag = (endAngle - startAngle) > 180 ? 1 : 0;
                
                const pathData = [
                    `M ${centerX} ${centerY}`, // Move to center
                    `L ${x1} ${y1}`, // Line to start point
                    `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`, // Arc to end point
                    'Z' // Close path
                ].join(' ');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                
                return path;
            },
            
            // Get precise angles using JSON data
            getApproximateStartAngle(moveData) {
                // Use actual JSON data if available, otherwise use visual mapping
                if (moveData.moveName === 'Stillblind') return 0;      // 0-90 degrees
                if (moveData.moveName === 'Miss') return 90;           // 90-105 degrees  
                if (moveData.moveName === 'Psychic') return 105;       // 105-195 degrees
                if (moveData.moveName === 'Psyshock') return 195;      // 195-285 degrees
                if (moveData.moveName === 'Psycho Shift') return 285;  // 285-360 degrees
                return 0;
            },
            
            getApproximateEndAngle(moveData) {
                // Use actual JSON data for precise end angles
                if (moveData.moveName === 'Stillblind') return 90;     // 24 segments = 90°
                if (moveData.moveName === 'Miss') return 105;          // 4 segments = 15°
                if (moveData.moveName === 'Psychic') return 195;       // 24 segments = 90°
                if (moveData.moveName === 'Psyshock') return 285;      // 24 segments = 90°
                if (moveData.moveName === 'Psycho Shift') return 360;  // 20 segments = 75°
                return this.getApproximateStartAngle(moveData) + (moveData.size / 96) * 360;
            },
            
            // Missions System Functions
            openMissions() {
                this.checkDailyReset();
                
                // Auto-complete check-in mission on first open
                if (this.data.dailyMissionStatus.checkIn === 'unclaimed') {
                    this.data.dailyMissionStatus.checkIn = 'completed';
                    this.saveData();
                }
                
                // Always default to daily missions tab when opening
                this.data.currentMissionTab = 'daily';
                
                // Update tab UI to show daily as active
                document.querySelectorAll('.mission-tab').forEach(t => t.classList.remove('active'));
                document.getElementById('dailyTab').classList.add('active');
                
                const modal = document.getElementById('missionsModal');
                modal.classList.add('active');
                this.renderMissions();
            },

            closeMissions() {
                // Don't allow closing if mystery game is locked during animation
                if (this.data.mysteryGameState.isLocked) {
                    return;
                }
                
                const modal = document.getElementById('missionsModal');
                modal.classList.remove('active');
            },

            switchMissionTab(tab) {
                this.data.currentMissionTab = tab;
                
                // Update tab UI
                document.querySelectorAll('.mission-tab').forEach(t => t.classList.remove('active'));
                document.getElementById(tab + 'Tab').classList.add('active');
                
                this.renderMissions();
            },

            checkDailyReset() {
                const now = new Date();
                const today = now.toDateString(); // e.g., "Sat Oct 05 2025"
                const lastResetDate = this.data.lastDailyResetDate || '';
                
                // Check if it's a new day
                if (today !== lastResetDate) {
                    // Reset daily missions
                    this.data.lastDailyResetDate = today;
                    this.data.lastDailyReset = now.getTime();
                    this.data.dailyChoresCompleted = 0;
                    this.data.dailyBonusClaimed = false;
                    this.data.dailyMissionStatus = {
                        checkIn: 'unclaimed',
                        twoChores: 'incomplete',
                        fourChores: 'incomplete'
                    };
                    // Reset mystery game
                    this.data.mysteryGamePlayed = false;
                    this.data.mysteryGameState = {
                        isActive: false,
                        gamePhase: 'start',
                        prizes: [],
                        selectedBox: null,
                        wonPrize: null,
                        isLocked: false
                    };
                    this.saveData();
                }
            },

            updateChoreProgress() {
                this.data.dailyChoresCompleted++;
                
                // Update mission status
                if (this.data.dailyChoresCompleted >= 2 && this.data.dailyMissionStatus.twoChores === 'incomplete') {
                    this.data.dailyMissionStatus.twoChores = 'completed';
                }
                if (this.data.dailyChoresCompleted >= 4 && this.data.dailyMissionStatus.fourChores === 'incomplete') {
                    this.data.dailyMissionStatus.fourChores = 'completed';
                }
                
                this.saveData();
            },

            renderMissions() {
                const container = document.getElementById('missionsBody');
                const tab = this.data.currentMissionTab;
                
                if (tab === 'daily') {
                    this.renderDailyMissions(container);
                } else if (tab === 'mystery') {
                    this.renderMysteryGame(container);
                } else {
                    container.innerHTML = `
                        <div class="coming-soon">
                            <div class="coming-soon-icon">🚧</div>
                            <div class="coming-soon-text">Coming Soon!</div>
                            <div>This feature is under construction.</div>
                        </div>
                    `;
                }
            },

            renderDailyMissions(container) {
                const missions = [
                    {
                        id: 'checkIn',
                        title: 'Daily Check-In',
                        description: 'Open the Missions window',
                        status: this.data.dailyMissionStatus.checkIn
                    },
                    {
                        id: 'twoChores',
                        title: 'Complete 2 Chores',
                        description: `Complete any 2 tasks (${this.data.dailyChoresCompleted}/2)`,
                        status: this.data.dailyMissionStatus.twoChores
                    },
                    {
                        id: 'fourChores',
                        title: 'Complete 4 Chores',
                        description: `Complete any 4 tasks (${this.data.dailyChoresCompleted}/4)`,
                        status: this.data.dailyMissionStatus.fourChores
                    }
                ];

                let html = '';
                missions.forEach(mission => {
                    const cardClass = mission.status === 'completed' ? 'mission-card completed' : 
                                     mission.status === 'claimed' ? 'mission-card claimed' : 'mission-card';
                    
                    html += `
                        <div class="${cardClass}">
                            <div class="mission-title">${mission.title}</div>
                            <div class="mission-description">${mission.description}</div>
                            ${mission.status === 'completed' ? 
                                `<button class="mission-claim-btn" onclick="app.claimMission('${mission.id}')">Mark Complete</button>` :
                              mission.status === 'claimed' ?
                                `<div class="mission-claimed-badge">✓ Completed</div>` :
                                `<button class="mission-claim-btn" disabled>Not Completed</button>`
                            }
                        </div>
                    `;
                });

                // Add Complete All button with bonus info
                const allClaimed = missions.every(m => m.status === 'claimed');
                const hasCompletedMissions = missions.some(m => m.status === 'completed');
                
                if (allClaimed) {
                    html += `
                        <div class="mission-card" style="background: linear-gradient(135deg, #FFD700, #FFA500); border: none; text-align: center;">
                            <div class="mission-title" style="color: white;">🎉 All Missions Complete!</div>
                            <div class="mission-description" style="color: white; opacity: 0.9;">You earned 10 Bolts bonus!</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div style="text-align: center; padding: 20px; background: rgba(255, 215, 0, 0.1); border-radius: 16px; margin-top: 8px;">
                            <div style="font-size: 16px; font-weight: 600; color: #FFA500; margin-bottom: 8px;">
                                Complete All Missions
                            </div>
                            <div style="display: flex; align-items: center; justify-content: center; gap: 6px; font-size: 18px; font-weight: 700; color: #FFD700;">
                                <img src="Imag/Achivments/Images/Finished Images/Bolt.png" alt="Bolt" style="width: 24px; height: 24px;">
                                <img src="Imag/Achivments/Images/Finished Images/X.png" alt="x" style="width: 14px; height: 14px; opacity: 0.8;">
                                <span>10 Bonus</span>
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html;
            },

            claimMission(missionId) {
                this.data.dailyMissionStatus[missionId] = 'claimed';
                this.saveData();
                
                // Check if all missions are claimed for bonus
                this.checkAllMissionsClaimed();
                
                this.renderMissions();
            },

            checkAllMissionsClaimed() {
                const allClaimed = Object.values(this.data.dailyMissionStatus).every(status => status === 'claimed');
                
                if (allClaimed && !this.data.dailyBonusClaimed) {
                    this.addCurrency(10);
                    this.data.dailyBonusClaimed = true;
                    this.saveData();
                    
                    // Show congratulations modal for daily mission completion
                    this.showDailyMissionCongratulations();
                }
            },

            showDailyMissionCongratulations() {
                const modal = document.getElementById('mysteryResultModal');
                const image = document.getElementById('mysteryResultImage');
                const text = document.getElementById('mysteryResultText');
                
                // Set up the congratulations display
                image.src = 'Imag/Achivments/Images/Finished Images/10-Bolts.png'; // Use 10 bolts image
                text.textContent = 'You won 10 Bolts!';
                
                modal.classList.add('active');
                
                // Show congratulations speech with delay to avoid conflicts
                setTimeout(() => {
                    const congratsMessages = [
                        'Daily Mission Streak: +10 BIG ONES BABY!',
                        'Daily Mission Streak: +10 Clanky Coins!',
                        'Daily Mission Streak: +10 Robo-Riches!',
                        'Daily Mission Streak: +10 Shiny Bois!',
                        'Daily Mission Streak: +10 Grade-A Fasteners!',
                        'Daily Mission Streak: +10 Bolt Bucks!',
                        'Daily Mission Streak: +10 THE GOOD STUFF!',
                        'Daily Mission Streak: +10 PURE SHINY!',
                        'Daily Mission Streak: +10 Mech Money!',
                        'Daily Mission Streak: +10 WINNER WINNER!'
                    ];
                    
                    const randomMessage = congratsMessages[Math.floor(Math.random() * congratsMessages.length)];
                    this.showSpeechBubble(randomMessage, 'regular');
                }, 500);
            },

            // Mystery Game Functions
            renderMysteryGame(container) {
                const canPlay = !this.data.mysteryGamePlayed || this.isObonxoCheatActive;
                const buttonText = canPlay ? 'Start Mystery Pick!' : 'Already Played Today';
                const buttonDisabled = canPlay ? '' : 'disabled';
                
                container.innerHTML = `
                    <div class="mystery-game-container">
                        <div class="mystery-game-title">
                            <img src="Imag/Achivments/Images/Finished Images/Gift.png" alt="Gift Box" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;">
                            Daily Mystery Pick
                        </div>
                        <button class="mystery-start-btn" onclick="app.startMysteryGame()" ${buttonDisabled}>
                            ${buttonText}
                        </button>
                        <div class="mystery-game-arena" id="mysteryGameArena">
                            <div class="mystery-game-status" id="mysteryGameStatus"></div>
                            <div class="mystery-boxes-container" id="mysteryBoxesContainer">
                                <!-- Boxes will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                `;
            },

            startMysteryGame() {
                if (this.data.mysteryGamePlayed && !this.isObonxoCheatActive) return;
                
                this.data.mysteryGameState.isActive = true;
                this.data.mysteryGameState.gamePhase = 'pick';
                
                // Generate three random prizes with rare robot chance
                const possiblePrizes = this.generateMysteryPrizes();
                this.data.mysteryGameState.prizes = possiblePrizes;
                
                // Show game arena
                document.getElementById('mysteryGameArena').classList.add('active');
                document.querySelector('.mystery-start-btn').style.display = 'none';
                
                this.showMysteryBoxes();
            },

            // Weighted Prize Probability System
            generateFinalPrize() {
                // Roll 1-100 to determine prize tier
                const roll = Math.floor(Math.random() * 100) + 1;
                
                if (roll === 1) {
                    // 1% Chance - Jackpot Tier
                    const availableRobots = this.storeRobots.filter(robot => 
                        !this.data.ownedRobots.includes(robot.id)
                    );
                    
                    if (availableRobots.length > 0) {
                        // Unlock random unowned robot
                        const randomRobot = availableRobots[Math.floor(Math.random() * availableRobots.length)];
                        return {
                            id: randomRobot.id,
                            name: randomRobot.name,
                            image: randomRobot.actualImagePath,
                            type: 'robot',
                            tier: 'jackpot',
                            robotData: randomRobot
                        };
                    } else {
                        // Fallback: 100 Bolts if all robots owned
                        return {
                            id: 'bolts100',
                            name: '100 Bolts',
                            image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                            value: 100,
                            type: 'bolts',
                            tier: 'jackpot'
                        };
                    }
                } else if (roll >= 2 && roll <= 70) {
                    // 69% Chance - Common Tier {1, 5, 10, 15, 20}
                    const commonValues = [1, 5, 10, 15, 20];
                    const value = commonValues[Math.floor(Math.random() * commonValues.length)];
                    return {
                        id: `bolts${value}`,
                        name: `${value} Bolt${value > 1 ? 's' : ''}`,
                        image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                        value: value,
                        type: 'bolts',
                        tier: 'common'
                    };
                } else if (roll >= 71 && roll <= 90) {
                    // 20% Chance - Uncommon Tier {20, 25, 30, 35, 40, 45, 50}
                    const uncommonValues = [20, 25, 30, 35, 40, 45, 50];
                    const value = uncommonValues[Math.floor(Math.random() * uncommonValues.length)];
                    return {
                        id: `bolts${value}`,
                        name: `${value} Bolts`,
                        image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                        value: value,
                        type: 'bolts',
                        tier: 'uncommon'
                    };
                } else {
                    // 10% Chance - Rare Tier {50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100}
                    const rareValues = [50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100];
                    const value = rareValues[Math.floor(Math.random() * rareValues.length)];
                    return {
                        id: `bolts${value}`,
                        name: `${value} Bolts`,
                        image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                        value: value,
                        type: 'bolts',
                        tier: 'rare'
                    };
                }
            },

            generateDummyPrizes(finalPrize) {
                const dummyPrizes = [];
                
                // Generate 2 dummy prizes from different tiers to make selection look plausible
                for (let i = 0; i < 2; i++) {
                    let dummyPrize;
                    do {
                        // Generate a random tier (avoid jackpot for dummies)
                        const tierRoll = Math.floor(Math.random() * 3);
                        if (tierRoll === 0) {
                            // Common tier
                            const commonValues = [1, 5, 10, 15, 20];
                            const value = commonValues[Math.floor(Math.random() * commonValues.length)];
                            dummyPrize = {
                                id: `dummy_bolts${value}_${i}`,
                                name: `${value} Bolt${value > 1 ? 's' : ''}`,
                                image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                                value: value,
                                type: 'bolts',
                                tier: 'common'
                            };
                        } else if (tierRoll === 1) {
                            // Uncommon tier
                            const uncommonValues = [20, 25, 30, 35, 40, 45, 50];
                            const value = uncommonValues[Math.floor(Math.random() * uncommonValues.length)];
                            dummyPrize = {
                                id: `dummy_bolts${value}_${i}`,
                                name: `${value} Bolts`,
                                image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                                value: value,
                                type: 'bolts',
                                tier: 'uncommon'
                            };
                        } else {
                            // Rare tier
                            const rareValues = [50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100];
                            const value = rareValues[Math.floor(Math.random() * rareValues.length)];
                            dummyPrize = {
                                id: `dummy_bolts${value}_${i}`,
                                name: `${value} Bolts`,
                                image: 'Imag/Achivments/Images/Finished Images/Bolt.png',
                                value: value,
                                type: 'bolts',
                                tier: 'rare'
                            };
                        }
                    } while (dummyPrize.id === finalPrize.id || dummyPrizes.some(p => p.id === dummyPrize.id));
                    
                    dummyPrizes.push(dummyPrize);
                }
                
                return dummyPrizes;
            },

            generateMysteryPrizes() {
                // Generate the final prize first (this is what the user will actually get)
                const finalPrize = this.generateFinalPrize();
                this.data.mysteryGameState.finalPrize = finalPrize;
                
                // Generate 2 dummy prizes for visual presentation
                const dummyPrizes = this.generateDummyPrizes(finalPrize);
                
                // Create array with final prize and dummies, then shuffle for visual presentation
                const allPrizes = [finalPrize, ...dummyPrizes];
                
                // Shuffle the visual order
                for (let i = allPrizes.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPrizes[i], allPrizes[j]] = [allPrizes[j], allPrizes[i]];
                }
                
                return allPrizes;
            },

            showMysteryBoxes() {
                const container = document.getElementById('mysteryBoxesContainer');
                const status = document.getElementById('mysteryGameStatus');
                
                status.textContent = 'Pick a box!';
                
                let html = '';
                for (let i = 0; i < 3; i++) {
                    const prize = this.data.mysteryGameState.prizes[i];
                    html += `
                        <div class="mystery-box" id="mysteryBox${i}" onclick="app.selectMysteryBox(${i})">
                            <img src="Imag/Achivments/Images/Finished Images/Gift.png" alt="Gift Box" class="mystery-box-image">
                            <div class="mystery-box-prize">
                                <img src="${prize.image}" alt="${prize.name}" class="mystery-prize-image">
                                <div class="mystery-prize-text">${prize.name}</div>
                            </div>
                        </div>
                    `;
                }
                container.innerHTML = html;
            },


            selectMysteryBox(boxIndex) {
                if (this.data.mysteryGameState.gamePhase !== 'pick') return;
                
                // Step A: Lock the modal immediately upon box selection
                this.data.mysteryGameState.isLocked = true;
                this.updateMysteryCloseButton(false); // Disable close button
                
                this.data.mysteryGameState.selectedBox = boxIndex;
                this.data.mysteryGameState.gamePhase = 'result';
                
                // Use the predetermined final prize (not random!)
                this.data.mysteryGameState.wonPrize = this.data.mysteryGameState.finalPrize;
                
                this.revealResult(boxIndex);
            },

            revealResult(selectedBoxIndex) {
                const status = document.getElementById('mysteryGameStatus');
                const boxes = document.querySelectorAll('.mystery-box');
                
                status.textContent = 'Opening your box...';
                
                // Open all boxes and show what was "inside"
                boxes.forEach((box, index) => {
                    const boxImage = box.querySelector('.mystery-box-image');
                    const prize = box.querySelector('.mystery-box-prize');
                    const prizeImage = prize.querySelector('.mystery-prize-image');
                    const prizeText = prize.querySelector('.mystery-prize-text');
                    
                    box.classList.add('opening');
                    
                    setTimeout(() => {
                        boxImage.src = 'Imag/Achivments/Images/Finished Images/Open-Gift.png';
                        
                        if (index === selectedBoxIndex) {
                            // Always show the predetermined final prize in selected box
                            const finalPrize = this.data.mysteryGameState.finalPrize;
                            prizeImage.src = finalPrize.image;
                            prizeText.textContent = finalPrize.name;
                            
                            // Add sparkle effect
                            const sparkle = document.createElement('div');
                            sparkle.className = 'sparkle-effect';
                            box.appendChild(sparkle);
                        } else {
                            // Show the dummy prizes that were originally in these boxes
                            const originalPrize = this.data.mysteryGameState.prizes[index];
                            
                            // If it's a robot prize that wasn't selected, show shadow and hide name
                            if (originalPrize.type === 'robot') {
                                prizeImage.src = originalPrize.robotData.shadowImagePath;
                                prizeText.textContent = '???';
                            } else {
                                prizeImage.src = originalPrize.image;
                                prizeText.textContent = originalPrize.name;
                            }
                        }
                        
                        prize.classList.add('revealed');
                    }, 300);
                });
                
                // Show result modal after animation - extended time to view other prizes
                setTimeout(() => {
                    this.showMysteryResult();
                }, 3500);
            },

            updateMysteryCloseButton(enabled) {
                const closeButton = document.querySelector('.missions-close');
                if (closeButton) {
                    if (enabled) {
                        closeButton.style.opacity = '1';
                        closeButton.style.cursor = 'pointer';
                        closeButton.style.pointerEvents = 'auto';
                    } else {
                        closeButton.style.opacity = '0.3';
                        closeButton.style.cursor = 'not-allowed';
                        closeButton.style.pointerEvents = 'none';
                    }
                }
            },

            showMysteryResult() {
                const modal = document.getElementById('mysteryResultModal');
                const image = document.getElementById('mysteryResultImage');
                const text = document.getElementById('mysteryResultText');
                const closeButton = modal.querySelector('.mystery-result-btn');
                
                const wonPrize = this.data.mysteryGameState.wonPrize;
                
                image.src = wonPrize.image;
                text.textContent = `You won ${wonPrize.name}!`;
                
                modal.classList.add('active');
                
                // Step D: Unlock the modal now that congratulations screen is visible
                this.data.mysteryGameState.isLocked = false;
                this.updateMysteryCloseButton(true); // Re-enable close button
                
                // Award the prize based on type - delay speech to avoid conflicts
                setTimeout(() => {
                    if (wonPrize.type === 'robot') {
                        // Add robot to owned robots and remove from store
                        this.data.ownedRobots.push(wonPrize.id);
                        this.showSpeechBubble(`Amazing! You won a free ${wonPrize.name} robot!`, 'regular');
                        
                        // Update robot store display if it's open
                        if (this.isStoreOpen()) {
                            this.renderRobotStore();
                        }
                    } else {
                        // Regular bolt prize
                        this.addCurrency(wonPrize.value);
                        
                        // Random fun bolt prize messages
                        const boltMessages = [
                            `Daily Mystery Pick: +${wonPrize.value} BIG ONES BABY!`,
                            `Daily Mystery Pick: +${wonPrize.value} Clanky Coins!`,
                            `Daily Mystery Pick: +${wonPrize.value} Robo-Riches!`,
                            `Daily Mystery Pick: +${wonPrize.value} Shiny Bois!`,
                            `Daily Mystery Pick: +${wonPrize.value} Grade-A Fasteners!`,
                            `Daily Mystery Pick: +${wonPrize.value} Bolt Bucks!`,
                            `Daily Mystery Pick: +${wonPrize.value} Spare Parts!`,
                            `Daily Mystery Pick: +${wonPrize.value} THE GOOD STUFF!`,
                            `Daily Mystery Pick: +${wonPrize.value} Clinkity-Clanks!`,
                            `Daily Mystery Pick: +${wonPrize.value} PURE SHINY!`,
                            `Daily Mystery Pick: +${wonPrize.value} Thingamajigs!`,
                            `Daily Mystery Pick: +${wonPrize.value} Screwy Screws!`,
                            `Daily Mystery Pick: +${wonPrize.value} Socket Stuffers!`,
                            `Daily Mystery Pick: +${wonPrize.value} Cold Hard Steel!`,
                            `Daily Mystery Pick: +${wonPrize.value} Metal Spaghetti!`,
                            `Daily Mystery Pick: +${wonPrize.value} Mech Money!`,
                            `Daily Mystery Pick: +${wonPrize.value} Prime Rivets!`,
                            `Daily Mystery Pick: +${wonPrize.value} Fat Stacks o' Scrap!`,
                            `Daily Mystery Pick: +${wonPrize.value} WINNER WINNER!`,
                            `Daily Mystery Pick: +${wonPrize.value} Doo-Dads!`,
                            `Daily Mystery Pick: +${wonPrize.value} Tinkerer's Tokens!`,
                            `Daily Mystery Pick: +${wonPrize.value} Freshly Forged!`,
                            `Daily Mystery Pick: +${wonPrize.value} Gizmos!`,
                            `Daily Mystery Pick: +${wonPrize.value} Little Metal Dudes!`,
                            `Daily Mystery Pick: +${wonPrize.value} OH YEAH!`
                        ];
                        
                        const randomMessage = boltMessages[Math.floor(Math.random() * boltMessages.length)];
                        this.showSpeechBubble(randomMessage, 'regular');
                    }
                }, 500); // 500ms delay to ensure this speech plays after any other conflicting speech
                
                // Only mark as played if cheat is not active
                if (!this.isObonxoCheatActive) {
                    this.data.mysteryGamePlayed = true;
                }
                this.saveData();
            },

            closeMysteryResult() {
                const modal = document.getElementById('mysteryResultModal');
                modal.classList.remove('active');
                
                // Reset game state
                this.data.mysteryGameState = {
                    isActive: false,
                    gamePhase: 'start',
                    prizes: [],
                    selectedBox: null,
                    wonPrize: null,
                    isLocked: false
                };
                
                // Ensure close button is re-enabled
                this.updateMysteryCloseButton(true);
                
                // If OBONXO cheat is active, reset the played status for testing
                if (this.isObonxoCheatActive) {
                    this.data.mysteryGamePlayed = false;
                }
                
                // Re-render the mystery game to show current status
                this.renderMissions();
            }
        };

        // Extend app object with battle system functions
        app.updateTeamSelectionUI = function() {
            // Update team count
            const teamCount = document.getElementById('teamCount');
            if (teamCount) {
                teamCount.textContent = TeamManager.selectedTeam.length;
            }
            
            // Update team analysis
            const analysis = TeamManager.getTeamAnalysis();
            const teamAnalysisEl = document.getElementById('teamAnalysis');
            if (teamAnalysisEl) {
                if (analysis.size === 0) {
                    teamAnalysisEl.textContent = 'Select robots to see team composition';
                } else {
                    const roleText = Object.entries(analysis.roles).map(([role, count]) => 
                        `${count} ${role}${count > 1 ? 's' : ''}`
                    ).join(', ');
                    teamAnalysisEl.textContent = `Roles: ${roleText}`;
                }
            }
            
            // Update selected team grid
            app.updateSelectedTeamGrid();
            
            // Update available robots grid
            app.updateAvailableRobotsGrid();
            
            // Update start battle button
            const startBtn = document.getElementById('startBattleBtn');
            if (startBtn) {
                startBtn.disabled = !TeamManager.isTeamComplete();
            }
        };

        app.updateSelectedTeamGrid = function() {
            const grid = document.getElementById('selectedTeamGrid');
            if (!grid) return;
            
            const slots = grid.querySelectorAll('.squad-slot');
            slots.forEach((slot, index) => {
                const robotId = TeamManager.selectedTeam[index];
                const slotNumber = slot.querySelector('.slot-number');
                const slotLabel = slot.querySelector('.slot-label');
                
                if (robotId) {
                    const robot = RobotDatabase.getRobot(robotId);
                    slot.className = 'squad-slot filled';
                    slotLabel.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 2px;">${robot.name}</div>
                        <div style="font-size: 8px;">${robot.mp} MP • ${robot.role}</div>
                    `;
                    slot.onclick = () => {
                        TeamManager.removeFromTeam(robotId);
                        app.updateTeamSelectionUI();
                    };
                    slot.title = `Click to remove ${robot.name}`;
                } else {
                    slot.className = 'squad-slot empty';
                    slotLabel.textContent = 'Empty';
                    slot.onclick = null;
                    slot.title = 'Select a robot from the bay below';
                }
            });
        };

        app.updateAvailableRobotsGrid = function() {
            console.log('🔧 updateAvailableRobotsGrid called');
            const grid = document.getElementById('robotsGrid');
            if (!grid) {
                console.error('❌ robotsGrid element not found!');
                return;
            }
            
            console.log('📐 Grid element found:', grid);
            console.log('📏 Grid dimensions:', grid.offsetWidth, 'x', grid.offsetHeight);
            console.log('👁️ Grid visibility:', getComputedStyle(grid).display, getComputedStyle(grid).visibility);
            
            console.log('🤖 Getting robots from database...');
            const allRobots = RobotDatabase.getAllRobots();
            console.log('📊 Found robots:', allRobots.length, allRobots);
            
            if (allRobots.length === 0) {
                console.error('❌ No robots found in database!');
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 20px;">No robots available</div>';
                return;
            }
            
            grid.innerHTML = '';
            
            allRobots.forEach(robot => {
                const isSelected = TeamManager.selectedTeam.includes(robot.id);
                const isTeamFull = TeamManager.selectedTeam.length >= TeamManager.maxTeamSize;
                const isDisabled = isSelected || (isTeamFull && !isSelected);
                
                const card = document.createElement('div');
                card.className = `robot-card ${isSelected ? 'selected' : ''} ${isDisabled && !isSelected ? 'disabled' : ''}`;
                
                // Create wheel visualization
                const wheelSegments = robot.wheel.map(segment => {
                    const width = (segment.size / 96) * 100;
                    return `<div class="wheel-segment ${segment.moveType.toLowerCase()}" style="width: ${width}%;" title="${segment.moveName}"></div>`;
                }).join('');
                
                card.innerHTML = `
                    <div class="robot-card-header">
                        <img src="${robot.image}" alt="${robot.name}" class="robot-card-image">
                        <div>
                            <div class="robot-card-name">${robot.name}</div>
                            <div class="robot-card-role">${robot.role}</div>
                        </div>
                    </div>
                    <div class="robot-card-stats">
                        <div class="robot-stat"><strong>MP:</strong> ${robot.mp}</div>
                    </div>
                    <div class="robot-card-description">${robot.description}</div>
                    <div class="robot-card-wheel">${wheelSegments}</div>
                    <div style="font-size: 10px; color: var(--text-secondary);">${robot.ability.name}</div>
                `;
                
                if (!isDisabled) {
                    card.onclick = () => {
                        if (isSelected) {
                            TeamManager.removeFromTeam(robot.id);
                        } else {
                            if (TeamManager.selectedTeam.length >= TeamManager.maxTeamSize) {
                                app.showSquadFullMessage('Squad is full! Remove a robot first.');
                                return;
                            }
                            TeamManager.addToTeam(robot.id);
                        }
                        app.updateTeamSelectionUI();
                    };
                } else if (isTeamFull && !isSelected) {
                    card.onclick = () => {
                        app.showSquadFullMessage('Squad is full! Remove a robot first.');
                    };
                }
                
                grid.appendChild(card);
                console.log('🎯 Added robot card to grid:', robot.name);
            });
            
            console.log('✅ Robot grid update complete. Total cards:', allRobots.length);
        };

        app.showSquadFullMessage = function(message) {
            // Create temporary message element
            const messageEl = document.createElement('div');
            messageEl.textContent = message;
            messageEl.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--surface);
                color: var(--text);
                padding: 16px 24px;
                border-radius: 8px;
                border: 2px solid var(--primary);
                box-shadow: var(--shadow-lg);
                z-index: 10000;
                font-weight: 600;
                text-align: center;
            `;
            
            document.body.appendChild(messageEl);
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 2000);
        };

        app.startBattleWithTeam = function() {
            if (!TeamManager.isTeamComplete()) {
                app.showSquadFullMessage('Please select 6 robots before starting battle!');
                return;
            }
            
            console.log('🚀 Starting battle with selected team:', TeamManager.selectedTeam);
            
            // DEBUG MODE: Use same team for both sides (player controls both)
            const playerTeam = TeamManager.selectedTeam;
            // Clone the team and append '-opp' to each robot ID to make them unique
            const opponentTeam = TeamManager.selectedTeam.map(robotId => robotId + '-opp');
            console.log('🎮 DEBUG MODE: Player controls both sides');
            console.log('👤 Player Team:', playerTeam);
            console.log('🤖 Opponent Team:', opponentTeam);
            
            // Transition to battle game phase
            app.showBattleGamePhase();
            
            // Initialize battle with both teams
            setTimeout(() => {
                BattleSystem.initializeBattleWithTeams(playerTeam, opponentTeam);
                BattleSystem.enableDebugMode();
            }, 500);
        };

        app.showBattleGamePhase = function() {
            // Hide team selection phase, show battle game phase
            document.getElementById('teamSelectionPhase').style.display = 'none';
            document.getElementById('battleGamePhase').style.display = 'block';
            
            // Update header
            document.getElementById('battleTitle').textContent = '⚔️ Battle Arena';
            document.getElementById('battleSubtitle').textContent = 'Strategic Robot Combat';
            
            console.log("Battle game phase activated");
            
            // START BATTLE MUSIC (plays throughout entire game)
            if (BattleSystem.battleMusic) {
                BattleSystem.battleMusic.currentTime = 0; // Restart from beginning
                BattleSystem.battleMusic.play().catch(err => {
                    console.warn('🎵 Could not play battle music:', err);
                });
                console.log('🎵 Battle music started - will play throughout game');
            }
            
            // START WITH FIRST TURN SPINNER!
            console.log('🎲 Spinning for first turn...');
            app.showFirstTurnSpinner();
        };
        
        // ==========================================
        // FIRST TURN SPINNER SYSTEM (WITH PROPER WHEEL)
        // ==========================================
        app.showFirstTurnSpinner = function() {
            const overlay = document.getElementById('firstTurnSpinner');
            const resultText = document.getElementById('spinnerResult');
            
            // Show overlay
            overlay.style.display = 'flex';
            resultText.style.opacity = '0';
            
            // Create wheel data - simple 2 segments (50-50)
            const wheelData = [
                { team: 'player', size: 48, color: '#00c8ff', label: 'PLAYER' },
                { team: 'opponent', size: 48, color: '#ff3232', label: 'OPPONENT' }
            ];
            
            // Build visual wheel
            this.buildFirstTurnWheel('firstTurnWheelSegments', wheelData);
            
            // Decide winner (50/50)
            const winner = Math.random() < 0.5 ? 'player' : 'opponent';
            console.log('🎲 First turn winner (pre-determined):', winner);
            
            // Calculate spin position - land in CENTER of winning segment
            let spinPosition;
            if (winner === 'player') {
                // Player segment is positions 1-48, center is around 24
                spinPosition = 20 + Math.floor(Math.random() * 9); // Positions 20-28 (center 9 positions)
            } else {
                // Opponent segment is positions 49-96, center is around 72
                spinPosition = 68 + Math.floor(Math.random() * 9); // Positions 68-76 (center 9 positions)
            }
            
            console.log(`🎯 Landing on ${winner} segment at position ${spinPosition}`);
            
            // Calculate rotation angle
            const wheelElement = document.getElementById('firstTurnWheelSegments');
            const finalRotation = this.calculateFirstTurnRotation(wheelData, spinPosition);
            
            // Reset wheel position
            wheelElement.style.transition = 'none';
            wheelElement.style.transform = 'rotate(0deg)';
            void wheelElement.offsetWidth; // Trigger reflow
            
            // Start spinning animation
            setTimeout(() => {
                wheelElement.style.transition = 'transform 3.5s cubic-bezier(0.22, 0.61, 0.36, 1)';
                wheelElement.style.transform = `rotate(${finalRotation}deg)`;
                
                // Show result after animation
                setTimeout(() => {
                    this.showSpinnerResult(winner);
                }, 3600);
            }, 100);
        };
        
        app.buildFirstTurnWheel = function(elementId, wheelData) {
            const wheelElement = document.getElementById(elementId);
            if (!wheelElement) return;
            
            // Clear existing
            wheelElement.innerHTML = '';
            
            // Calculate total size
            const totalSize = wheelData.reduce((sum, seg) => sum + seg.size, 0);
            
            // Create conic gradient
            let gradientSegments = [];
            let currentAngle = 0;
            
            wheelData.forEach((segment, index) => {
                const segmentAngle = (segment.size / totalSize) * 360;
                gradientSegments.push(`${segment.color} ${currentAngle}deg ${currentAngle + segmentAngle}deg`);
                
                // Add label to the segment
                if (segment.label) {
                    const label = document.createElement('div');
                    label.className = 'first-turn-label';
                    label.textContent = segment.label;
                    
                    // Position label at center of segment
                    const labelAngle = currentAngle + (segmentAngle / 2);
                    const labelRadius = 45; // % from center
                    const radians = (labelAngle - 90) * (Math.PI / 180);
                    const x = 50 + (labelRadius * Math.cos(radians));
                    const y = 50 + (labelRadius * Math.sin(radians));
                    
                    label.style.left = `${x}%`;
                    label.style.top = `${y}%`;
                    label.style.transform = `translate(-50%, -50%) rotate(${labelAngle}deg)`;
                    
                    wheelElement.appendChild(label);
                }
                
                currentAngle += segmentAngle;
            });
            
            wheelElement.style.background = `conic-gradient(${gradientSegments.join(', ')})`;
        };
        
        app.calculateFirstTurnRotation = function(wheelData, spinPosition) {
            const totalSize = wheelData.reduce((sum, seg) => sum + seg.size, 0);
            let cumulative = 0;
            let segmentStartAngle = 0;
            let segmentEndAngle = 0;
            
            for (const segment of wheelData) {
                const segmentAngle = (segment.size / totalSize) * 360;
                
                if (spinPosition > cumulative && spinPosition <= cumulative + segment.size) {
                    segmentStartAngle = (cumulative / totalSize) * 360;
                    segmentEndAngle = ((cumulative + segment.size) / totalSize) * 360;
                    
                    const positionInSegment = spinPosition - cumulative;
                    const angleInSegment = (positionInSegment / segment.size) * segmentAngle;
                    const targetAngle = segmentStartAngle + angleInSegment;
                    
                    // Add multiple rotations for drama (1800° = 5 full spins)
                    const fullRotations = 1800;
                    const finalAngle = fullRotations + targetAngle;
                    
                    return finalAngle;
                }
                
                cumulative += segment.size;
            }
            
            return 1800; // Fallback
        };
        
        app.showSpinnerResult = function(winner) {
            const resultText = document.getElementById('spinnerResult');
            
            // Show result
            if (winner === 'player') {
                resultText.textContent = '🎮 PLAYER GOES FIRST';
                resultText.style.color = '#00c8ff';
            } else {
                resultText.textContent = '🤖 OPPONENT GOES FIRST';
                resultText.style.color = '#ff3232';
            }
            
            resultText.style.animation = 'resultFadeIn 0.5s ease forwards';
            resultText.style.opacity = '1';
            
            // Wait, then hide spinner and start game
            setTimeout(() => {
                this.hideFirstTurnSpinner(winner);
            }, 2500);
        };
        
        app.hideFirstTurnSpinner = function(winner) {
            const overlay = document.getElementById('firstTurnSpinner');
            const wheelElement = document.getElementById('firstTurnWheelSegments');
            const resultText = document.getElementById('spinnerResult');
            
            // Fade out
            overlay.style.animation = 'fadeOut 0.5s ease forwards';
            
            setTimeout(() => {
                overlay.style.display = 'none';
                
                // Reset for next time
                wheelElement.style.transition = 'none';
                wheelElement.style.transform = 'rotate(0deg)';
                resultText.style.opacity = '0';
                resultText.style.animation = '';
                overlay.style.animation = '';
                
                // Start the game with the winner's turn
                console.log(`🎮 Starting ${winner}'s turn...`);
                
                // Log to battle history
                BattleSystem.addToHistory(`🎲 First turn: ${winner.toUpperCase()} goes first!`, 'system', null);
                
                if (winner === 'player') {
                    BattleSystem.setState(BattleSystem.gameStates.PLAYER_TURN);
                } else {
                    BattleSystem.setState(BattleSystem.gameStates.AI_TURN);
                }
            }, 500);
        };

        // Battle System Foundation
        const BattleSystem = {
            // ==========================================
            // BATTLE SCENARIO DEBUGGER
            // ==========================================
            debugger: {
                enabled: false,
                panelOpen: false,
                selectedPlayerMove: null,
                selectedOpponentMove: null,
                selectedPlayerBonusMove: null,
                selectedOpponentBonusMove: null
            },
            
            // Psycho Cut Statistics Tracking
            psychoCutStats: {
                totalTriggers: 0,
                totalSuccesses: 0,
                totalFailures: 0,
                damageDealt: [],
                bonusSpinResults: []
            },
            
            // Toggle debugger panel visibility
            toggleDebugger() {
                this.debugger.panelOpen = !this.debugger.panelOpen;
                const panel = document.getElementById('battleDebuggerPanel');
                if (this.debugger.panelOpen) {
                    panel.classList.add('active');
                    panel.classList.remove('minimized'); // Ensure it's not minimized when opening
                    this.updateStatusEffectManagerVisibility(); // Show status manager if battle is active
                } else {
                    panel.classList.remove('active');
                }
                console.log(`🛠️ Debugger panel ${this.debugger.panelOpen ? 'opened' : 'closed'}`);
            },
            
            // Minimize/maximize debugger panel
            minimizeDebugger() {
                const panel = document.getElementById('battleDebuggerPanel');
                panel.classList.toggle('minimized');
                const isMinimized = panel.classList.contains('minimized');
                console.log(`🛠️ Debugger panel ${isMinimized ? 'minimized' : 'maximized'}`);
            },
            
            // Toggle debugger mode (force outcome on/off)
            toggleDebuggerMode() {
                this.debugger.enabled = !this.debugger.enabled;
                const toggle = document.getElementById('debuggerToggle');
                if (this.debugger.enabled) {
                    toggle.classList.add('active');
                    console.log('🛠️ Debugger mode ENABLED - Battle outcomes will be forced');
                    this.updateDebuggerStatus();
                } else {
                    toggle.classList.remove('active');
                    console.log('🛠️ Debugger mode DISABLED - Battles will be random');
                    this.updateDebuggerStatus();
                }
            },
            
            // Toggle free movement mode (instant teleportation for scenario setup)
            toggleFreeMovementMode() {
                this.freeMovementMode = !this.freeMovementMode;
                const toggle = document.getElementById('freeMovementToggle');
                if (this.freeMovementMode) {
                    toggle.classList.add('active');
                    console.log('🚀 FREE MOVEMENT MODE ENABLED - Click any robot, then click any empty space to teleport!');
                    this.addToHistory('🚀 Free Movement Mode: ON - Instant teleportation enabled', 'info', this.currentControlTeam);
                } else {
                    toggle.classList.remove('active');
                    console.log('🚶 FREE MOVEMENT MODE DISABLED - Normal movement rules apply');
                    this.addToHistory('🚶 Free Movement Mode: OFF - Normal movement restored', 'info', this.currentControlTeam);
                }
            },
            
            // Populate debugger with battle moves
            populateDebugger(attackerRobot, defenderRobot, attackerTeam, defenderTeam) {
                if (!this.currentBattle) return;
                
                console.log('🛠️ Populating debugger with battle moves');
                
                // Update column headers
                const playerIsAttacker = attackerTeam === 'player';
                const playerRobot = playerIsAttacker ? attackerRobot : defenderRobot;
                const opponentRobot = playerIsAttacker ? defenderRobot : attackerRobot;
                
                document.getElementById('playerColumnHeader').textContent = `${playerRobot.name} (Player)`;
                document.getElementById('opponentColumnHeader').textContent = `${opponentRobot.name} (Opponent)`;
                
                // Update status effect manager headers
                const playerStatusHeader = document.getElementById('playerStatusHeader');
                const opponentStatusHeader = document.getElementById('opponentStatusHeader');
                if (playerStatusHeader) playerStatusHeader.textContent = `${playerRobot.name} (Player)`;
                if (opponentStatusHeader) opponentStatusHeader.textContent = `${opponentRobot.name} (Opponent)`;
                
                // Populate player moves
                this.populateMovesList('playerMovesList', playerRobot.wheel, 'player');
                
                // Populate opponent moves
                this.populateMovesList('opponentMovesList', opponentRobot.wheel, 'opponent');
                
                // Populate bonus spin lists (for Psycho Cut)
                this.populateMovesList('playerBonusMovesList', playerRobot.wheel, 'player', true);
                this.populateMovesList('opponentBonusMovesList', opponentRobot.wheel, 'opponent', true);
                
                // Show bonus spin section
                const bonusSpinSection = document.getElementById('debuggerBonusSpinSection');
                if (bonusSpinSection) {
                    bonusSpinSection.style.display = 'block';
                }
                
                // Update status effect manager visibility and content
                this.updateStatusEffectManagerVisibility();
                
                this.updateDebuggerStatus();
            },
            
            // Populate a moves list
            populateMovesList(containerId, wheel, side, isBonus = false) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                
                // Get robot instance ID for status effects
                const robotInstanceId = side === 'player' ? 
                    this.currentBattle?.attackerRobotInstanceId : 
                    this.currentBattle?.defenderRobotInstanceId;
                
                wheel.forEach((move, index) => {
                    const moveOption = document.createElement('div');
                    moveOption.className = 'move-option';
                    moveOption.dataset.side = side;
                    moveOption.dataset.index = index;
                    moveOption.dataset.isBonus = isBonus;
                    
                    // Radio button
                    const radio = document.createElement('div');
                    radio.className = 'move-radio';
                    
                    // Move text with color
                    const moveText = document.createElement('div');
                    moveText.className = 'move-text';
                    moveText.textContent = move.moveName;
                    moveText.style.color = this.getMoveColorHex(move.moveType);
                    
                    // Damage/stars info with status effect modifications
                    const moveInfo = document.createElement('div');
                    moveInfo.className = 'move-damage';
                    
                    if (move.damage !== undefined && move.damage !== null) {
                        let displayDamage = move.damage;
                        let hasStatusEffect = false;
                        
                        // Calculate status effect damage reduction
                        const moveTypeLower = move.moveType ? move.moveType.toLowerCase() : '';
                        if (robotInstanceId && (moveTypeLower === 'white' || moveTypeLower === 'gold')) {
                            let damageReduction = 0;
                            
                            if (this.hasStatusEffect(robotInstanceId, 'poison')) {
                                damageReduction += 20;
                                hasStatusEffect = true;
                            }
                            if (this.hasStatusEffect(robotInstanceId, 'noxious')) {
                                damageReduction += 40;
                                hasStatusEffect = true;
                            }
                            if (this.hasStatusEffect(robotInstanceId, 'burn')) {
                                damageReduction += 10;
                                hasStatusEffect = true;
                            }
                            
                            displayDamage = Math.max(0, move.damage - damageReduction);
                        }
                        
                        if (hasStatusEffect && displayDamage !== move.damage) {
                            moveInfo.innerHTML = `<span style="text-decoration: line-through; opacity: 0.5;">${move.damage}</span> <span style="color: #ff6b6b; font-weight: 700;">${displayDamage}</span> dmg`;
                        } else {
                            moveInfo.textContent = `${move.damage} dmg`;
                        }
                    } else if (move.stars !== undefined && move.stars !== null) {
                        moveInfo.textContent = `${'⭐'.repeat(move.stars)}`;
                    } else {
                        moveInfo.textContent = move.moveType;
                    }
                    
                    moveOption.appendChild(radio);
                    moveOption.appendChild(moveText);
                    moveOption.appendChild(moveInfo);
                    
                    // Click handler - different for bonus spins
                    if (isBonus) {
                        moveOption.onclick = () => this.selectDebuggerBonusMove(side, index, moveOption);
                    } else {
                        moveOption.onclick = () => this.selectDebuggerMove(side, index, moveOption);
                    }
                    
                    container.appendChild(moveOption);
                });
            },
            
            // Select a move in the debugger
            selectDebuggerMove(side, index, element) {
                // Deselect all moves in this column
                const container = element.parentElement;
                container.querySelectorAll('.move-option').forEach(opt => opt.classList.remove('selected'));
                
                // Select this move
                element.classList.add('selected');
                
                // Store selection
                if (side === 'player') {
                    this.debugger.selectedPlayerMove = index;
                    console.log(`🛠️ Player move selected: index ${index}`);
                } else {
                    this.debugger.selectedOpponentMove = index;
                    console.log(`🛠️ Opponent move selected: index ${index}`);
                }
                
                this.updateDebuggerStatus();
            },
            
            // Update debugger status message
            updateDebuggerStatus() {
                const statusDiv = document.getElementById('debuggerStatus');
                
                if (!this.debugger.enabled) {
                    statusDiv.className = 'debugger-status';
                    statusDiv.textContent = 'Debugger disabled - battles will be random';
                    return;
                }
                
                if (!this.currentBattle) {
                    statusDiv.className = 'debugger-status waiting';
                    statusDiv.textContent = 'Awaiting battle initiation...';
                    return;
                }
                
                if (this.debugger.selectedPlayerMove !== null && this.debugger.selectedOpponentMove !== null) {
                    statusDiv.className = 'debugger-status ready';
                    statusDiv.textContent = '✅ Ready! Battle outcome will be forced to selected moves.';
                } else {
                    statusDiv.className = 'debugger-status waiting';
                    const missing = [];
                    if (this.debugger.selectedPlayerMove === null) missing.push('Player');
                    if (this.debugger.selectedOpponentMove === null) missing.push('Opponent');
                    statusDiv.textContent = `⚠️ Select moves for: ${missing.join(', ')}`;
                }
            },
            
            // Clear debugger selections
            clearDebuggerSelections() {
                this.debugger.selectedPlayerMove = null;
                this.debugger.selectedOpponentMove = null;
                document.querySelectorAll('.move-option').forEach(opt => opt.classList.remove('selected'));
                this.updateDebuggerStatus();
            },
            
            // ==========================================
            // STATUS EFFECT MANAGER (DEBUGGER)
            // ==========================================
            
            // Initialize status effect manager UI
            initializeStatusEffectManager() {
                const playerSelect = document.getElementById('playerStatusSelect');
                const opponentSelect = document.getElementById('opponentStatusSelect');
                
                if (playerSelect) {
                    playerSelect.addEventListener('change', (e) => {
                        if (e.target.value) {
                            this.addStatusEffectFromDebugger('player', e.target.value);
                            e.target.value = ''; // Reset select
                        }
                    });
                }
                
                if (opponentSelect) {
                    opponentSelect.addEventListener('change', (e) => {
                        if (e.target.value) {
                            this.addStatusEffectFromDebugger('opponent', e.target.value);
                            e.target.value = ''; // Reset select
                        }
                    });
                }
                
                console.log('🧪 Status Effect Manager initialized');
            },
            
            // Show/hide status effect manager based on battle state
            updateStatusEffectManagerVisibility() {
                const statusManager = document.getElementById('debuggerStatusManager');
                if (this.currentBattle && this.debugger.panelOpen) {
                    statusManager.style.display = 'block';
                    this.refreshStatusEffectDisplay();
                } else {
                    statusManager.style.display = 'none';
                }
            },
            
            // Add status effect from debugger
            addStatusEffectFromDebugger(side, statusName) {
                if (!this.currentBattle) {
                    console.error('❌ No active battle');
                    return;
                }
                
                const robotInstanceId = side === 'player' ? 
                    this.currentBattle.attackerRobotInstanceId : 
                    this.currentBattle.defenderRobotInstanceId;
                
                if (!robotInstanceId) {
                    console.error('❌ Robot instance ID not found');
                    return;
                }
                
                // Add status effect to the robot
                const wasAdded = this.addStatusEffect(robotInstanceId, statusName);
                
                // Only modify opponent's move if status was successfully added
                if (wasAdded) {
                    // Also modify the OPPONENT's currently selected move to inflict this status
                    // This allows testing: add frozen to opponent, and YOUR move will freeze them
                    const opposingSide = side === 'player' ? 'opponent' : 'player';
                    const opposingMoveIndex = opposingSide === 'player' ? 
                        this.debugger.selectedPlayerMove : 
                        this.debugger.selectedOpponentMove;
                    
                    if (opposingMoveIndex !== null) {
                        const opposingRobot = opposingSide === 'player' ? 
                            this.currentBattle.attackerRobot : 
                            this.currentBattle.defenderRobot;
                        
                        if (opposingRobot && opposingRobot.wheel && opposingRobot.wheel[opposingMoveIndex]) {
                            const move = opposingRobot.wheel[opposingMoveIndex];
                            
                            // Map status names to effect descriptions
                            const statusEffects = {
                                'poison': 'The battle opponent becomes poisoned',
                                'noxious': 'The battle opponent becomes noxious',
                                'burn': 'The battle opponent becomes burned',
                                'sleep': 'The battle opponent falls asleep',
                                'frozen': 'The battle opponent becomes frozen',
                                'paralysis': 'The battle opponent becomes paralyzed',
                                'confusion': 'The battle opponent becomes confused'
                            };
                            
                            // Add the status effect to the move
                            move.effect = statusEffects[statusName] || move.effect;
                            console.log(`🧪 Modified ${opposingSide}'s move "${move.moveName}" to inflict ${statusName}`);
                        }
                    }
                }
                
                const robotData = RobotDatabase.getRobot(robotInstanceId.replace(/-opp$/, '').replace(/-c-\d+$/, '').replace(/-uc-\d+$/, '').replace(/-r-\d+$/, '').replace(/-ex-\d+$/, ''));
                if (wasAdded) {
                    console.log(`🧪 Successfully added ${statusName} to ${robotData?.name || robotInstanceId} (${side})`);
                } else {
                    console.log(`⚠️ Could not add ${statusName} to ${robotData?.name || robotInstanceId} (${side}) - see above for reason`);
                }
                
                // Refresh displays
                this.refreshStatusEffectDisplay();
                this.populateDebugger(
                    this.currentBattle.attackerRobot,
                    this.currentBattle.defenderRobot,
                    this.currentBattle.attackerTeam,
                    this.currentBattle.defenderTeam
                );
                
                // Update visual indicators on field
                const pointId = side === 'player' ? 
                    this.currentBattle.attackerPointId : 
                    this.currentBattle.defenderPointId;
                this.updateRobotStatusIndicators(pointId, robotInstanceId);
            },
            
            // Remove status effect from debugger
            removeStatusEffectFromDebugger(side, statusName) {
                if (!this.currentBattle) return;
                
                const robotInstanceId = side === 'player' ? 
                    this.currentBattle.attackerRobotInstanceId : 
                    this.currentBattle.defenderRobotInstanceId;
                
                if (!robotInstanceId) return;
                
                // Remove status effect
                this.removeStatusEffect(robotInstanceId, statusName);
                
                const robotData = RobotDatabase.getRobot(robotInstanceId.replace(/-opp$/, '').replace(/-c-\d+$/, '').replace(/-uc-\d+$/, '').replace(/-r-\d+$/, '').replace(/-ex-\d+$/, ''));
                console.log(`🧪 Removed ${statusName} from ${robotData?.name || robotInstanceId} (${side})`);
                
                // Refresh displays
                this.refreshStatusEffectDisplay();
                this.populateDebugger(
                    this.currentBattle.attackerRobot,
                    this.currentBattle.defenderRobot,
                    this.currentBattle.attackerTeam,
                    this.currentBattle.defenderTeam
                );
                
                // Update visual indicators on field
                const pointId = side === 'player' ? 
                    this.currentBattle.attackerPointId : 
                    this.currentBattle.defenderPointId;
                this.updateRobotStatusIndicators(pointId, robotInstanceId);
            },
            
            // Refresh status effect display in debugger
            refreshStatusEffectDisplay() {
                if (!this.currentBattle) return;
                
                const playerRobotId = this.currentBattle.attackerRobotInstanceId;
                const opponentRobotId = this.currentBattle.defenderRobotInstanceId;
                
                this.updateStatusEffectList('player', playerRobotId);
                this.updateStatusEffectList('opponent', opponentRobotId);
            },
            
            // Update status effect list for a side
            updateStatusEffectList(side, robotInstanceId) {
                const listId = side === 'player' ? 'playerStatusEffects' : 'opponentStatusEffects';
                const listElement = document.getElementById(listId);
                
                if (!listElement || !robotInstanceId) return;
                
                // Get active status effects for this robot
                const activeEffects = [];
                if (this.robotStatusEffects[robotInstanceId]) {
                    // Iterate through conditions Set
                    if (this.robotStatusEffects[robotInstanceId].conditions) {
                        this.robotStatusEffects[robotInstanceId].conditions.forEach(statusName => {
                            activeEffects.push(statusName);
                        });
                    }
                    // Iterate through markers Set
                    if (this.robotStatusEffects[robotInstanceId].markers) {
                        this.robotStatusEffects[robotInstanceId].markers.forEach(statusName => {
                            activeEffects.push(statusName);
                        });
                    }
                }
                
                // Clear and rebuild list
                listElement.innerHTML = '';
                
                if (activeEffects.length === 0) {
                    const noStatusMsg = document.createElement('div');
                    noStatusMsg.className = 'no-status-message';
                    noStatusMsg.textContent = 'No active status effects';
                    listElement.appendChild(noStatusMsg);
                } else {
                    activeEffects.forEach(statusName => {
                        const statusDef = this.statusEffectDefinitions[statusName];
                        if (!statusDef) return;
                        
                        const statusItem = document.createElement('div');
                        statusItem.className = 'status-effect-item';
                        
                        const statusNameDiv = document.createElement('div');
                        statusNameDiv.className = 'status-effect-name';
                        statusNameDiv.textContent = `${statusDef.icon} ${statusDef.name}`;
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'status-effect-remove';
                        removeBtn.textContent = '×';
                        removeBtn.title = `Remove ${statusDef.name}`;
                        removeBtn.onclick = () => this.removeStatusEffectFromDebugger(side, statusName);
                        
                        statusItem.appendChild(statusNameDiv);
                        statusItem.appendChild(removeBtn);
                        listElement.appendChild(statusItem);
                    });
                }
            },
            
            // ==========================================
            // AUDIO SYSTEM
            // ==========================================
            battleMusic: null, // Audio element for battle music
            
            // ==========================================
            // PRECISE GRID-BASED GAME BOARD MAPPING
            // Based on 7x5 grid with proper connections
            // ==========================================
            gameBoard: {
                // ROW 1: Top row (Opponent's side)
                // (OE1A) (O1B) (O1C) (O1D-GOAL) (O1E) (O1F) (OE1G)
                routePoints: {
                    // O1B - Outer Square space
                    'point-top-1': { 
                        x: 166, y: 100, 
                        type: 'route', 
                        grid: 'O1B',
                        position: 'top-1', 
                        connections: ['entry-top-left', 'point-top-2'] 
                    },
                    // O1C - Outer Square space
                    'point-top-2': { 
                        x: 266, y: 100, 
                        type: 'route', 
                        grid: 'O1C',
                        position: 'top-2', 
                        connections: ['point-top-1', 'goal-opponent', 'point-inner-top'] 
                    },
                    // O1E - Outer Square space
                    'point-top-3': { 
                        x: 399, y: 100, 
                        type: 'route', 
                        grid: 'O1E',
                        position: 'top-3', 
                        connections: ['goal-opponent', 'point-top-4'] 
                    },
                    // O1F - Outer Square space
                    'point-top-4': { 
                        x: 499, y: 100, 
                        type: 'route', 
                        grid: 'O1F',
                        position: 'top-4', 
                        connections: ['point-top-3', 'entry-top-right'] 
                    },
                    
                    // ROW 2: O2A, I2B, I2D, I2F, O2G
                    // O2A - Outer Square space
                    'point-left-1': { 
                        x: 67, y: 224, 
                        type: 'route', 
                        grid: 'O2A',
                        position: 'left-1', 
                        connections: ['entry-top-left', 'point-left-2'] 
                    },
                    
                    // ROW 3: O3A, I3B, I3F, O3G
                    // O3A - Outer Square space
                    'point-left-2': { 
                        x: 67, y: 350, 
                        type: 'route', 
                        grid: 'O3A',
                        position: 'left-2', 
                        connections: ['point-left-1', 'point-left-3'] 
                    },
                    
                    // ROW 4: O4A, I4B, I4D, I4F, O4G
                    // O4A - Outer Square space
                    'point-left-3': { 
                        x: 67, y: 476, 
                        type: 'route', 
                        grid: 'O4A',
                        position: 'left-3', 
                        connections: ['point-left-2', 'entry-bottom-left'] 
                    },
                    
                    // O2G - Outer Square space (right side row 2)
                    'point-right-1': { 
                        x: 599, y: 224, 
                        type: 'route', 
                        grid: 'O2G',
                        position: 'right-1', 
                        connections: ['entry-top-right', 'point-right-2'] 
                    },
                    // O3G - Outer Square space (right side row 3)
                    'point-right-2': { 
                        x: 599, y: 350, 
                        type: 'route', 
                        grid: 'O3G',
                        position: 'right-2', 
                        connections: ['point-right-1', 'point-right-3'] 
                    },
                    // O4G - Outer Square space (right side row 4)
                    'point-right-3': { 
                        x: 599, y: 476, 
                        type: 'route', 
                        grid: 'O4G',
                        position: 'right-3', 
                        connections: ['point-right-2', 'entry-bottom-right'] 
                    },
                    
                    // ROW 5: Bottom row (Player's side)
                    // (OE5A) (O5B) (O5C) (O5D-GOAL) (O5E) (O5F) (OE5G)
                    // O5B - Outer Square space
                    'point-bottom-1': { 
                        x: 166, y: 600, 
                        type: 'route', 
                        grid: 'O5B',
                        position: 'bottom-1', 
                        connections: ['entry-bottom-left', 'point-bottom-2'] 
                    },
                    // O5C - Outer Square space
                    'point-bottom-2': { 
                        x: 266, y: 600, 
                        type: 'route', 
                        grid: 'O5C',
                        position: 'bottom-2', 
                        connections: ['point-bottom-1', 'goal-player'] 
                    },
                    // O5E - Outer Square space
                    'point-bottom-3': { 
                        x: 399, y: 600, 
                        type: 'route', 
                        grid: 'O5E',
                        position: 'bottom-3', 
                        connections: ['goal-player', 'point-bottom-4', 'point-inner-bottom'] 
                    },
                    // O5F - Outer Square space
                    'point-bottom-4': { 
                        x: 499, y: 600, 
                        type: 'route', 
                        grid: 'O5F',
                        position: 'bottom-4', 
                        connections: ['point-bottom-3', 'entry-bottom-right'] 
                    }
                },
                
                // INNER SQUARE POINTS (8 total)
                innerPoints: {
                    // I2B - Inner Square Space (Row 2, Col B)
                    'point-inner-tl': { 
                        x: 200, y: 250, 
                        type: 'inner', 
                        grid: 'I2B',
                        position: 'inner-top-left', 
                        connections: ['entry-top-left', 'point-inner-top', 'point-inner-left'] 
                    },
                    // I2F - Inner Square Space (Row 2, Col F)
                    'point-inner-tr': { 
                        x: 466, y: 250, 
                        type: 'inner', 
                        grid: 'I2F',
                        position: 'inner-top-right', 
                        connections: ['entry-top-right', 'point-inner-top', 'point-inner-right'] 
                    },
                    // I4B - Inner Square Space (Row 4, Col B)
                    'point-inner-bl': { 
                        x: 200, y: 450, 
                        type: 'inner', 
                        grid: 'I4B',
                        position: 'inner-bottom-left', 
                        connections: ['entry-bottom-left', 'point-inner-left', 'point-inner-bottom'] 
                    },
                    // I4F - Inner Square Space (Row 4, Col F)
                    'point-inner-br': { 
                        x: 466, y: 450, 
                        type: 'inner', 
                        grid: 'I4F',
                        position: 'inner-bottom-right', 
                        connections: ['entry-bottom-right', 'point-inner-right', 'point-inner-bottom'] 
                    },
                    // I2D - Inner Square Space (Row 2, Col D - top middle)
                    'point-inner-top': { 
                        x: 333, y: 250, 
                        type: 'inner', 
                        grid: 'I2D',
                        position: 'inner-top-mid', 
                        connections: ['point-inner-tl', 'point-top-2', 'point-inner-tr'] 
                    },
                    // I4D - Inner Square Space (Row 4, Col D - bottom middle)
                    'point-inner-bottom': { 
                        x: 333, y: 450, 
                        type: 'inner', 
                        grid: 'I4D',
                        position: 'inner-bottom-mid', 
                        connections: ['point-inner-bl', 'point-inner-br', 'point-bottom-3'] 
                    },
                    // I3B - Inner Square Space (Row 3, Col B - left middle)
                    'point-inner-left': { 
                        x: 200, y: 350, 
                        type: 'inner', 
                        grid: 'I3B',
                        position: 'inner-left-mid', 
                        connections: ['point-inner-tl', 'point-inner-bl'] 
                    },
                    // I3F - Inner Square Space (Row 3, Col F - right middle)
                    'point-inner-right': { 
                        x: 466, y: 350, 
                        type: 'inner', 
                        grid: 'I3F',
                        position: 'inner-right-mid', 
                        connections: ['point-inner-tr', 'point-inner-br'] 
                    }
                },
                
                // GOAL POINTS (2 total) - WIN CONDITIONS
                goalPoints: {
                    // O1D - Opponent's Goal (Player wins if they reach this)
                    'goal-opponent': { 
                        x: 333, y: 100, 
                        type: 'goal', 
                        team: 'opponent',
                        grid: 'O1D',
                        position: 'top-goal', 
                        connections: ['point-top-2', 'point-top-3'] 
                    },
                    // O5D - Player's Goal (Opponent wins if they reach this)
                    'goal-player': { 
                        x: 333, y: 600, 
                        type: 'goal', 
                        team: 'player',
                        grid: 'O5D',
                        position: 'bottom-goal', 
                        connections: ['point-bottom-2', 'point-bottom-3'] 
                    }
                },
                
                // ENTRY POINTS (4 total) - SPAWN LOCATIONS
                entryPoints: {
                    // OE1A - Opponent's Entry (top-left)
                    'entry-top-left': { 
                        x: 67, y: 100, 
                        type: 'entry', 
                        grid: 'OE1A',
                        position: 'top-left', 
                        spawnPoint: true, 
                        team: 'opponent', 
                        connections: ['point-top-1', 'point-left-1', 'point-inner-tl'] 
                    },
                    // OE1G - Opponent's Entry (top-right)
                    'entry-top-right': { 
                        x: 599, y: 100, 
                        type: 'entry', 
                        grid: 'OE1G',
                        position: 'top-right', 
                        spawnPoint: true, 
                        team: 'opponent', 
                        connections: ['point-top-4', 'point-right-1', 'point-inner-tr'] 
                    },
                    // OE5A - Player's Entry (bottom-left)
                    'entry-bottom-left': { 
                        x: 67, y: 600, 
                        type: 'entry', 
                        grid: 'OE5A',
                        position: 'bottom-left', 
                        spawnPoint: true, 
                        team: 'player', 
                        connections: ['point-bottom-1', 'point-left-3', 'point-inner-bl'] 
                    },
                    // OE5G - Player's Entry (bottom-right)
                    'entry-bottom-right': { 
                        x: 599, y: 600, 
                        type: 'entry', 
                        grid: 'OE5G',
                        position: 'bottom-right', 
                        spawnPoint: true, 
                        team: 'player', 
                        connections: ['point-bottom-4', 'point-right-3', 'point-inner-br'] 
                    }
                }
            },
            
            // Player Zones Mapping
            playerZones: {
                player: {
                    benchSlots: {
                        'bench-slot-1': { position: 'secondary-left', capacity: 1, robotId: null },
                        'bench-slot-2': { position: 'secondary-right', capacity: 1, robotId: null },
                        'bench-slot-3': { position: 'primary-1', capacity: 1, robotId: null },
                        'bench-slot-4': { position: 'primary-2', capacity: 1, robotId: null },
                        'bench-slot-5': { position: 'primary-3', capacity: 1, robotId: null },
                        'bench-slot-6': { position: 'primary-4', capacity: 1, robotId: null }
                    },
                    repairBay: [] // FIFO queue: max 2 robots, [{robotId, timestamp}, ...]
                },
                opponent: {
                    benchSlots: {
                        'opponent-bench-slot-1': { position: 'secondary-left', capacity: 1, robotId: null },
                        'opponent-bench-slot-2': { position: 'secondary-right', capacity: 1, robotId: null },
                        'opponent-bench-slot-3': { position: 'primary-1', capacity: 1, robotId: null },
                        'opponent-bench-slot-4': { position: 'primary-2', capacity: 1, robotId: null },
                        'opponent-bench-slot-5': { position: 'primary-3', capacity: 1, robotId: null },
                        'opponent-bench-slot-6': { position: 'primary-4', capacity: 1, robotId: null }
                    },
                    repairBay: [] // FIFO queue: max 2 robots, [{robotId, timestamp}, ...]
                }
            },
            
            // Robot Management
            robots: {
                active: new Map(), // robotId -> { position, stats, abilities }
                bench: new Map(),  // slotId -> robotId
                pc: new Map()      // slotId -> robotId
            },
            
            // Battle State
            battleState: {
                isActive: false,
                currentTurn: 'player', // 'player' or 'opponent'
                turnCount: 0,
                phase: 'setup', // 'setup', 'battle', 'ended'
                winner: null
            },
            
            // Turn Action Tracking (ONE action per turn)
            turnActions: {
                hasMovedRobot: false,      // Has deployed OR moved a robot this turn
                hasBattled: false,          // Has initiated a battle this turn
                actionTakenThisTurn: false, // Any action taken (for UI feedback)
                lastMovedRobotPoint: null   // Track which robot moved (for "lock-in")
            },
            
            // Repair Bay Status Tracking
            rebootingRobots: {}, // { robotId: waitCount } - robots with "Rebooting: X" status
            
            // ==========================================
            // STATUS EFFECT SYSTEM
            // ==========================================
            // Comprehensive status tracking for all robots
            // Format: { robotId: { statuses: Set, markers: Set } }
            robotStatusEffects: {},
            
            // Track when Wait was applied to prevent same-turn expiration
            // Format: { robotId: { team: 'player'|'opponent', ownerTurnCountAtApplication: number, appliedDuringOwnTurn: boolean } }
            // appliedDuringOwnTurn: true = applied during owner's turn (needs to last until NEXT turn ends)
            // appliedDuringOwnTurn: false = applied during opponent's turn (expires at end of CURRENT turn)
            waitStatusTurnTracker: {},
            
            // Team-specific turn counters (increments each time team's turn ENDS)
            playerTurnCount: 0,
            opponentTurnCount: 0,
            
            // Status effect definitions with mechanical effects
            statusEffectDefinitions: {
                // Battle-Inflicted Status Conditions
                'poison': {
                    name: 'Poison',
                    description: 'Damage reduced by 20',
                    type: 'condition',
                    damageReduction: 20,
                    affectedMoveTypes: ['white', 'gold'],
                    icon: '🧪',
                    color: '#9C27B0'
                },
                'noxious': {
                    name: 'Noxious',
                    description: 'Damage reduced by 40',
                    type: 'condition',
                    damageReduction: 40,
                    affectedMoveTypes: ['white', 'gold'],
                    icon: '☠️',
                    color: '#7B1FA2'
                },
                'paralysis': {
                    name: 'Paralysis',
                    description: 'Smallest Attack becomes Miss',
                    type: 'condition',
                    convertsSmallestToMiss: true,
                    icon: '⚡',
                    color: '#FFC107'
                },
                'burn': {
                    name: 'Burn',
                    description: 'Damage reduced by 10 AND smallest Attack becomes Miss',
                    type: 'condition',
                    damageReduction: 10,
                    affectedMoveTypes: ['white', 'gold'],
                    convertsSmallestToMiss: true,
                    icon: '🔥',
                    color: '#FF5722'
                },
                'confusion': {
                    name: 'Confusion',
                    description: 'Combat Dial result shifts one segment clockwise',
                    type: 'condition',
                    shiftsResult: 'clockwise',
                    icon: '😵',
                    color: '#E91E63'
                },
                'sleep': {
                    name: 'Sleep',
                    description: 'Cannot initiate battle or take actions, but can still move',
                    type: 'condition',
                    preventsActions: true,
                    preventsMovement: false,
                    wokenByAttack: true,
                    icon: '💤',
                    color: '#2196F3'
                },
                'frozen': {
                    name: 'Frozen',
                    description: 'Cannot initiate battle, all Attacks become Misses if attacked',
                    type: 'condition',
                    preventsActions: true,
                    preventsMovement: false,
                    allAttacksBecomeMiss: true,
                    thawedByAttack: true,
                    icon: '🧊',
                    color: '#00BCD4'
                },
                
                // Special Markers & Game States
                'waiting': {
                    name: 'Wait',
                    description: 'Cannot be selected for any action for 1 turn. Cannot move, battle, or be deployed from Bench. Expires automatically after 1 turn.',
                    type: 'marker',
                    preventsActions: true,
                    preventsMovement: true,
                    preventsDeployment: true,
                    turnsRemaining: 1,
                    autoExpires: true,
                    icon: '⏸️',
                    color: '#9E9E9E'
                },
                'curse': {
                    name: 'Curse',
                    description: 'Removed from duel permanently when knocked out',
                    type: 'marker',
                    permanentRemovalOnKO: true,
                    icon: '💀',
                    color: '#424242'
                },
                'mp-1': {
                    name: 'MP -1',
                    description: 'Movement Points reduced by 1',
                    type: 'marker',
                    mpReduction: 1,
                    icon: '🐌',
                    color: '#795548'
                }
            },
            
            // ==========================================
            // STATUS EFFECT MANAGEMENT FUNCTIONS
            // ==========================================
            
            // Initialize status tracking for a robot
            initializeRobotStatus(robotId) {
                if (!this.robotStatusEffects[robotId]) {
                    this.robotStatusEffects[robotId] = {
                        conditions: new Set(),  // poison, noxious, paralysis, burn, confusion, sleep, frozen
                        markers: new Set()      // waiting, curse, mp-1
                    };
                }
            },
            
            // Add a status effect to a robot
            addStatusEffect(robotId, statusName) {
                this.initializeRobotStatus(robotId);
                
                const statusDef = this.statusEffectDefinitions[statusName];
                if (!statusDef) {
                    console.error(`❌ Unknown status effect: ${statusName}`);
                    return false;
                }
                
                // POISON/NOXIOUS MUTUAL EXCLUSIVITY RULES:
                // 1. Only one can be applied at once
                // 2. Noxious overrides Poison (if poisoned, noxious replaces it)
                // 3. Poison cannot override Noxious (if noxious, poison is blocked)
                if (statusName === 'poison' || statusName === 'noxious') {
                    const hasPoison = this.hasStatusEffect(robotId, 'poison');
                    const hasNoxious = this.hasStatusEffect(robotId, 'noxious');
                    
                    if (statusName === 'noxious' && hasPoison) {
                        // Noxious overrides Poison - remove poison first
                        this.robotStatusEffects[robotId].conditions.delete('poison');
                        console.log(`☠️ Noxious is overriding existing Poison on ${robotId}`);
                    } else if (statusName === 'poison' && hasNoxious) {
                        // Poison cannot override Noxious - block the application
                        console.log(`🧪 Poison blocked - ${robotId} is already Noxious (stronger effect)`);
                        return false;
                    }
                }
                
                if (statusDef.type === 'condition') {
                    this.robotStatusEffects[robotId].conditions.add(statusName);
                } else if (statusDef.type === 'marker') {
                    this.robotStatusEffects[robotId].markers.add(statusName);
                    
                    // CRITICAL: Track when Wait is applied to prevent same-turn expiration
                    if (statusName === 'waiting') {
                        const robotTeam = this.getRobotTeamById(robotId);
                        const currentTeamTurnCount = robotTeam === 'player' ? this.playerTurnCount : this.opponentTurnCount;
                        const appliedDuringOwnTurn = (this.currentControlTeam === robotTeam);
                        this.waitStatusTurnTracker[robotId] = {
                            team: robotTeam,
                            ownerTurnCountAtApplication: currentTeamTurnCount,
                            appliedDuringOwnTurn: appliedDuringOwnTurn
                        };
                        console.log(`⏸️ Wait tracker set: ${robotId} (${robotTeam} team) at team turn ${currentTeamTurnCount}, appliedDuringOwnTurn=${appliedDuringOwnTurn}`);
                    }
                }
                
                console.log(`${statusDef.icon} Applied ${statusDef.name} to ${robotId}`);
                return true;
            },
            
            // Remove a status effect from a robot
            removeStatusEffect(robotId, statusName) {
                if (!this.robotStatusEffects[robotId]) return false;
                
                const statusDef = this.statusEffectDefinitions[statusName];
                if (!statusDef) return false;
                
                let removed = false;
                
                if (statusDef.type === 'condition') {
                    removed = this.robotStatusEffects[robotId].conditions.delete(statusName);
                } else if (statusDef.type === 'marker') {
                    removed = this.robotStatusEffects[robotId].markers.delete(statusName);
                }
                
                if (removed) {
                    console.log(`✅ Removed ${statusName} from ${robotId}`);
                    // Update visual if robot is on field
                    const pointId = this.findRobotOnField(robotId);
                    if (pointId) {
                        this.updateRobotStatusIndicators(pointId, robotId);
                    }
                }
                
                return removed;
            },
            
            // Check if robot has a specific status
            hasStatusEffect(robotId, statusName) {
                if (!this.robotStatusEffects[robotId]) return false;
                
                const statusDef = this.statusEffectDefinitions[statusName];
                if (!statusDef) return false;
                
                if (statusDef.type === 'condition') {
                    return this.robotStatusEffects[robotId].conditions.has(statusName);
                } else if (statusDef.type === 'marker') {
                    return this.robotStatusEffects[robotId].markers.has(statusName);
                }
                return false;
            },
            
            // Get all status effects for a robot
            getRobotStatuses(robotId) {
                if (!this.robotStatusEffects[robotId]) {
                    return { conditions: [], markers: [] };
                }
                
                return {
                    conditions: Array.from(this.robotStatusEffects[robotId].conditions),
                    markers: Array.from(this.robotStatusEffects[robotId].markers)
                };
            },
            
            // Clear ALL status effects from a robot (used when sent to Repair Bay)
            clearAllStatusEffects(robotId) {
                if (!this.robotStatusEffects[robotId]) return;
                
                const statuses = this.getRobotStatuses(robotId);
                const totalCleared = statuses.conditions.length + statuses.markers.length;
                
                if (totalCleared > 0) {
                    console.log(`🧹 Clearing ${totalCleared} status effect(s) from ${robotId}`);
                    this.robotStatusEffects[robotId].conditions.clear();
                    this.robotStatusEffects[robotId].markers.clear();
                    
                    // Update visual indicators on the field
                    const pointId = this.findRobotOnField(robotId);
                    if (pointId) {
                        this.updateRobotStatusIndicators(pointId, robotId);
                        console.log(`🎯 Cleared status indicators for ${robotId} at ${pointId}`);
                    }
                }
            },
            
            // Expire Wait status for all robots of a team at end of turn
            expireWaitStatusForTeam(team) {
                // Get CURRENT team turn count BEFORE incrementing
                const currentTeamTurnCount = team === 'player' ? this.playerTurnCount : this.opponentTurnCount;
                console.log(`⏸️ Expiring Wait status for ${team} team (team turn: ${currentTeamTurnCount}, checking before increment)...`);
                
                let expiredCount = 0;
                let stillWaitingCount = 0;
                
                // Check all robots with status effects
                for (const robotId in this.robotStatusEffects) {
                    const statuses = this.robotStatusEffects[robotId];
                    
                    // Only process robots with 'waiting' status
                    if (!statuses.markers.has('waiting')) continue;
                    
                    // Find the robot's team by checking all board points
                    const robotTeam = this.getRobotTeamById(robotId);
                    
                    // Only check robots on the team whose turn is ending
                    if (robotTeam === team) {
                        // Check turn tracker
                        const tracker = this.waitStatusTurnTracker[robotId];
                        if (tracker && tracker.ownerTurnCountAtApplication !== undefined) {
                            console.log(`   ${robotId}: Applied at team turn ${tracker.ownerTurnCountAtApplication}, current team turn ${currentTeamTurnCount}, appliedDuringOwnTurn=${tracker.appliedDuringOwnTurn}`);
                            
                            // Expiration logic depends on WHEN Wait was applied:
                            // - If applied during OWNER'S turn: Must complete NEXT full turn (currentTurn > applicationTurn)
                            // - If applied during OPPONENT'S turn: Expires at end of CURRENT turn (currentTurn >= applicationTurn)
                            
                            let shouldExpire = false;
                            if (tracker.appliedDuringOwnTurn) {
                                // Applied during owner's turn - needs to survive until NEXT turn ends
                                shouldExpire = (currentTeamTurnCount > tracker.ownerTurnCountAtApplication);
                                console.log(`   → Applied during own turn: expire if ${currentTeamTurnCount} > ${tracker.ownerTurnCountAtApplication} = ${shouldExpire}`);
                            } else {
                                // Applied during opponent's turn - expires at end of current turn
                                shouldExpire = (currentTeamTurnCount >= tracker.ownerTurnCountAtApplication);
                                console.log(`   → Applied during opponent's turn: expire if ${currentTeamTurnCount} >= ${tracker.ownerTurnCountAtApplication} = ${shouldExpire}`);
                            }
                            
                            if (shouldExpire) {
                                // Expire Wait
                                this.removeStatusEffect(robotId, 'waiting');
                                delete this.waitStatusTurnTracker[robotId];
                                expiredCount++;
                                
                                const robotData = RobotDatabase.getRobot(robotId);
                                console.log(`⏸️ Wait expired for ${robotData?.name || robotId}`);
                                this.addToHistory(`⏸️ ${robotData?.name || robotId} can act again`, 'info', team);
                            } else {
                                // Keep Wait active
                                stillWaitingCount++;
                                console.log(`   ${robotId}: Still waiting`);
                            }
                        } else {
                            // No tracker found - expire immediately (safety fallback)
                            console.warn(`⚠️ ${robotId} has Wait but no tracker - expiring now`);
                            this.removeStatusEffect(robotId, 'waiting');
                            expiredCount++;
                        }
                    }
                }
                
                // NOW increment the turn counter AFTER checking expiration
                if (team === 'player') {
                    this.playerTurnCount++;
                } else {
                    this.opponentTurnCount++;
                }
                console.log(`🔢 Incremented ${team} turn count to ${team === 'player' ? this.playerTurnCount : this.opponentTurnCount}`);
                
                if (expiredCount > 0) {
                    console.log(`✅ Expired Wait status for ${expiredCount} robot(s)`);
                }
                if (stillWaitingCount > 0) {
                    console.log(`⏳ ${stillWaitingCount} robot(s) still waiting`);
                }
                if (expiredCount === 0 && stillWaitingCount === 0) {
                    console.log(`✅ No robots with Wait status on ${team} team`);
                }
            },
            
            // Get robot's team by checking all board points
            getRobotTeamById(robotId) {
                // Check all point types
                const allPoints = [
                    ...Object.values(this.gameBoard.entryPoints),
                    ...Object.values(this.gameBoard.routePoints),
                    ...Object.values(this.gameBoard.innerPoints),
                    ...Object.values(this.gameBoard.goalPoints)
                ];
                
                for (const point of allPoints) {
                    if (point.robot && point.robot.id === robotId) {
                        return point.robot.team;
                    }
                }
                
                // Check bench
                for (const benchRobot of this.bench) {
                    if (benchRobot.id === robotId) {
                        return benchRobot.team;
                    }
                }
                
                // Check repair bay
                for (const repairRobot of this.repairBay) {
                    if (repairRobot.id === robotId) {
                        return repairRobot.team;
                    }
                }
                
                return null;
            },
            
            // Cure standard conditions (Tagging heal)
            cureStandardConditions(robotId) {
                if (!this.robotStatusEffects[robotId]) return;
                
                // Curable via Tagging: poison, noxious, paralysis, burn, confusion, sleep, frozen, mp-1
                const curableConditions = ['poison', 'noxious', 'paralysis', 'burn', 'confusion', 'sleep', 'frozen'];
                const curableMarkers = ['mp-1'];
                
                let curedCount = 0;
                
                curableConditions.forEach(condition => {
                    if (this.robotStatusEffects[robotId].conditions.has(condition)) {
                        this.removeStatusEffect(robotId, condition);
                        curedCount++;
                    }
                });
                
                curableMarkers.forEach(marker => {
                    if (this.robotStatusEffects[robotId].markers.has(marker)) {
                        this.removeStatusEffect(robotId, marker);
                        curedCount++;
                    }
                });
                
                if (curedCount > 0) {
                    console.log(`💚 Healed ${curedCount} condition(s) from ${robotId} via Tagging`);
                }
                
                return curedCount > 0;
            },
            
            // Check if robot has any curable conditions (for Tagging decision)
            hasCurableConditions(robotId) {
                if (!this.robotStatusEffects[robotId]) return false;
                
                const curableConditions = ['poison', 'noxious', 'paralysis', 'burn', 'confusion', 'sleep', 'frozen'];
                const curableMarkers = ['mp-1'];
                
                const hasCondition = curableConditions.some(c => 
                    this.robotStatusEffects[robotId].conditions.has(c)
                );
                const hasMarker = curableMarkers.some(m => 
                    this.robotStatusEffects[robotId].markers.has(m)
                );
                
                return hasCondition || hasMarker;
            },
            
            // Check if robot is disabled (Sleep or Frozen)
            isRobotDisabled(robotId) {
                if (!this.robotStatusEffects[robotId]) return false;
                
                return this.hasStatusEffect(robotId, 'sleep') || 
                       this.hasStatusEffect(robotId, 'frozen');
            },
            
            // Check if robot can be moved
            canRobotMove(robotId) {
                if (!this.robotStatusEffects[robotId]) return true;
                
                // Check for statuses that prevent movement
                const preventingStatuses = ['sleep', 'frozen', 'waiting'];
                return !preventingStatuses.some(status => this.hasStatusEffect(robotId, status));
            },
            
            // Get effective MP for a robot (accounts for MP-1 marker)
            getEffectiveMP(robotId, baseMP) {
                if (!this.robotStatusEffects[robotId]) return baseMP;
                
                let effectiveMP = baseMP;
                
                if (this.hasStatusEffect(robotId, 'mp-1')) {
                    effectiveMP -= 1;
                }
                
                return Math.max(0, effectiveMP);
            },
            
            // ==========================================
            // TAGGING CURE MECHANIC
            // ==========================================
            
            // Get adjacent friendly robots that have curable conditions
            getAdjacentCurableAllies(pointId, team) {
                const point = this.getPointById(pointId);
                if (!point || !point.connections) return [];
                
                const curableAllies = [];
                
                point.connections.forEach(connectedPointId => {
                    const connectedPoint = this.getPointById(connectedPointId);
                    
                    // Check if point has a robot on same team with curable conditions
                    if (connectedPoint && connectedPoint.robot && connectedPoint.robot.team === team) {
                        const allyRobotId = connectedPoint.robot.id;
                        if (this.hasCurableConditions(allyRobotId)) {
                            curableAllies.push({
                                pointId: connectedPointId,
                                robotId: allyRobotId
                            });
                        }
                    }
                });
                
                return curableAllies;
            },
            
            // Check and handle Tagging cure after movement
            // Returns TRUE if turn should end, FALSE if turn should continue
            checkTaggingCure(movedToPointId, team) {
                console.log(`💊 Checking Tagging cure opportunities at ${movedToPointId}...`);
                
                const curableAllies = this.getAdjacentCurableAllies(movedToPointId, team);
                const adjacentEnemies = this.getAdjacentEnemies(movedToPointId, team);
                
                console.log(`   Found ${curableAllies.length} curable allies, ${adjacentEnemies.length} enemies`);
                
                // PRIORITY 1: Adjacent to BOTH enemy AND disabled ally
                if (curableAllies.length > 0 && adjacentEnemies.length > 0) {
                    console.log(`🎯 TAGGING PRIORITY 1: Both enemy and curable ally present - showing choice`);
                    this.showTaggingChoice(movedToPointId, team, curableAllies, adjacentEnemies);
                    return true; // Turn handling delegated to player choice
                }
                
                // PRIORITY 2: Adjacent to ONLY disabled ally (no enemies)
                if (curableAllies.length > 0 && adjacentEnemies.length === 0) {
                    console.log(`💚 TAGGING PRIORITY 2: Only curable ally present - auto-healing`);
                    this.performAutoTaggingHeal(curableAllies, team);
                    return true; // Turn ends automatically after heal
                }
                
                // No curable allies found
                return false; // Continue normal turn flow
            },
            
            // Show UI for player to choose between Battle or Heal
            showTaggingChoice(movedToPointId, team, curableAllies, adjacentEnemies) {
                // Highlight the options
                this.highlightAdjacentEnemies(movedToPointId, team);
                
                // Create choice modal
                const modal = document.createElement('div');
                modal.id = 'taggingChoiceModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    border: 3px solid #4CAF50;
                    border-radius: 15px;
                    padding: 30px;
                    z-index: 10000;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                    color: white;
                    min-width: 400px;
                    text-align: center;
                `;
                
                const allyNames = curableAllies.map(ally => {
                    const robot = RobotDatabase.getRobot(ally.robotId);
                    const statuses = this.getRobotStatuses(ally.robotId);
                    const statusList = [...statuses.conditions, ...statuses.markers].join(', ');
                    return `${robot.name} (${statusList})`;
                }).join('<br>');
                
                modal.innerHTML = `
                    <h2 style="margin: 0 0 20px 0; color: #4CAF50;">⚔️ Tactical Decision</h2>
                    <p style="font-size: 16px; margin-bottom: 20px;">
                        Your robot is adjacent to both an <strong style="color: #f44336;">ENEMY</strong> 
                        and an <strong style="color: #4CAF50;">ALLY</strong> who needs healing!
                    </p>
                    <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 10px; margin: 20px 0;">
                        <strong style="color: #4CAF50;">Allies to Heal:</strong><br>
                        ${allyNames}
                    </div>
                    <p style="font-size: 14px; color: #aaa; margin-bottom: 25px;">
                        You can only choose ONE action:
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="GameBoard.chooseTaggingBattle()" 
                                style="padding: 15px 30px; font-size: 18px; background: #f44336; 
                                       color: white; border: none; border-radius: 10px; cursor: pointer;
                                       box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.3s;">
                            ⚔️ Battle Enemy
                        </button>
                        <button onclick="GameBoard.chooseTaggingHeal(${JSON.stringify(curableAllies)}, '${team}')" 
                                style="padding: 15px 30px; font-size: 18px; background: #4CAF50; 
                                       color: white; border: none; border-radius: 10px; cursor: pointer;
                                       box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.3s;">
                            💚 Heal Ally
                        </button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Store choice context
                this.taggingChoiceContext = {
                    movedToPointId,
                    team,
                    curableAllies,
                    adjacentEnemies
                };
            },
            
            // Player chose to battle
            chooseTaggingBattle() {
                const modal = document.getElementById('taggingChoiceModal');
                if (modal) modal.remove();
                
                console.log(`⚔️ Player chose BATTLE over healing`);
                this.addToHistory('Chose to battle instead of healing ally', 'info', this.taggingChoiceContext.team);
                
                // Enemies are already highlighted, player can click to battle
                // Turn does NOT end automatically
                this.taggingChoiceContext = null;
            },
            
            // Player chose to heal
            chooseTaggingHeal(curableAllies, team) {
                const modal = document.getElementById('taggingChoiceModal');
                if (modal) modal.remove();
                
                console.log(`💚 Player chose HEAL over battling`);
                
                // Heal all adjacent allies
                curableAllies.forEach(ally => {
                    this.cureStandardConditions(ally.robotId);
                    const robot = RobotDatabase.getRobot(ally.robotId);
                    this.addToHistory(`💚 ${robot.name} healed via Tagging!`, 'heal', team);
                });
                
                // Clear enemy highlights
                this.clearAttackableEnemies();
                
                // End turn immediately
                console.log(`⏹️ Turn ending after healing`);
                this.taggingChoiceContext = null;
                setTimeout(() => this.endPlayerTurn(), 500);
            },
            
            // Auto-heal when only allies are adjacent (no choice needed)
            performAutoTaggingHeal(curableAllies, team) {
                console.log(`💚 AUTO-HEALING ${curableAllies.length} adjacent ${curableAllies.length === 1 ? 'ally' : 'allies'}...`);
                
                curableAllies.forEach(ally => {
                    this.cureStandardConditions(ally.robotId);
                    const robot = RobotDatabase.getRobot(ally.robotId);
                    this.addToHistory(`💚 ${robot.name} healed via Tagging!`, 'heal', team);
                    console.log(`   Healed ${robot.name} at ${ally.pointId}`);
                });
                
                // End turn immediately
                console.log(`⏹️ Turn auto-ending after healing (no enemies to battle)`);
                setTimeout(() => this.endPlayerTurn(), 1000);
            },
            
            // ==========================================
            // STATUS EFFECT VISUAL INDICATORS
            // ==========================================
            
            // Add status effect icons to a robot visual
            addStatusEffectIndicators(robotGroup, robotId, centerX, centerY) {
                if (!this.robotStatusEffects[robotId]) return;
                
                const statuses = this.getRobotStatuses(robotId);
                const allStatuses = [...statuses.conditions, ...statuses.markers];
                
                if (allStatuses.length === 0) return;
                
                // Create container for status icons
                const svgNS = "http://www.w3.org/2000/svg";
                const statusContainer = document.createElementNS(svgNS, 'g');
                statusContainer.setAttribute('class', 'status-indicators');
                statusContainer.style.pointerEvents = 'none'; // Don't interfere with robot clicks
                
                // Position icons in a circle around the robot
                const radius = 65; // Distance from robot center
                const iconSize = 24;
                const angleStep = (2 * Math.PI) / Math.max(allStatuses.length, 4); // At least 4 positions
                
                allStatuses.forEach((statusName, index) => {
                    const statusDef = this.statusEffectDefinitions[statusName];
                    if (!statusDef) return;
                    
                    // Calculate position in circle
                    const angle = index * angleStep - (Math.PI / 2); // Start at top
                    const iconX = centerX + radius * Math.cos(angle);
                    const iconY = centerY + radius * Math.sin(angle);
                    
                    // Create circular background
                    const bg = document.createElementNS(svgNS, 'circle');
                    bg.setAttribute('cx', iconX);
                    bg.setAttribute('cy', iconY);
                    bg.setAttribute('r', iconSize / 2);
                    bg.setAttribute('fill', statusDef.color || '#666');
                    bg.setAttribute('stroke', '#fff');
                    bg.setAttribute('stroke-width', '2');
                    bg.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.5))';
                    
                    // Create text icon
                    const icon = document.createElementNS(svgNS, 'text');
                    icon.setAttribute('x', iconX);
                    icon.setAttribute('y', iconY);
                    icon.setAttribute('text-anchor', 'middle');
                    icon.setAttribute('dominant-baseline', 'central');
                    icon.setAttribute('font-size', '16');
                    icon.textContent = statusDef.icon || '?';
                    icon.style.pointerEvents = 'none';
                    
                    // Add tooltip (title element)
                    const title = document.createElementNS(svgNS, 'title');
                    title.textContent = `${statusDef.name}: ${statusDef.description}`;
                    
                    statusContainer.appendChild(bg);
                    statusContainer.appendChild(icon);
                    statusContainer.appendChild(title);
                });
                
                robotGroup.appendChild(statusContainer);
            },
            
            // Update status indicators for a robot (call after status changes)
            updateRobotStatusIndicators(pointId, robotId) {
                const robotGroup = document.getElementById(`robot-${pointId}`);
                if (!robotGroup) return;
                
                // Remove old status indicators
                const oldIndicators = robotGroup.querySelector('.status-indicators');
                if (oldIndicators) {
                    oldIndicators.remove();
                }
                
                // Get point data for positioning
                const pointData = this.getPointById(pointId);
                if (!pointData) return;
                
                // Add new indicators
                this.addStatusEffectIndicators(robotGroup, robotId, pointData.x, pointData.y);
            },
            
            // Utility Functions
            getAllPoints() {
                return {
                    ...this.gameBoard.routePoints,
                    ...this.gameBoard.innerPoints,
                    ...this.gameBoard.entryPoints,
                    ...this.gameBoard.goalPoints
                };
            },
            
            // Find which point a robot is on (returns pointId or null)
            findRobotOnField(robotId) {
                const allPoints = this.getAllPoints();
                for (const [pointId, pointData] of Object.entries(allPoints)) {
                    if (pointData.robot && pointData.robot.id === robotId) {
                        return pointId;
                    }
                }
                return null;
            },
            
            getPointById(pointId) {
                // CRITICAL FIX: Return reference to actual point object, not a copy
                // Check each category directly to maintain reference
                if (this.gameBoard.routePoints[pointId]) {
                    return this.gameBoard.routePoints[pointId];
                }
                if (this.gameBoard.innerPoints[pointId]) {
                    return this.gameBoard.innerPoints[pointId];
                }
                if (this.gameBoard.entryPoints[pointId]) {
                    return this.gameBoard.entryPoints[pointId];
                }
                if (this.gameBoard.goalPoints[pointId]) {
                    return this.gameBoard.goalPoints[pointId];
                }
                return null;
            },
            
            isPointOccupied(pointId) {
                const element = document.getElementById(pointId);
                return element ? element.getAttribute('data-occupied') === 'true' : false;
            },
            
            occupyPoint(pointId, robotId, team = 'neutral') {
                const element = document.getElementById(pointId);
                if (element) {
                    element.setAttribute('data-occupied', 'true');
                    element.setAttribute('data-robot-id', robotId);
                    element.setAttribute('data-team', team);
                    
                    // Add visual robot image
                    this.addRobotVisual(pointId, robotId, team);
                    return true;
                }
                return false;
            },
            
            clearPoint(pointId) {
                const element = document.getElementById(pointId);
                if (element) {
                    element.setAttribute('data-occupied', 'false');
                    element.setAttribute('data-robot-id', '');
                    element.setAttribute('data-team', 'neutral');
                    
                    // Remove visual robot image
                    this.removeRobotVisual(pointId);
                    return true;
                }
                return false;
            },
            
            getValidMoves(fromPointId) {
                const point = this.getPointById(fromPointId);
                if (!point || !point.connections) return [];
                
                return point.connections.filter(pointId => !this.isPointOccupied(pointId));
            },
            
            // Robot Slot Management
            placeRobotInSlot(slotId, robotId, team = 'player') {
                const element = document.getElementById(slotId);
                if (element && element.getAttribute('data-occupied') === 'false') {
                    element.setAttribute('data-occupied', 'true');
                    element.setAttribute('data-robot-id', robotId);
                    
                    // Update internal mapping (bench slots only - Repair Bay uses separate system)
                    if (team === 'player') {
                        if (slotId.includes('bench') && this.playerZones.player.benchSlots[slotId]) {
                            this.playerZones.player.benchSlots[slotId].robotId = robotId;
                        }
                    } else {
                        if (slotId.includes('bench') && this.playerZones.opponent.benchSlots[slotId]) {
                            this.playerZones.opponent.benchSlots[slotId].robotId = robotId;
                        }
                    }
                    return true;
                }
                return false;
            },
            
            removeRobotFromSlot(slotId, team = 'player') {
                const element = document.getElementById(slotId);
                if (element) {
                    const robotId = element.getAttribute('data-robot-id');
                    element.setAttribute('data-occupied', 'false');
                    element.setAttribute('data-robot-id', '');
                    
                    // Update internal mapping (bench slots only - Repair Bay uses separate system)
                    if (team === 'player') {
                        if (slotId.includes('bench') && this.playerZones.player.benchSlots[slotId]) {
                            this.playerZones.player.benchSlots[slotId].robotId = null;
                        }
                    } else {
                        if (slotId.includes('bench') && this.playerZones.opponent.benchSlots[slotId]) {
                            this.playerZones.opponent.benchSlots[slotId].robotId = null;
                        }
                    }
                    return robotId;
                }
                return null;
            },
            
            // Future Integration Points
            initializeBattle() {
                console.log('🤖 Battle System Initialized!');
                console.log('📍 Game Board Points:', Object.keys(this.getAllPoints()).length);
                console.log('🎯 Player Slots:', Object.keys(this.playerZones.player.benchSlots).length);
                console.log('🔧 Repair Bay Capacity: 2 slots per player');
                console.log('\n✨ STATUS EFFECT SYSTEM LOADED!');
                console.log('📋 Available status effects:');
                console.log('   - Conditions: Confusion, Poison, Burn, Noxious, Paralysis, Frozen, Sleep, Wait');
                console.log('   - Markers: MP-1, Rebooting');
                console.log('🧪 Debug Commands:');
                console.log('   GameBoard.debugApplyStatus("robotId", "statusName") - Apply status');
                console.log('   GameBoard.debugShowAllStatuses() - View all active statuses');
                console.log('   GameBoard.debugApplyConfusion("robotId") - Quick shortcuts available');
                console.log('   GameBoard.debugTestStatusBattle("attacker", "defender") - Simulate battle');
                console.log('🤖 Ready for Robot Integration!');
                
                // Initialize movement lock flag
                this.isMovementInProgress = false;
                
                // Initialize Repair Bay displays (empty at start)
                this.updateRepairBayDisplay('player');
                this.updateRepairBayDisplay('opponent');
                console.log('✅ Repair Bay displays initialized (empty)');
                
                // Initialize battle music
                this.battleMusic = new Audio('Audio/Duel1.mp3');
                this.battleMusic.loop = true; // Loop during battle
                this.battleMusic.volume = 0.5; // Set volume to 50%
                console.log('🎵 Battle music initialized');
            },
            
            // Debug Functions
            debugShowAllPoints() {
                const allPoints = this.getAllPoints();
                console.table(allPoints);
            },
            
            debugShowPlayerZones() {
                console.log('Player Zones:', this.playerZones);
            },
            
            // ==========================================
            // STATUS EFFECT DEBUG FUNCTIONS
            // ==========================================
            
            // Apply a status effect to a robot (for testing)
            debugApplyStatus(robotId, statusName) {
                if (!this.statusEffectDefinitions[statusName]) {
                    console.error(`❌ Unknown status: ${statusName}`);
                    console.log('Available statuses:', Object.keys(this.statusEffectDefinitions));
                    return;
                }
                
                this.addStatusEffect(robotId, statusName);
                console.log(`✅ Applied ${statusName} to ${robotId}`);
                
                // Update visual if robot is on field
                const pointId = this.findRobotOnField(robotId);
                if (pointId) {
                    this.updateRobotStatusIndicators(pointId, robotId);
                }
            },
            
            // Remove a status effect from a robot (for testing)
            debugRemoveStatus(robotId, statusName) {
                this.removeStatusEffect(robotId, statusName);
                console.log(`✅ Removed ${statusName} from ${robotId}`);
                
                // Update visual if robot is on field
                const pointId = this.findRobotOnField(robotId);
                if (pointId) {
                    this.updateRobotStatusIndicators(pointId, robotId);
                }
            },
            
            // Clear all status effects from a robot (for testing)
            debugClearAllStatus(robotId) {
                this.clearAllStatusEffects(robotId);
                console.log(`✅ Cleared all status effects from ${robotId}`);
                
                // Update visual if robot is on field
                const pointId = this.findRobotOnField(robotId);
                if (pointId) {
                    this.updateRobotStatusIndicators(pointId, robotId);
                }
            },
            
            // Show all robots with status effects
            debugShowAllStatuses() {
                console.log('📊 STATUS EFFECTS REPORT');
                console.log('═══════════════════════════════════════');
                
                if (!this.robotStatusEffects || Object.keys(this.robotStatusEffects).length === 0) {
                    console.log('No robots have status effects');
                    return;
                }
                
                for (const [robotId, effects] of Object.entries(this.robotStatusEffects)) {
                    const robot = RobotDatabase.getRobot(robotId);
                    const robotName = robot ? robot.name : robotId;
                    console.log(`\n🤖 ${robotName} (${robotId})`);
                    
                    const statuses = this.getRobotStatuses(robotId);
                    
                    if (statuses.conditions.length > 0) {
                        console.log('  Conditions:', statuses.conditions.join(', '));
                    }
                    if (statuses.markers.length > 0) {
                        console.log('  Markers:', statuses.markers.join(', '));
                    }
                }
                
                console.log('═══════════════════════════════════════');
            },
            
            // Test battle with status effects
            debugTestStatusBattle(attackerRobotId, defenderRobotId) {
                const attacker = RobotDatabase.getRobot(attackerRobotId);
                const defender = RobotDatabase.getRobot(defenderRobotId);
                
                if (!attacker || !defender) {
                    console.error('❌ Invalid robot IDs');
                    return;
                }
                
                console.log('🎲 SIMULATING BATTLE WITH STATUS EFFECTS');
                console.log('═══════════════════════════════════════');
                console.log(`⚔️ ${attacker.name} vs ${defender.name}`);
                
                // Show current statuses
                console.log(`\n${attacker.name} statuses:`, this.getRobotStatuses(attackerRobotId));
                console.log(`${defender.name} statuses:`, this.getRobotStatuses(defenderRobotId));
                
                // Simulate spins
                const attackerSpin = this.spinWheel(attacker.wheel);
                const defenderSpin = this.spinWheel(defender.wheel);
                
                console.log(`\n🎲 Original Spins:`);
                console.log(`  ${attacker.name}: ${attackerSpin.moveName} (${attackerSpin.moveType}) - ${attackerSpin.damage || 0} dmg`);
                console.log(`  ${defender.name}: ${defenderSpin.moveName} (${defenderSpin.moveType}) - ${defenderSpin.damage || 0} dmg`);
                
                // Apply status effects
                const modifiedAttackerSpin = this.applyStatusEffectsToBattleSpin(attackerRobotId, attackerSpin, 'attacker', defenderRobotId);
                const modifiedDefenderSpin = this.applyStatusEffectsToBattleSpin(defenderRobotId, defenderSpin, 'defender', attackerRobotId);
                
                console.log(`\n✨ Modified Spins (after status effects):`);
                console.log(`  ${attacker.name}: ${modifiedAttackerSpin.moveName} (${modifiedAttackerSpin.moveType}) - ${modifiedAttackerSpin.damage || 0} dmg`);
                console.log(`  ${defender.name}: ${modifiedDefenderSpin.moveName} (${modifiedDefenderSpin.moveType}) - ${modifiedDefenderSpin.damage || 0} dmg`);
                
                console.log('═══════════════════════════════════════');
            },
            
            // Quick status presets for testing
            debugApplyConfusion(robotId) { this.debugApplyStatus(robotId, 'confusion'); },
            debugApplyPoison(robotId) { this.debugApplyStatus(robotId, 'poison'); },
            debugApplyBurn(robotId) { this.debugApplyStatus(robotId, 'burn'); },
            debugApplyNoxious(robotId) { this.debugApplyStatus(robotId, 'noxious'); },
            debugApplyParalysis(robotId) { this.debugApplyStatus(robotId, 'paralysis'); },
            debugApplyFrozen(robotId) { this.debugApplyStatus(robotId, 'frozen'); },
            debugApplySleep(robotId) { this.debugApplyStatus(robotId, 'sleep'); },
            debugApplyWait(robotId) { this.debugApplyStatus(robotId, 'wait'); },
            debugApplyMPMinus1(robotId) { this.debugApplyStatus(robotId, 'mp-1'); },
            
            // NEW: Verify Grid Connections
            debugVerifyGrid() {
                console.log('🔍 GRID VERIFICATION REPORT');
                console.log('═══════════════════════════════════════');
                
                const allPoints = this.getAllPoints();
                const totalPoints = Object.keys(allPoints).length;
                console.log(`📊 Total Points: ${totalPoints} (Expected: 26)`);
                
                // Verify each point's connections
                let validConnections = 0;
                let invalidConnections = 0;
                
                for (const [pointId, pointData] of Object.entries(allPoints)) {
                    const gridLabel = pointData.grid || 'N/A';
                    console.log(`\n📍 ${pointId} (${gridLabel})`);
                    console.log(`   Type: ${pointData.type}`);
                    console.log(`   Connections: ${pointData.connections.length}`);
                    
                    // Verify each connection exists
                    pointData.connections.forEach(connId => {
                        if (allPoints[connId]) {
                            console.log(`   ✅ ${connId} (${allPoints[connId].grid || 'N/A'})`);
                            validConnections++;
                        } else {
                            console.log(`   ❌ ${connId} - NOT FOUND!`);
                            invalidConnections++;
                        }
                    });
                }
                
                console.log('\n═══════════════════════════════════════');
                console.log(`✅ Valid Connections: ${validConnections}`);
                console.log(`❌ Invalid Connections: ${invalidConnections}`);
                
                // Special spaces verification
                console.log('\n🎯 SPECIAL SPACES:');
                console.log('Entry Points (Player):');
                console.log('  - OE5A (entry-bottom-left)');
                console.log('  - OE5G (entry-bottom-right)');
                console.log('Entry Points (Opponent):');
                console.log('  - OE1A (entry-top-left)');
                console.log('  - OE1G (entry-top-right)');
                console.log('Goal Points:');
                console.log('  - O1D (goal-opponent) - Player wins here');
                console.log('  - O5D (goal-player) - Opponent wins here');
                
                return {
                    totalPoints,
                    validConnections,
                    invalidConnections,
                    isValid: invalidConnections === 0 && totalPoints === 26
                };
            },
            
            // ==========================================
            // PHASE 2: TURN MANAGEMENT & MOVEMENT LOGIC
            // ==========================================
            
            // Game State Machine
            gameStates: {
                SETUP: 'setup',
                PLAYER_TURN: 'player_turn',
                AI_TURN: 'ai_turn',
                PLAYER_WINS: 'player_wins',
                AI_WINS: 'ai_wins',
                DRAW: 'draw'
            },
            
            currentState: 'setup',
            selectedFigure: null,
            validMoves: [],
            validMovePaths: new Map(), // Store paths for each valid move destination
            turnCount: 0,
            isFirstMoveOfGame: true, // First move has -1 MP penalty
            battleHistory: [], // Array to store battle events
            developerLogMode: false, // Toggle between player-friendly and verbose developer logs
            lastTurnStatusLog: '', // Track last status to avoid spam in battle log
            winType: null, // Track win type: 'goal', 'waitwin', 'timeout'
            
            // State Management
            setState(newState) {
                const oldState = this.currentState;
                this.currentState = newState;
                console.log(`🎮 State Change: ${oldState} → ${newState}`);
                this.onStateChange(newState, oldState);
            },
            
            onStateChange(newState, oldState) {
                switch(newState) {
                    case this.gameStates.SETUP:
                        this.onSetupPhase();
                        break;
                    case this.gameStates.PLAYER_TURN:
                        this.onPlayerTurnStart();
                        break;
                    case this.gameStates.AI_TURN:
                        this.onAITurnStart();
                        break;
                    case this.gameStates.PLAYER_WINS:
                    case this.gameStates.AI_WINS:
                    case this.gameStates.DRAW:
                        this.onGameEnd(newState);
                        break;
                }
            },
            
            // Phase Handlers
            onSetupPhase() {
                console.log('🔧 Setup Phase: Preparing battle...');
                this.turnCount = 0;
                this.selectedFigure = null;
                this.validMoves = [];
                
                // No auto-placement - users must deploy their selected robots manually
                console.log('✅ Setup complete. Deploy robots from bench to entry points.');
                
                // Don't auto-start player turn - wait for manual deployment
                // this.setState(this.gameStates.PLAYER_TURN);
            },
            
            onPlayerTurnStart() {
                console.log('👤 Player Turn Started');
                
                // Clean up any ghost robots before turn starts
                this.cleanupGhostRobots();
                
                // REPAIR BAY: Process rebooting status
                this.processRebootingStatus('player');
                
                this.turnCount++;
                this.showEndTurnButton();
                this.highlightPlayerFigures();
                
                // In debug mode, set control to player
                if (this.debugMode) {
                    this.currentControlTeam = 'player';
                    this.showDebugControls();
                    console.log('🐛 DEBUG MODE: Player turn - you control player');
                }
                
                // Check for win conditions
                if (this.checkWinConditions('player')) return;
                
                // Check for WaitWin (System Lock Victory)
                if (this.checkWaitWin('player')) return;
                
                // CRITICAL: TRIGGER 1 - Highlight all adjacent enemies at turn start
                // Small delay to ensure DOM is fully ready
                setTimeout(() => {
                    this.highlightAllAdjacentEnemies('player');
                }, 100);
            },
            
            onAITurnStart() {
                console.log('🤖 AI Turn Started');
                
                // Clean up any ghost robots before turn starts
                this.cleanupGhostRobots();
                
                // REPAIR BAY: Process rebooting status
                this.processRebootingStatus('opponent');
                
                // In debug mode, treat AI turn as opponent turn (manual control)
                if (this.debugMode) {
                    console.log('🐛 DEBUG MODE: AI turn converted to manual opponent control');
                    this.currentControlTeam = 'opponent';
                    this.showEndTurnButton();
                    this.showDebugControls();
                    this.showTurnActionMessage('OPPONENT\'S TURN - You control opponent in debug mode');
                    
                    // CRITICAL: Check for win conditions at start of opponent's turn
                    if (this.checkWinConditions('opponent')) return;
                    
                    // Check for WaitWin in debug mode
                    if (this.checkWaitWin('opponent')) return;
                    
                    // CRITICAL: TRIGGER 1 - Highlight all adjacent enemies at turn start (debug mode)
                    // Small delay to ensure DOM is fully ready
                    setTimeout(() => {
                        this.highlightAllAdjacentEnemies('opponent');
                    }, 100);
                    
                    return; // Don't execute AI logic
                }
                
                // CRITICAL: Check for win conditions before AI executes
                if (this.checkWinConditions('opponent')) return;
                
                // Check for WaitWin before AI executes
                if (this.checkWaitWin('opponent')) return;
                
                // Normal AI mode
                this.disablePlayerInput();
                this.clearHighlights();
                // TODO: Implement AI decision making
                setTimeout(() => {
                    this.executeAITurn();
                }, 1000); // 1 second delay for dramatic effect
            },
            
            onGameEnd(endState) {
                console.log(`🏁 Game Ended: ${endState}`);
                this.disablePlayerInput();
                this.clearHighlights();
                this.showEndGameUI(endState);
            },
            
            // ==========================================
            // PHASE 2: ENHANCED INPUT MANAGEMENT
            // ==========================================
            
            enablePlayerInput() {
                // Add click listeners to player robot images
                const playerRobots = document.querySelectorAll('.player-robot');
                playerRobots.forEach(robot => {
                    robot.style.cursor = 'pointer';
                    robot.style.pointerEvents = 'auto'; // Enable clicks on robot images
                    robot.addEventListener('click', this.onRobotClick.bind(this));
                });
                
                // Also add click listeners to the points themselves as backup
                const playerPoints = document.querySelectorAll('[data-team="player"][data-occupied="true"]');
                playerPoints.forEach(point => {
                    point.style.cursor = 'pointer';
                    point.addEventListener('click', this.onFigureClick.bind(this));
                });
                
                // Add click-outside deselection
                this.setupClickOutsideDeselection();
            },
            
            disablePlayerInput() {
                // Remove click listeners from robot images
                const allRobots = document.querySelectorAll('.battle-robot');
                allRobots.forEach(robot => {
                    robot.style.cursor = 'default';
                    robot.style.pointerEvents = 'none';
                    robot.removeEventListener('click', this.onRobotClick.bind(this));
                });
                
                // Remove click listeners from points
                const allPoints = document.querySelectorAll('[data-occupied="true"]');
                allPoints.forEach(point => {
                    point.style.cursor = 'default';
                    point.removeEventListener('click', this.onFigureClick.bind(this));
                });
                
                // Remove click-outside listener
                this.removeClickOutsideDeselection();
            },
            
            // Click-outside deselection handler
            setupClickOutsideDeselection() {
                // Remove existing listener if any
                this.removeClickOutsideDeselection();
                
                // Create bound function for removal later
                this.clickOutsideHandler = (event) => {
                    // Only handle if we have a selection
                    if (!this.selectedFigure) return;
                    
                    // Check if click is on a valid move
                    if (event.target.classList.contains('valid-move')) return;
                    
                    // Check if click is on the selected robot or point
                    const clickedId = event.target.id || event.target.closest('[id]')?.id;
                    if (clickedId === this.selectedFigure || clickedId === `robot-${this.selectedFigure}`) return;
                    
                    // Check if click is on another player robot (will trigger reselection)
                    if (event.target.classList.contains('player-robot') || 
                        event.target.closest('.player-robot')) return;
                    
                    // Check if click is on a player-occupied point
                    const clickedPoint = event.target.closest('.point');
                    if (clickedPoint && clickedPoint.getAttribute('data-team') === 'player' && 
                        clickedPoint.getAttribute('data-occupied') === 'true') return;
                    
                    // Otherwise, deselect
                    console.log('🖱️ Click outside detected - deselecting');
                    this.deselectFigure();
                };
                
                // Add listener to the game field
                const gameField = document.querySelector('.game-field');
                if (gameField) {
                    gameField.addEventListener('click', this.clickOutsideHandler);
                }
            },
            
            removeClickOutsideDeselection() {
                if (this.clickOutsideHandler) {
                    const gameField = document.querySelector('.game-field');
                    if (gameField) {
                        gameField.removeEventListener('click', this.clickOutsideHandler);
                    }
                    this.clickOutsideHandler = null;
                }
            },
            
            // Robot Click Handler (for visual robot images)
            onRobotClick(event) {
                if (this.currentState !== this.gameStates.PLAYER_TURN) return;
                
                const robotImg = event.currentTarget;
                const pointId = robotImg.id.replace('robot-', ''); // Extract point ID from robot ID
                
                console.log(`🎯 Robot clicked at point: ${pointId}`);
                this.selectFigure(pointId);
            },
            
            // Figure Selection and Movement
            onFigureClick(event) {
                if (this.currentState !== this.gameStates.PLAYER_TURN) return;
                
                const clickedElement = event.currentTarget;
                const figureId = clickedElement.id;
                
                console.log(`🎯 Figure clicked: ${figureId}`);
                
                // If clicking the same figure, deselect
                if (this.selectedFigure === figureId) {
                    this.deselectFigure();
                    return;
                }
                
                // If clicking a different player figure, select it
                if (clickedElement.getAttribute('data-team') === 'player') {
                    this.selectFigure(figureId);
                    return;
                }
                
                // If clicking an opponent figure while having a selection, try to attack
                if (this.selectedFigure && clickedElement.getAttribute('data-team') === 'opponent') {
                    this.tryAttack(this.selectedFigure, figureId);
                    return;
                }
            },
            
            selectFigure(figureId) {
                this.deselectFigure(); // Clear previous selection
                this.selectedFigure = figureId;
                
                // Highlight selected robot image
                const robotImg = document.getElementById(`robot-${figureId}`);
                if (robotImg) {
                    robotImg.classList.add('selected');
                }
                
                // Also highlight the point for backup
                const figureElement = document.getElementById(figureId);
                if (figureElement) {
                    figureElement.classList.add('selected');
                }
                
                // Calculate and show valid moves
                this.calculateValidMoves(figureId);
                this.highlightValidMoves();
                
                console.log(`✅ Selected figure: ${figureId}`);
            },
            
            deselectFigure() {
                if (this.selectedFigure) {
                    // Remove selection from robot image
                    const robotImg = document.getElementById(`robot-${this.selectedFigure}`);
                    if (robotImg) {
                        robotImg.classList.remove('selected');
                    }
                    
                    // Remove selection from point
                    const figureElement = document.getElementById(this.selectedFigure);
                    if (figureElement) {
                        figureElement.classList.remove('selected');
                    }
                }
                this.selectedFigure = null;
                this.validMoves = [];
                this.clearMoveHighlights();
            },
            
            // ==========================================
            // PHASE 2: CHESS-LIKE MOVEMENT CALCULATION
            // ==========================================
            
            // Calculate valid moves with BLOCKING RULE enforcement
            calculateValidMoves(figureId) {
                const point = this.getPointById(figureId);
                if (!point) return;
                
                // Get MP from robot data
                const pointElement = document.getElementById(figureId);
                const robotId = pointElement ? pointElement.getAttribute('data-robot-id') : null;
                const robot = robotId ? RobotDatabase.getRobot(robotId) : null;
                const movementPoints = robot ? robot.mp : 2; // Default to 2 if no robot data
                
                // Use enhanced BFS with blocking rule
                const result = this.breadthFirstSearchWithBlocking(figureId, movementPoints);
                this.validMoves = result.validMoves;
                this.movePaths = result.paths; // Store paths for animation
                
                console.log(`📍 Valid moves for ${figureId} (${robot ? robot.name : 'Unknown'} - ${movementPoints} MP):`, this.validMoves);
                console.log(`🛤️ Paths calculated:`, this.movePaths);
            },
            
            // Enhanced BFS with BLOCKING RULE: occupied spaces block paths
            breadthFirstSearchWithBlocking(startPointId, maxDistance) {
                const visited = new Set();
                const queue = [{ pointId: startPointId, distance: 0, path: [startPointId] }];
                const validMoves = [];
                const paths = {}; // Store the path to each valid destination
                
                while (queue.length > 0) {
                    const { pointId, distance, path } = queue.shift();
                    
                    if (visited.has(pointId)) continue;
                    visited.add(pointId);
                    
                    // If this isn't the starting point and it's within range
                    if (pointId !== startPointId && distance <= maxDistance) {
                        // Only add if the destination is not occupied
                        if (!this.isPointOccupied(pointId)) {
                            validMoves.push(pointId);
                            paths[pointId] = path; // Store the path to this destination
                        }
                    }
                    
                    // BLOCKING RULE: Don't explore beyond occupied spaces (except starting point)
                    const isBlocked = pointId !== startPointId && this.isPointOccupied(pointId);
                    
                    // Add neighbors to queue if we haven't reached max distance and path isn't blocked
                    if (distance < maxDistance && !isBlocked) {
                        const point = this.getPointById(pointId);
                        if (point && point.connections) {
                            point.connections.forEach(neighborId => {
                                if (!visited.has(neighborId)) {
                                    queue.push({ 
                                        pointId: neighborId, 
                                        distance: distance + 1,
                                        path: [...path, neighborId] // Build the path
                                    });
                                }
                            });
                        }
                    }
                }
                
                return { validMoves, paths };
            },
            
            // Legacy BFS (kept for backward compatibility)
            breadthFirstSearch(startPointId, maxDistance) {
                const result = this.breadthFirstSearchWithBlocking(startPointId, maxDistance);
                return result.validMoves;
            },
            
            // Visual Feedback
            highlightPlayerFigures() {
                const playerRobots = document.querySelectorAll('.player-robot');
                playerRobots.forEach(robot => {
                    robot.classList.add('player-turn-highlight');
                });
            },
            
            highlightValidMoves() {
                this.validMoves.forEach(pointId => {
                    const element = document.getElementById(pointId);
                    if (element) {
                        element.classList.add('valid-move');
                        element.style.cursor = 'pointer';
                        element.addEventListener('click', this.onValidMoveClick.bind(this));
                        
                        // Show movable space image for standard points only
                        if (element.classList.contains('standard-point')) {
                            const movableImage = document.querySelector(`.movable-space-image[data-point="${pointId}"]`);
                            if (movableImage) {
                                movableImage.classList.add('active');
                            }
                        }
                        
                        // Highlight goal space image for goal points
                        if (element.classList.contains('goal-point')) {
                            const goalImage = document.querySelector(`.goal-space-image[data-goal="${pointId}"]`);
                            if (goalImage) {
                                goalImage.classList.add('valid-goal');
                            }
                        }
                    }
                });
            },
            
            clearHighlights() {
                // Clear robot highlights
                document.querySelectorAll('.battle-robot').forEach(robot => {
                    robot.classList.remove('player-turn-highlight', 'selected');
                });
                
                // Clear point highlights
                document.querySelectorAll('.point').forEach(point => {
                    point.classList.remove('player-turn-highlight', 'selected', 'valid-move');
                    point.style.cursor = '';
                });
                
                // Clear movable space images
                document.querySelectorAll('.movable-space-image').forEach(img => {
                    img.classList.remove('active');
                });
            },
            
            clearMoveHighlights() {
                document.querySelectorAll('.valid-move').forEach(element => {
                    element.classList.remove('valid-move');
                    element.style.cursor = '';
                    element.removeEventListener('click', this.onValidMoveClick.bind(this));
                });
                
                // Clear movable space images
                document.querySelectorAll('.movable-space-image').forEach(img => {
                    img.classList.remove('active');
                });
            },
            
            // Move Execution
            onValidMoveClick(event) {
                const targetPointId = event.currentTarget.id;
                if (this.selectedFigure && this.validMoves.includes(targetPointId)) {
                    this.executeMove(this.selectedFigure, targetPointId);
                }
            },
            
            executeMove(fromPointId, toPointId) {
                // ⚠️ DEPRECATED: This old movement system is disabled
                // Use the new moveRobotToPoint() system instead
                console.warn(`⚠️ OLD executeMove() called - this should not happen! Use moveRobotToPoint() instead.`);
                console.warn(`   Attempted move: ${fromPointId} → ${toPointId}`);
                return;
                
                /* OLD CODE DISABLED
                console.log(`🚀 Moving from ${fromPointId} to ${toPointId}`);
                
                // Get robot data from source
                const sourceElement = document.getElementById(fromPointId);
                const robotId = sourceElement.getAttribute('data-robot-id');
                const team = sourceElement.getAttribute('data-team');
                
                // Animate the visual movement first
                this.moveRobotVisual(fromPointId, toPointId);
                
                // Wait for animation to complete, then update data
                setTimeout(() => {
                    // Clear source point (this will remove the old visual)
                    this.clearPoint(fromPointId);
                    
                    // Occupy target point (this will add new visual)
                    this.occupyPoint(toPointId, robotId, team);
                    
                    // Clear selection and highlights
                    this.deselectFigure();
                    
                    // Check for surrounded enemies (instant KO!)
                    GameBoard.checkForSurrounds(team);
                    
                    // Check for adjacent enemies (highlight them, don't auto-battle or end turn)
                    const adjacentEnemies = this.getAdjacentEnemies(toPointId, team);
                    if (adjacentEnemies.length > 0) {
                        this.highlightAdjacentEnemies(toPointId, team);
                    }
                    
                    // Clear first move flag after first move completes
                    if (GameBoard.isFirstMoveOfGame) {
                        GameBoard.isFirstMoveOfGame = false;
                        console.log('✅ First move completed - future moves will use full MP');
                    }
                    
                    // DON'T auto-end turn - let player move other robots or click "End Turn"
                    console.log('✅ Move complete. You can move other robots or click "End Turn"');
                }, 500); // Match the CSS transition time
                */
            },
            
            getAdjacentEnemies(pointId, team) {
                const point = this.getPointById(pointId);
                if (!point || !point.connections) return [];
                
                const enemyTeam = team === 'player' ? 'opponent' : 'player';
                const adjacentEnemies = [];
                
                point.connections.forEach(connectedPointId => {
                    const connectedPoint = this.getPointById(connectedPointId);
                    
                    // Check if point has a robot and it's an enemy
                    if (connectedPoint && connectedPoint.robot && connectedPoint.robot.team === enemyTeam) {
                        adjacentEnemies.push(connectedPointId);
                    }
                });
                
                return adjacentEnemies;
            },
            
            // TRIGGER 1: Global scan - Highlight ALL adjacent enemies at turn start
            highlightAllAdjacentEnemies(team) {
                console.log(`🔍 TRIGGER 1 - TURN START: Scanning all ${team} robots for adjacent enemies...`);
                
                // Scan all points on the board
                const allPoints = [
                    ...Object.entries(this.gameBoard.entryPoints),
                    ...Object.entries(this.gameBoard.routePoints),
                    ...Object.entries(this.gameBoard.innerPoints),
                    ...Object.entries(this.gameBoard.goalPoints)
                ];
                
                let totalEnemiesHighlighted = 0;
                
                // Check each robot belonging to the current team
                for (const [pointId, pointData] of allPoints) {
                    if (pointData.robot && pointData.robot.team === team) {
                        console.log(`  🤖 Checking ${pointData.robot.id} at ${pointId}...`);
                        
                        // Check if this robot can initiate battle (not affected by action-blocking status)
                        const robotStatuses = this.getRobotStatuses(pointData.robot.id);
                        const actionBlockers = ['sleep', 'frozen', 'waiting'];
                        const hasBlockingStatus = actionBlockers.some(s => 
                            robotStatuses.conditions.includes(s) || robotStatuses.markers.includes(s)
                        );
                        
                        if (hasBlockingStatus) {
                            console.log(`    ⏸️ Robot is affected by action-blocking status - cannot attack`);
                            continue; // Skip this robot, don't highlight enemies
                        }
                        
                        // Check for adjacent enemies
                        const adjacentEnemies = this.getAdjacentEnemies(pointId, team);
                        if (adjacentEnemies.length > 0) {
                            console.log(`    ⚡ Found ${adjacentEnemies.length} adjacent enemies!`);
                            
                            // Highlight each adjacent enemy
                            adjacentEnemies.forEach(enemyPointId => {
                                const enemyRobotGroup = document.getElementById(`robot-${enemyPointId}`);
                                if (enemyRobotGroup) {
                                    // Skip if already highlighted (avoid duplicates)
                                    if (!enemyRobotGroup.classList.contains('attackable-enemy')) {
                                        enemyRobotGroup.classList.add('attackable-enemy');
                                        
                                        // Apply RED GLOW effect
                                        const circle = enemyRobotGroup.querySelector('circle');
                                        if (circle) {
                                            circle.setAttribute('r', '60');
                                            circle.style.filter = 'drop-shadow(0 0 20px rgba(255, 0, 0, 0.9))';
                                            circle.setAttribute('stroke', '#ff0000');
                                            circle.setAttribute('stroke-width', '8');
                                            console.log(`      🔴 Highlighted enemy at ${enemyPointId}`);
                                            totalEnemiesHighlighted++;
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
                
                if (totalEnemiesHighlighted > 0) {
                    console.log(`✅ TURN START: Highlighted ${totalEnemiesHighlighted} attackable ${totalEnemiesHighlighted === 1 ? 'enemy' : 'enemies'}`);
                    this.addToHistory(`⚔️ ${totalEnemiesHighlighted} attackable ${totalEnemiesHighlighted === 1 ? 'enemy' : 'enemies'} on the board!`, 'info', team);
                } else {
                    console.log(`✅ TURN START: No adjacent enemies found`);
                }
            },
            
            // Highlight adjacent enemies and return count
            highlightAdjacentEnemies(pointId, team) {
                // Check if the robot at this point can initiate battle
                const point = this.getPointById(pointId);
                if (point && point.robot) {
                    const robotStatuses = this.getRobotStatuses(point.robot.id);
                    const actionBlockers = ['sleep', 'frozen', 'waiting'];
                    const hasBlockingStatus = actionBlockers.some(s => 
                        robotStatuses.conditions.includes(s) || robotStatuses.markers.includes(s)
                    );
                    
                    if (hasBlockingStatus) {
                        console.log(`⏸️ Robot at ${pointId} is affected by action-blocking status - cannot attack`);
                        return 0; // Don't highlight any enemies
                    }
                }
                
                const adjacentEnemies = this.getAdjacentEnemies(pointId, team);
                
                if (adjacentEnemies.length > 0) {
                    console.log(`⚡ ${adjacentEnemies.length} adjacent ${adjacentEnemies.length === 1 ? 'enemy' : 'enemies'} found - highlighting for battle`);
                    
                    // Highlight enemy robots with RED GLOW
                    adjacentEnemies.forEach(enemyPointId => {
                        const enemyRobotGroup = document.getElementById(`robot-${enemyPointId}`);
                        if (enemyRobotGroup) {
                            enemyRobotGroup.classList.add('attackable-enemy');
                            
                            // Apply RED GLOW effect
                            const circle = enemyRobotGroup.querySelector('circle');
                            if (circle) {
                                // Pulsing red glow for attackable enemies
                                circle.setAttribute('r', '60'); // Bigger (DOUBLED from normal 30)
                                circle.style.filter = 'drop-shadow(0 0 20px rgba(255, 0, 0, 0.9))'; // RED glow
                                circle.setAttribute('stroke', '#ff0000'); // Red border
                                circle.setAttribute('stroke-width', '8'); // Thicker border
                                console.log(`🔴 Applied RED GLOW to enemy at ${enemyPointId}`);
                            }
                        }
                    });
                    
                    console.log(`⚔️ Click on a glowing red enemy to initiate battle!`);
                    this.addToHistory(`⚔️ ${adjacentEnemies.length} adjacent ${adjacentEnemies.length === 1 ? 'enemy' : 'enemies'} available for battle!`, 'info', team);
                } else {
                    console.log(`✅ No adjacent enemies`);
                }
                
                return adjacentEnemies.length; // Return count for auto-end turn logic
            },
            
            // Find ally robot adjacent to this enemy (for battle initiation)
            findAdjacentAlly(enemyPointId, enemyTeam) {
                console.log(`🔍 Finding ally adjacent to enemy at ${enemyPointId} (enemy team: ${enemyTeam})`);
                const point = this.getPointById(enemyPointId);
                if (!point || !point.connections) {
                    console.log(`❌ Point not found or no connections`);
                    return null;
                }
                
                const allyTeam = enemyTeam === 'player' ? 'opponent' : 'player';
                console.log(`🔍 Looking for ally team: ${allyTeam}`);
                
                // Find first adjacent ally
                for (const connectedPointId of point.connections) {
                    const connectedPoint = this.getPointById(connectedPointId);
                    console.log(`  Checking ${connectedPointId}: robot=${!!connectedPoint?.robot}, team=${connectedPoint?.robot?.team}`);
                    
                    // CRITICAL DEBUG: Check gameBoard directly
                    let directCheck = null;
                    if (this.gameBoard.entryPoints[connectedPointId]) {
                        directCheck = this.gameBoard.entryPoints[connectedPointId].robot;
                    } else if (this.gameBoard.routePoints[connectedPointId]) {
                        directCheck = this.gameBoard.routePoints[connectedPointId].robot;
                    } else if (this.gameBoard.innerPoints[connectedPointId]) {
                        directCheck = this.gameBoard.innerPoints[connectedPointId].robot;
                    } else if (this.gameBoard.goalPoints[connectedPointId]) {
                        directCheck = this.gameBoard.goalPoints[connectedPointId].robot;
                    }
                    console.log(`  Direct gameBoard check for ${connectedPointId}: robot=${!!directCheck}, team=${directCheck?.team}`);
                    
                    if (connectedPoint && connectedPoint.robot && connectedPoint.robot.team === allyTeam) {
                        console.log(`✅ Found ally at ${connectedPointId}`);
                        return connectedPointId;
                    }
                }
                
                console.log(`❌ No ally found adjacent to ${enemyPointId}`);
                return null;
            },
            
            showBattleOptions(attackerPointId, enemyPoints) {
                console.log(`⚤️ Battle options available from ${attackerPointId}:`, enemyPoints);
                // Highlight adjacent enemies for click-to-battle
                const pointData = this.getPointById(attackerPointId);
                if (pointData && pointData.robot) {
                    this.highlightAdjacentEnemies(attackerPointId, pointData.robot.team);
                }
                // DON'T auto-end turn - let player decide when to end
            },
            
            // Turn Management
            setupEndTurnButton() {
                const endTurnBtn = document.getElementById('end-turn-btn');
                if (endTurnBtn) {
                    endTurnBtn.onclick = () => this.endPlayerTurn();
                    console.log('✅ End Turn button initialized');
                }
            },
            
            showEndTurnButton() {
                const endTurnBtn = document.getElementById('end-turn-btn');
                if (endTurnBtn) {
                    endTurnBtn.style.display = 'block';
                    console.log('👁️ End Turn button shown');
                }
            },
            
            hideEndTurnButton() {
                const endTurnBtn = document.getElementById('end-turn-btn');
                if (endTurnBtn) {
                    endTurnBtn.style.display = 'none';
                }
            },
            
            // Check if any robot on the current team has adjacent enemies
            hasAnyBattleOpportunities(team) {
                // Check all points for robots of this team
                const allPoints = [
                    ...Object.entries(this.gameBoard.entryPoints),
                    ...Object.entries(this.gameBoard.routePoints),
                    ...Object.entries(this.gameBoard.innerPoints),
                    ...Object.entries(this.gameBoard.goalPoints)
                ];
                
                for (const [pointId, pointData] of allPoints) {
                    if (pointData.robot && pointData.robot.team === team) {
                        // This robot belongs to the current team, check for adjacent enemies
                        const adjacentEnemies = this.getAdjacentEnemies(pointId, team);
                        if (adjacentEnemies.length > 0) {
                            console.log(`⚔️ Battle opportunity found: ${pointData.robot.id} at ${pointId} has ${adjacentEnemies.length} adjacent enemies`);
                            return true; // Found at least one battle opportunity
                        }
                    }
                }
                
                console.log(`✅ No battle opportunities available for ${team}`);
                return false; // No battle opportunities
            },
            
            endPlayerTurn() {
                const currentTeam = this.debugMode ? this.currentControlTeam : 'player';
                console.log(`🔄 Attempting to end ${currentTeam} turn...`);
                
                // CONFIRMATION SYSTEM: TWO-TIER CHECK
                // Check A: Has any action been taken (move OR battle)?
                if (!this.turnActions.hasMovedRobot && !this.turnActions.hasBattled) {
                    console.log('⚠️ CHECK A: No action taken this turn - showing confirmation');
                    const confirmed = confirm('You have not moved or battled this turn. Are you sure you want to end your turn?');
                    if (!confirmed) {
                        console.log('❌ Turn end cancelled by user (Check A)');
                        return; // User chose not to end turn
                    }
                }
                
                // Check B: If a robot was moved, does it have adjacent enemies to battle?
                if (this.turnActions.hasMovedRobot && this.turnActions.lastMovedRobotPoint && !this.turnActions.hasBattled) {
                    console.log('⚠️ CHECK B: Move made, checking for battle opportunities...');
                    const adjacentEnemies = this.getAdjacentEnemies(this.turnActions.lastMovedRobotPoint, currentTeam);
                    
                    if (adjacentEnemies.length > 0) {
                        console.log(`⚠️ CHECK B: ${adjacentEnemies.length} adjacent ${adjacentEnemies.length === 1 ? 'enemy' : 'enemies'} available to attack!`);
                        const confirmed = confirm(`You can still attack ${adjacentEnemies.length} adjacent ${adjacentEnemies.length === 1 ? 'enemy' : 'enemies'}! Are you sure you want to end your turn?`);
                        if (!confirmed) {
                            console.log('❌ Turn end cancelled by user (Check B - battle available)');
                            return; // User chose not to end turn
                        }
                        console.log('✅ User confirmed - ending turn despite battle opportunity');
                    } else {
                        console.log('✅ CHECK B: No adjacent enemies - proceeding to end turn');
                    }
                }
                
                console.log(`✅ ${currentTeam} turn ending...`);
                
                // Add to battle history
                this.addToHistory(`Turn ended`, 'info', currentTeam);
                
                // CRITICAL: Expire Wait status at END of owner's turn
                // Wait blocks the robot for the owner's NEXT FULL turn
                // It expires AFTER that turn completes
                this.expireWaitStatusForTeam(currentTeam);
                
                this.hideEndTurnButton();
                this.clearSelection();
                this.clearAttackableEnemies();
                
                // Reset turn action counters
                this.turnActions.hasMovedRobot = false;
                this.turnActions.hasBattled = false;
                this.turnActions.actionTakenThisTurn = false;
                this.turnActions.lastMovedRobotPoint = null; // Clear lock-in
                console.log('✅ Turn actions reset for next turn:', this.turnActions);
                
                // Update bench display to refresh first-turn handicap visuals
                this.updateBenchDisplay();
                console.log('✅ Bench display refreshed (first-turn handicap visuals updated)');
                
                // In debug mode, just switch control team
                if (this.debugMode) {
                    const nextTeam = currentTeam === 'player' ? 'opponent' : 'player';
                    console.log(`🔄 DEBUG MODE: Switching control from ${currentTeam} to ${nextTeam}`);
                    this.switchControlTeam();
                    
                    // Set appropriate game state for the next team
                    if (nextTeam === 'player') {
                        this.setState(this.gameStates.PLAYER_TURN);
                    } else {
                        // Set to AI_TURN but it will be intercepted by onAITurnStart in debug mode
                        this.setState(this.gameStates.AI_TURN);
                    }
                    
                    // Update status display to show reset counters
                    this.showDebugControls();
                    
                    // Show visual notification of turn switch
                    this.showTurnActionMessage(`Turn switched to ${this.currentControlTeam.toUpperCase()}!`);
                } else {
                    console.log(`🔄 NORMAL MODE: Switching to AI turn`);
                    this.setState(this.gameStates.AI_TURN);
                }
            },
            
            executeAITurn() {
                console.log('🤖 AI executing turn...');
                // TODO: Implement AI logic
                // For now, just pass turn back to player after a delay
                setTimeout(() => {
                    console.log('🤖 AI turn complete, passing to player');
                    this.setState(this.gameStates.PLAYER_TURN);
                }, 1000);
            },
            
            // Win Condition Checking
            checkWinConditions(team) {
                // Check goal capture
                const goalId = team === 'player' ? 'goal-opponent' : 'goal-player';
                const goalElement = document.getElementById(goalId);
                
                console.log(`🏁 Checking win conditions for ${team}:`);
                console.log(`   Goal ID: ${goalId}`);
                console.log(`   Goal element found: ${!!goalElement}`);
                if (goalElement) {
                    console.log(`   data-occupied: ${goalElement.getAttribute('data-occupied')}`);
                    console.log(`   data-team: ${goalElement.getAttribute('data-team')}`);
                }
                
                if (goalElement && goalElement.getAttribute('data-occupied') === 'true' && 
                    goalElement.getAttribute('data-team') === team) {
                    
                    // CRITICAL: Check if the robot on the goal has Wait status
                    // A robot with Wait cannot win until Wait expires
                    const goalPoint = this.gameBoard.goalPoints[goalId];
                    if (goalPoint && goalPoint.robot) {
                        const robotStatuses = this.getRobotStatuses(goalPoint.robot.id);
                        const hasWait = robotStatuses.conditions.includes('waiting') || robotStatuses.markers.includes('waiting');
                        
                        if (hasWait) {
                            console.log(`⏸️ Robot on goal has Wait status - win condition BLOCKED!`);
                            console.log(`   ${team} must survive until Wait expires to secure the win`);
                            this.addToHistory(`⚠️ Robot on goal has Wait - win delayed!`, 'info', team);
                            return false; // No win yet - Wait blocks the win
                        }
                    }
                    
                    console.log(`🎉 WIN CONDITION MET! ${team} captured the goal!`);
                    this.winType = 'goal';
                    this.setState(team === 'player' ? this.gameStates.PLAYER_WINS : this.gameStates.AI_WINS);
                    return true;
                }
                
                // Check turn limit
                if (this.turnCount >= 300) {
                    this.winType = 'timeout';
                    this.setState(this.gameStates.DRAW);
                    return true;
                }
                
                console.log(`   No win condition met yet.`);
                return false;
            },
            
            // Check if a team has any legal moves (for System Lock Victory detection)
            // SYSTEM LOCK occurs when BOTH conditions are true:
            // Condition A: Player has ZERO robots on the field
            // Condition B: Both entry points are blocked by enemy robots
            hasLegalMoves(team) {
                console.log(`🔍 Checking if ${team} has legal moves...`);
                
                const entryPoints = team === 'player' ? 
                    ['entry-bottom-left', 'entry-bottom-right'] : ['entry-top-left', 'entry-top-right'];
                
                // CONDITION A: Count robots on field for this team
                // Use Object.entries to get both ID and point data
                const allPointEntries = [
                    ...Object.entries(this.gameBoard.entryPoints),
                    ...Object.entries(this.gameBoard.routePoints),
                    ...Object.entries(this.gameBoard.innerPoints),
                    ...Object.entries(this.gameBoard.goalPoints)
                ];
                
                let robotsOnField = 0;
                let canAnyRobotMove = false;
                
                for (const [pointId, point] of allPointEntries) {
                    if (!point.robot || point.robot.team !== team) continue;
                    
                    robotsOnField++;
                    
                    const robot = RobotDatabase.getRobot(point.robot.id);
                    if (!robot) continue;
                    
                    // Check if this robot can move anywhere
                    const validMoves = this.calculateValidMovesWithinMP(pointId, robot.mp);
                    if (validMoves.length > 0) {
                        canAnyRobotMove = true;
                        console.log(`   ✅ ${team} can move ${robot.name} from ${pointId}`);
                    }
                }
                
                console.log(`   📊 ${team} has ${robotsOnField} robots on field`);
                
                // If team has robots on field that can move, they have legal moves
                if (robotsOnField > 0 && canAnyRobotMove) {
                    console.log(`   ✅ ${team} HAS legal moves (robots can move)`);
                    return true;
                }
                
                // If team has robots on field but none can move, they still have legal moves
                // (they're just blocked, not in System Lock)
                if (robotsOnField > 0 && !canAnyRobotMove) {
                    console.log(`   ⚠️ ${team} has robots but they're all blocked - NOT System Lock`);
                    return true; // Still has legal moves (robots exist, just can't move this turn)
                }
                
                // CONDITION B: Check if both entry points are blocked
                let blockedEntryPoints = 0;
                const enemyTeam = team === 'player' ? 'opponent' : 'player';
                
                for (const entryId of entryPoints) {
                    const entryPoint = this.getPointById(entryId);
                    if (entryPoint && entryPoint.robot && entryPoint.robot.team === enemyTeam) {
                        blockedEntryPoints++;
                        console.log(`   🚫 Entry point ${entryId} blocked by ${enemyTeam}`);
                    }
                }
                
                // SYSTEM LOCK: No robots on field AND both entry points blocked
                if (robotsOnField === 0 && blockedEntryPoints === 2) {
                    console.log(`   ❌ SYSTEM LOCK! ${team} has NO robots on field AND both entry points blocked!`);
                    return false; // No legal moves - System Lock!
                }
                
                // If no robots on field but at least one entry point is free, check if can deploy
                if (robotsOnField === 0 && blockedEntryPoints < 2) {
                    // Check if team has any robots in bench to deploy
                    const bench = team === 'player' ? this.playerBench : this.opponentBench;
                    const hasRobotsInBench = bench.some(robotId => robotId !== null);
                    
                    if (hasRobotsInBench) {
                        console.log(`   ✅ ${team} can deploy from bench (entry points available)`);
                        return true;
                    } else {
                        console.log(`   ❌ SYSTEM LOCK! ${team} has NO robots on field AND bench is EMPTY!`);
                        return false; // No legal moves - no robots to deploy!
                    }
                }
                
                console.log(`   ✅ ${team} HAS legal moves`);
                return true;
            },
            
            // Check for WaitWin (System Lock Victory)
            checkWaitWin(team) {
                console.log(`🔒 Checking WaitWin for ${team}...`);
                
                // Determine opponent
                const opponent = team === 'player' ? 'opponent' : 'player';
                
                // Check if opponent has no legal moves
                if (!this.hasLegalMoves(opponent)) {
                    console.log(`🎉 WAITWIN! ${opponent} has no legal moves - ${team} wins by System Lock!`);
                    this.addToHistory(`🔒 ${opponent.toUpperCase()} has no legal moves!`, 'win', null);
                    this.addToHistory(`🏆 ${team.toUpperCase()} WINS by System Lock Victory!`, 'win', team);
                    this.winType = 'waitwin';
                    this.setState(team === 'player' ? this.gameStates.PLAYER_WINS : this.gameStates.AI_WINS);
                    return true;
                }
                
                return false;
            },
            
            showEndGameUI(endState) {
                let message = '';
                let title = '';
                switch(endState) {
                    case this.gameStates.PLAYER_WINS:
                        title = '🎉 VICTORY!';
                        if (this.winType === 'waitwin') {
                            message = 'System Lock Victory! Opponent has no legal moves!';
                        } else {
                            message = 'You captured the opponent\'s goal!';
                        }
                        break;
                    case this.gameStates.AI_WINS:
                        title = '💀 DEFEAT';
                        if (this.winType === 'waitwin') {
                            message = 'System Lock Defeat! You have no legal moves!';
                        } else {
                            message = 'The opponent captured your goal!';
                        }
                        break;
                    case this.gameStates.DRAW:
                        title = '🤝 DRAW';
                        message = 'Turn limit reached (300 turns).';
                        break;
                }
                
                console.log(`🏁 GAME OVER: ${title} - ${message}`);
                
                // Show modal with game result
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    animation: fadeIn 0.3s ease-in-out;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                        max-width: 500px;
                        animation: slideUp 0.4s ease-out;
                    ">
                        <h1 style="
                            font-size: 48px;
                            margin: 0 0 20px 0;
                            color: white;
                            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
                        ">${title}</h1>
                        <p style="
                            font-size: 24px;
                            margin: 0 0 30px 0;
                            color: rgba(255,255,255,0.9);
                        ">${message}</p>
                        <button onclick="BattleSystem.returnToTeamSelection()" style="
                            background: white;
                            color: #667eea;
                            border: none;
                            padding: 15px 40px;
                            font-size: 18px;
                            font-weight: bold;
                            border-radius: 10px;
                            cursor: pointer;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                            transition: all 0.2s;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            Return to Team Selection
                        </button>
                    </div>
                `;
                
                document.body.appendChild(modal);
            },
            
            // REMOVED: Test robot auto-placement
            // Users now manually deploy their selected robots from bench
            // This ensures only user-selected robots appear on the field
            
            // REMOVED: Debug random robot placement
            // All robots must be manually deployed by user from bench
            
            debugClearAllRobots() {
                const allPoints = Object.keys(this.getAllPoints());
                allPoints.forEach(pointId => {
                    this.clearPoint(pointId);
                });
                console.log('🧹 All robots cleared from board');
            },
            
            returnToTeamSelection() {
                console.log('🔄 Returning to team selection...');
                
                // Remove end game modal
                const modal = document.querySelector('div[style*="z-index: 10000"]');
                if (modal) {
                    modal.remove();
                }
                
                // Clear the battle board
                this.debugClearAllRobots();
                
                // Reset game state
                this.setState(this.gameStates.SETUP);
                this.turnCount = 0;
                this.turnActions = {
                    hasMovedRobot: false,
                    hasBattled: false,
                    actionTakenThisTurn: false,
                    lastMovedRobotPoint: null // Track which robot just moved (for "lock-in")
                };
                
                // Hide battle game phase and show team selection phase
                const battleGamePhase = document.getElementById('battleGamePhase');
                const teamSelectionPhase = document.getElementById('teamSelectionPhase');
                
                if (battleGamePhase) {
                    battleGamePhase.style.display = 'none';
                    console.log('✅ Battle game phase hidden');
                }
                if (teamSelectionPhase) {
                    teamSelectionPhase.style.display = 'block';
                    console.log('✅ Team selection phase shown');
                }
                
                // Update header
                const battleTitle = document.getElementById('battleTitle');
                const battleSubtitle = document.getElementById('battleSubtitle');
                if (battleTitle) battleTitle.textContent = '🤖 Team Selection';
                if (battleSubtitle) battleSubtitle.textContent = 'Choose 6 robots for battle';
                
                console.log('✅ Returned to team selection');
            },
            
            // Visual Robot Management
            addRobotVisual(pointId, robotId, team) {
                const point = document.getElementById(pointId);
                if (!point) {
                    console.error(`❌ Point element not found: ${pointId}`);
                    return;
                }
                
                // Remove any existing robot visual
                this.removeRobotVisual(pointId);
                
                // Get point coordinates for positioning
                const pointData = this.getPointById(pointId);
                if (!pointData) {
                    console.error(`❌ Point data not found: ${pointId}`);
                    return;
                }
                
                // Get robot data for proper image
                const robot = RobotDatabase.getRobot(robotId);
                const robotImage = robot ? robot.image : 'Imag/mascot.png';
                const robotName = robot ? robot.name : robotId;
                
                console.log(`🎨 Creating robot visual at (${pointData.x}, ${pointData.y})`);
                
                // Create SVG group for the robot
                const svgNS = "http://www.w3.org/2000/svg";
                const robotGroup = document.createElementNS(svgNS, 'g');
                robotGroup.id = `robot-${pointId}`;
                robotGroup.setAttribute('class', `battle-robot ${team}-robot`);
                robotGroup.style.cursor = 'pointer';
                // Store pointId as data attribute for reliable click detection
                robotGroup.setAttribute('data-point-id', pointId);
                robotGroup.setAttribute('data-team', team);
                robotGroup.setAttribute('data-robot-id', robotId); // For Combat Dial handler
                
                // Create circle background - TWICE AS BIG!
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', pointData.x);
                circle.setAttribute('cy', pointData.y);
                circle.setAttribute('r', '50'); // DOUBLED! (was 25)
                circle.setAttribute('fill', team === 'player' ? '#28a745' : '#dc3545');
                circle.setAttribute('stroke', '#fff');
                circle.setAttribute('stroke-width', '6'); // Thicker border
                circle.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.5))';
                // Make circle non-interactive for pointer events (let group handle it)
                circle.style.pointerEvents = 'none';
                
                // Create image element (SVG image) - TWICE AS BIG!
                const image = document.createElementNS(svgNS, 'image');
                image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', robotImage);
                image.setAttribute('x', pointData.x - 44); // DOUBLED offset
                image.setAttribute('y', pointData.y - 44);
                image.setAttribute('width', '88'); // DOUBLED! (was 44)
                image.setAttribute('height', '88');
                image.setAttribute('clip-path', 'circle(44px at 44px 44px)');
                // Make image non-interactive for pointer events (let group handle it)
                image.style.pointerEvents = 'none';
                
                // Create invisible clickable circle (covers entire robot image with generous margin)
                const clickCircle = document.createElementNS(svgNS, 'circle');
                clickCircle.setAttribute('cx', pointData.x);
                clickCircle.setAttribute('cy', pointData.y);
                clickCircle.setAttribute('r', '70'); // INCREASED: 88x88px robot (44px) + 26px margin for easy clicking
                clickCircle.setAttribute('fill', 'transparent');
                clickCircle.setAttribute('stroke', 'none');
                clickCircle.setAttribute('data-robot-id', robotId); // For Combat Dial handler
                clickCircle.style.cursor = 'pointer';
                // This circle handles all pointer events and must be on top
                clickCircle.style.pointerEvents = 'all';
                clickCircle.style.zIndex = '1000'; // Ensure it's on top
                
                // Add elements to group (clickCircle LAST so it's on top)
                robotGroup.appendChild(circle);
                robotGroup.appendChild(image);
                robotGroup.appendChild(clickCircle);
                
                // Add status effect indicators
                this.addStatusEffectIndicators(robotGroup, robotId, pointData.x, pointData.y);
                
                // NOTE: Click handling is now done via global SVG click handler (setupSVGClickHandler)
                // This prevents overlapping robot click issues
                
                // NOTE: Hover effects are now handled by CSS (.battle-robot:hover)
                // This ensures consistent hover feedback across all robot positions
                // JavaScript hover handlers were causing issues with event propagation
                
                // Add to the SVG
                const svg = document.querySelector('.battle-board-svg');
                if (svg) {
                    svg.appendChild(robotGroup);
                    console.log(`✅ Robot visual added to SVG at (${pointData.x}, ${pointData.y})`);
                    
                    // Add Combat Dial tap-and-hold handler ONLY to group (not circle - avoid bubbling)
                    this.addCombatDialHandlerToElement(robotGroup, robotId);
                } else {
                    console.error('❌ SVG element not found!');
                }
                
                console.log(`🤖 Added visual robot ${robotName} (${team}) at ${pointId} (${pointData.x}, ${pointData.y})`);
            },
            
            removeRobotVisual(pointId) {
                const existingRobot = document.getElementById(`robot-${pointId}`);
                if (existingRobot) {
                    existingRobot.remove();
                    console.log(`🗑️ Removed visual robot from ${pointId}`);
                }
            },
            
            // Clean up any ghost robots (visuals without data)
            cleanupGhostRobots() {
                console.log('🧹 Checking for ghost robots (visuals without data)...');
                let ghostCount = 0;
                
                // Get all robot visuals on the board
                const allRobotVisuals = document.querySelectorAll('[id^="robot-"]');
                
                allRobotVisuals.forEach(visual => {
                    const visualId = visual.id;
                    const pointId = visualId.replace('robot-', '');
                    
                    // Check if this point has robot data
                    const pointData = this.getPointById(pointId);
                    if (!pointData || !pointData.robot) {
                        console.warn(`⚠️ GHOST ROBOT found at ${pointId}! Removing...`);
                        visual.remove();
                        ghostCount++;
                    }
                });
                
                if (ghostCount > 0) {
                    console.log(`✅ Removed ${ghostCount} ghost robot(s)`);
                } else {
                    console.log(`✅ No ghost robots found - board is clean`);
                }
            },
            
            // ==========================================
            // PHASE 3: SMOOTH PATH-FOLLOWING ANIMATION
            // ==========================================
            
            // Animate robot along the calculated path (returns promise)
            async moveRobotVisual(fromPointId, toPointId) {
                const robotGroup = document.getElementById(`robot-${fromPointId}`);
                if (!robotGroup) {
                    console.warn(`⚠️ Robot visual not found at ${fromPointId}`);
                    return;
                }
                
                // Get the stored path from BFS calculation
                const path = this.validMovePaths.get(toPointId);
                
                if (!path || path.length === 0) {
                    console.warn(`⚠️ No path found for ${toPointId}, using direct move`);
                    // Fallback to direct move
                    await this.animateAlongPath(robotGroup, [fromPointId, toPointId], fromPointId, toPointId);
                    return;
                }
                
                console.log(`🛤️ Following path (${path.length} steps):`, path);
                
                // Animate along the path
                await this.animateAlongPath(robotGroup, path, fromPointId, toPointId);
            },
            
            // Smooth animation that follows the route path
            animateAlongPath(robotGroup, path, fromPointId, toPointId) {
                return new Promise((resolve) => {
                    const circle = robotGroup.querySelector('circle');
                    const image = robotGroup.querySelector('image');
                    
                    if (!circle || !image) {
                        console.error('❌ Robot visual elements not found');
                        resolve();
                        return;
                    }
                    
                    // Calculate total animation time based on path length
                    const stepDuration = 300; // ms per step
                    const totalDuration = (path.length - 1) * stepDuration;
                    
                    // Build keyframe animation
                    let currentStep = 0;
                    const animateStep = () => {
                        if (currentStep >= path.length - 1) {
                            // Animation complete - update ALL attributes to maintain interactivity
                            robotGroup.id = `robot-${toPointId}`;
                            robotGroup.setAttribute('data-point-id', toPointId);
                            robotGroup.style.cursor = 'pointer';
                            
                            // Get robotId from element for Combat Dial handler re-attachment
                            const robotId = robotGroup.getAttribute('data-robot-id');
                            
                            // Ensure the clickCircle maintains its properties
                            const clickCircle = robotGroup.querySelector('circle:last-of-type');
                            if (clickCircle) {
                                clickCircle.style.cursor = 'pointer';
                                clickCircle.style.pointerEvents = 'all';
                            }
                            
                            // Re-attach Combat Dial handler ONLY to robotGroup (not circle - avoid bubbling)
                            if (robotId) {
                                // Handler will be attached to new element instance (no need to remove old marker)
                                this.addCombatDialHandlerToElement(robotGroup, robotId);
                            }
                            
                            // Verify class is preserved for CSS hover
                            console.log(`✅ Animation complete: ${fromPointId} → ${toPointId}`);
                            console.log(`🔍 Robot classes after move: ${robotGroup.getAttribute('class')}`);
                            resolve();
                            return;
                        }
                        
                        currentStep++;
                        const nextPointId = path[currentStep];
                        const nextPointData = this.getPointById(nextPointId);
                        
                        if (nextPointData) {
                            // Smooth transition to next point
                            circle.style.transition = `all ${stepDuration}ms ease-in-out`;
                            image.style.transition = `all ${stepDuration}ms ease-in-out`;
                            
                            circle.setAttribute('cx', nextPointData.x);
                            circle.setAttribute('cy', nextPointData.y);
                            image.setAttribute('x', nextPointData.x - 44);
                            image.setAttribute('y', nextPointData.y - 44);
                            
                            // Continue to next step
                            setTimeout(animateStep, stepDuration);
                        } else {
                            resolve();
                        }
                    };
                    
                    // Start animation
                    animateStep();
                });
            },
            
            // Phase 2 Initialization
            initializePhase2() {
                console.log('🎮 Phase 2: Turn Management & Movement - INITIALIZED!');
                this.setupEndTurnButton();
                this.setupMovableSpaceImageHandlers();
                this.setState(this.gameStates.SETUP);
                
                // Show end turn button immediately in debug mode
                if (this.debugMode) {
                    this.showEndTurnButton();
                }
            },
            
            // Setup click handlers for movable space images (event delegation)
            setupMovableSpaceImageHandlers() {
                document.querySelectorAll('.movable-space-image').forEach(img => {
                    img.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        const pointId = img.getAttribute('data-point');
                        if (pointId && img.classList.contains('active')) {
                            console.log(`🖱️ Movable image clicked for ${pointId}`);
                            const pointEl = document.getElementById(pointId);
                            if (pointEl) {
                                // Directly call the handler instead of using .click()
                                this.handlePointClick(pointEl);
                            } else {
                                console.error(`❌ Point element not found: ${pointId}`);
                            }
                        } else {
                            console.log(`⚠️ Image clicked but not active or no point ID`);
                        }
                    });
                });
                console.log('✅ Movable space image click handlers initialized');
            },

            // DEBUG MODE: Enable manual control of both sides
            debugMode: false,
            currentControlTeam: 'player',
            
            // FREE MOVEMENT MODE: Allow instant teleportation for scenario setup
            freeMovementMode: false,
            
            enableDebugMode() {
                this.debugMode = true;
                this.currentControlTeam = 'player'; // Always start with player control
                console.log('🐛 DEBUG MODE ENABLED - You control both sides! Starting with PLAYER control.');
                this.showDebugControls();
            },
            
            showDebugControls() {
                // Create or get debug button
                let debugBtn = document.getElementById('debug-switch-btn');
                if (!debugBtn) {
                    debugBtn = document.createElement('button');
                    debugBtn.id = 'debug-switch-btn';
                    debugBtn.style.position = 'fixed';
                    debugBtn.style.top = '10px';
                    debugBtn.style.right = '10px';
                    debugBtn.style.padding = '6px 12px';
                    debugBtn.style.fontSize = '12px';
                    debugBtn.style.borderRadius = '6px';
                    debugBtn.style.border = '2px solid #666';
                    debugBtn.style.background = 'rgba(30, 30, 30, 0.9)';
                    debugBtn.style.color = '#fff';
                    debugBtn.style.cursor = 'pointer';
                    debugBtn.style.zIndex = '9999';
                    debugBtn.style.fontWeight = '600';
                    debugBtn.style.transition = 'all 0.2s ease';
                    debugBtn.onclick = () => this.switchControlTeam();
                    document.body.appendChild(debugBtn);
                }
                
                // Update button text
                const team = this.currentControlTeam === 'player' ? '👤 Player' : '🤖 Opponent';
                debugBtn.innerHTML = `🐛 ${team}`;
                debugBtn.style.borderColor = this.currentControlTeam === 'player' ? '#28a745' : '#dc3545';
                
                // Add hover effect
                debugBtn.onmouseenter = () => {
                    debugBtn.style.background = 'rgba(50, 50, 50, 0.95)';
                    debugBtn.style.transform = 'scale(1.05)';
                };
                debugBtn.onmouseleave = () => {
                    debugBtn.style.background = 'rgba(30, 30, 30, 0.9)';
                    debugBtn.style.transform = 'scale(1)';
                };
                
                // Create or update turn status indicator
                let statusDiv = document.getElementById('turn-status-indicator');
                // Turn Status moved to Battle Log - hide the panel
                if (!statusDiv) {
                    statusDiv = document.createElement('div');
                    statusDiv.id = 'turn-status-indicator';
                    statusDiv.style.display = 'none'; // Hidden - info in battle log instead
                    document.body.appendChild(statusDiv);
                }
                
                // Add turn status to battle log instead
                const moved = this.turnActions.hasMovedRobot ? '✅' : '❌';
                const battled = this.turnActions.hasBattled ? '✅' : '❌';
                
                // Only update log if status changed (avoid spam)
                const statusKey = `${moved}${battled}`;
                if (this.lastTurnStatusLog !== statusKey) {
                    this.addToHistory(`Turn Status - Moved: ${moved}, Battled: ${battled}`, 'system');
                    this.lastTurnStatusLog = statusKey;
                }
                
                // Create or update battle history log
                this.showBattleHistory();
            },
            
            switchControlTeam() {
                this.currentControlTeam = this.currentControlTeam === 'player' ? 'opponent' : 'player';
                console.log(`🔄 Switched control to: ${this.currentControlTeam}`);
                this.showDebugControls();
                
                // Clear any selections when switching
                this.clearSelection();
            },
            
            // Battle History Log
            // team: 'player', 'opponent', or null for neutral events
            addToHistory(message, type = 'info', team = null) {
                const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
                
                // Team-based colors: player = green, opponent = red
                let color;
                if (team === 'player') {
                    color = '#00ff88'; // Green for player
                } else if (team === 'opponent') {
                    color = '#ff4444'; // Red for opponent
                } else {
                    // Type-based colors for neutral events
                    const colors = {
                        info: '#aaa',
                        battle: '#ff6b6b',
                        win: '#ffd700',
                        system: '#4dabf7'
                    };
                    color = colors[type] || colors.info;
                }
                
                this.battleHistory.push({
                    time: timestamp,
                    message: message,
                    type: type,
                    team: team,
                    color: color
                });
                
                // Keep only last 100 entries (increased for detailed logging)
                if (this.battleHistory.length > 100) {
                    this.battleHistory.shift();
                }
                
                // Update display if it exists
                this.showBattleHistory();
            },
            
            showBattleHistory() {
                let historyDiv = document.getElementById('battle-history-log');
                if (!historyDiv) {
                    historyDiv = document.createElement('div');
                    historyDiv.id = 'battle-history-log';
                    historyDiv.style.position = 'fixed';
                    historyDiv.style.top = '130px';
                    historyDiv.style.right = '10px';
                    historyDiv.style.width = '250px';
                    historyDiv.style.padding = '0';
                    historyDiv.style.fontSize = '10px';
                    historyDiv.style.borderRadius = '6px';
                    historyDiv.style.background = 'rgba(20, 20, 20, 0.95)';
                    historyDiv.style.color = '#fff';
                    historyDiv.style.zIndex = '9999';
                    historyDiv.style.fontFamily = 'monospace';
                    historyDiv.style.border = '1px solid #666';
                    historyDiv.style.display = 'flex';
                    historyDiv.style.flexDirection = 'column';
                    document.body.appendChild(historyDiv);
                }
                
                // Check if log is collapsed
                const isCollapsed = historyDiv.dataset.collapsed === 'true';
                
                // Build history HTML with collapsible header
                const logMode = this.developerLogMode ? 'Developer Log' : 'Battle Log';
                const logIcon = this.developerLogMode ? '🔧' : '📜';
                let html = `<div style="font-weight: bold; color: #ffd700; padding: 8px; background: rgba(20, 20, 20, 0.95); border-bottom: 1px solid #666; display: flex; justify-content: space-between; align-items: center;">
                    <span style="cursor: pointer; flex: 1;" onclick="BattleSystem.toggleBattleLog()">${logIcon} ${logMode}</span>
                    <button style="font-size: 10px; padding: 2px 6px; background: ${this.developerLogMode ? '#4CAF50' : '#666'}; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 8px;" onclick="event.stopPropagation(); BattleSystem.toggleDeveloperLogMode()">DEV</button>
                    <span style="font-size: 16px; user-select: none; cursor: pointer;" onclick="BattleSystem.toggleBattleLog()">${isCollapsed ? '+' : '−'}</span>
                </div>`;
                
                // Add content area (hidden if collapsed)
                if (!isCollapsed) {
                    html += '<div id="battle-log-content" style="padding: 8px; overflow-y: auto; overflow-x: hidden; max-height: 300px; display: flex; flex-direction: column-reverse;">';
                    
                    // Filter history based on mode
                    let filteredHistory = [...this.battleHistory];
                    if (this.developerLogMode) {
                        // Show only developer logs
                        filteredHistory = filteredHistory.filter(entry => entry.isDeveloperLog);
                    } else {
                        // Show only regular logs
                        filteredHistory = filteredHistory.filter(entry => !entry.isDeveloperLog);
                    }
                    
                    // Reverse to show newest at top
                    const reversedHistory = filteredHistory.reverse();
                    reversedHistory.forEach(entry => {
                        if (entry.isDeveloperLog) {
                            // Developer log format - monospace, multi-line support
                            html += `<div style="margin-bottom: 5px; padding: 5px; border-left: 3px solid ${entry.color}; padding-left: 8px; background: rgba(0,0,0,0.5); font-family: 'Courier New', monospace; font-size: 9px;">`;
                            html += `<span style="color: #888; font-size: 8px;">[${entry.time}]</span><br>`;
                            html += `<span style="color: ${entry.color}; white-space: pre-wrap; word-break: break-word;">${entry.message}</span>`;
                            html += `</div>`;
                        } else {
                            // Regular log format
                            let teamIcon = '';
                            if (entry.team === 'player') {
                                teamIcon = '👤 '; // Player icon
                            } else if (entry.team === 'opponent') {
                                teamIcon = '🤖 '; // Robot icon
                            }
                            
                            html += `<div style="margin-bottom: 3px; padding: 3px; border-left: 3px solid ${entry.color}; padding-left: 6px; background: rgba(0,0,0,0.3);">`;
                            html += `<span style="color: #666; font-size: 9px;">[${entry.time}]</span> `;
                            html += `<span style="color: ${entry.color}; font-weight: ${entry.team ? 'bold' : 'normal'};">${teamIcon}${entry.message}</span>`;
                            html += `</div>`;
                        }
                    });
                    
                    html += '</div>'; // Close content div
                }
                
                historyDiv.innerHTML = html;
            },
            
            // Toggle battle log collapse/expand
            toggleBattleLog() {
                const historyDiv = document.getElementById('battle-history-log');
                if (!historyDiv) return;
                
                // Toggle collapsed state
                const isCollapsed = historyDiv.dataset.collapsed === 'true';
                historyDiv.dataset.collapsed = !isCollapsed;
                
                // Refresh display
                this.showBattleHistory();
            },
            
            // Toggle Developer Log Mode
            toggleDeveloperLogMode() {
                this.developerLogMode = !this.developerLogMode;
                console.log(`🔧 Developer Log Mode: ${this.developerLogMode ? 'ENABLED' : 'DISABLED'}`);
                this.showBattleHistory(); // Refresh display
            },
            
            // Add verbose developer log entry
            addDeveloperLog(category, data) {
                if (!this.developerLogMode) return; // Only log if dev mode is on
                
                const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
                
                // Format data as JSON string for readability
                const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : String(data);
                
                // Category colors
                const categoryColors = {
                    'SPIN_RESULT': '#ff6b6b',
                    'BATTLE_OUTCOME': '#ffd700',
                    'DAMAGE_CALC': '#ff9f43',
                    'STATUS_EFFECT': '#a29bfe',
                    'MOVEMENT': '#00d2d3',
                    'DEPLOYMENT': '#00b894',
                    'KNOCKOUT': '#d63031',
                    'REPAIR': '#74b9ff',
                    'SYSTEM': '#636e72',
                    'ERROR': '#ff0000'
                };
                
                const color = categoryColors[category] || '#aaa';
                
                this.battleHistory.push({
                    time: timestamp,
                    message: `[${category}] ${dataStr}`,
                    type: 'developer',
                    team: null,
                    color: color,
                    isDeveloperLog: true
                });
                
                // Keep only last 100 entries
                if (this.battleHistory.length > 100) {
                    this.battleHistory.shift();
                }
                
                // Update display
                this.showBattleHistory();
            },

            // Initialize battle with selected teams
            initializeBattleWithTeams(playerTeam, opponentTeam) {
                console.log('🎮 Initializing battle with teams...');
                console.log('👤 Player Team:', playerTeam);
                console.log('🤖 Opponent Team:', opponentTeam);
                
                // Clear any existing robots
                this.clearAllRobots();
                
                // Deploy player team to bench initially
                this.deployTeamToBench(playerTeam, 'player');
                this.deployTeamToBench(opponentTeam, 'opponent');
                
                // Set up initial game state
                this.setState(this.gameStates.SETUP);
                
                // Enable interactive robot deployment
                this.enableRobotInteraction();
                
                // Set up global SVG click handler for better robot detection
                this.setupSVGClickHandler();
                
                // Initialize Combat Dial tap-and-hold handlers
                this.initializeCombatDialHandlers();
                
                console.log('✅ Battle initialized! Players can now deploy robots from bench.');
            },
            
            // Set up global SVG click handler to properly detect robot clicks
            setupSVGClickHandler() {
                const svg = document.querySelector('.battle-board-svg');
                if (!svg) return;
                
                // Remove any existing handler
                if (this.svgClickHandler) {
                    svg.removeEventListener('click', this.svgClickHandler);
                }
                
                // Create new handler
                this.svgClickHandler = (e) => {
                    // Get click coordinates relative to SVG
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    
                    console.log(`🖱️ SVG clicked at (${svgP.x.toFixed(1)}, ${svgP.y.toFixed(1)})`);
                    
                    // Find all robots and calculate distances
                    const robots = [];
                    const allPoints = {
                        ...this.gameBoard.routePoints, 
                        ...this.gameBoard.innerPoints,  // ADDED: Inner square points!
                        ...this.gameBoard.entryPoints, 
                        ...this.gameBoard.goalPoints
                    };
                    
                    // DEBUG: Log all points with robots
                    const pointsWithRobots = Object.entries(allPoints).filter(([id, data]) => data.robot);
                    console.log(`🤖 Points with robots:`, pointsWithRobots.map(([id, data]) => `${id} (${data.robot.team})`));
                    
                    // CRITICAL DEBUG: Check gameBoard directly for all point types
                    console.log(`🔍 DIRECT gameBoard CHECK:`);
                    console.log(`  entryPoints with robots:`, Object.keys(this.gameBoard.entryPoints).filter(id => this.gameBoard.entryPoints[id].robot));
                    console.log(`  routePoints with robots:`, Object.keys(this.gameBoard.routePoints).filter(id => this.gameBoard.routePoints[id].robot));
                    console.log(`  innerPoints with robots:`, Object.keys(this.gameBoard.innerPoints).filter(id => this.gameBoard.innerPoints[id].robot));
                    console.log(`  goalPoints with robots:`, Object.keys(this.gameBoard.goalPoints).filter(id => this.gameBoard.goalPoints[id].robot));
                    
                    Object.entries(allPoints).forEach(([pointId, pointData]) => {
                        if (pointData.robot) {
                            const dx = svgP.x - pointData.x;
                            const dy = svgP.y - pointData.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            console.log(`  Checking robot at ${pointId}: distance=${distance.toFixed(1)}px (threshold=70px)`);
                            
                            // INCREASED click radius for easier robot selection
                            // Robot image is 88x88px (44px from center to edge)
                            // Using 70px to give generous clickable area around entire robot
                            if (distance <= 70) {
                                robots.push({
                                    pointId,
                                    distance,
                                    team: pointData.robot.team,
                                    robotGroup: document.getElementById(`robot-${pointId}`)
                                });
                            }
                        }
                    });
                    
                    // If we found robots, click the closest one
                    if (robots.length > 0) {
                        robots.sort((a, b) => a.distance - b.distance);
                        const closest = robots[0];
                        
                        console.log(`🎯 Closest robot: ${closest.pointId} at distance ${closest.distance.toFixed(1)}px, team: ${closest.team}`);
                        console.log(`   Robot group exists: ${!!closest.robotGroup}`);
                        console.log(`   Is attackable enemy: ${closest.robotGroup?.classList.contains('attackable-enemy')}`);
                        
                        // Check if this is an attackable enemy
                        if (closest.robotGroup && closest.robotGroup.classList.contains('attackable-enemy')) {
                            console.log(`⚔️ Initiating battle with enemy at ${closest.pointId}!`);
                            const attackerPointId = this.findAdjacentAlly(closest.pointId, closest.team);
                            if (attackerPointId) {
                                this.initiateBattle(attackerPointId, closest.pointId);
                            } else {
                                console.error('❌ No adjacent ally found to initiate battle!');
                            }
                        } else {
                            // Normal robot selection for movement
                            console.log(`📍 Attempting to select robot at ${closest.pointId} for movement`);
                            this.selectRobotForMovement(closest.pointId);
                        }
                    } else {
                        // No robot clicked - check if we clicked on a point (for deployment or movement destination)
                        console.log(`🔍 No robot found - checking for point clicks`);
                        
                        // Find closest point to click (INCREASED radius for easier clicking)
                        const points = [];
                        Object.entries(allPoints).forEach(([pointId, pointData]) => {
                            const dx = svgP.x - pointData.x;
                            const dy = svgP.y - pointData.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // INCREASED: 50px radius to cover space images (70x70px = 35px from center)
                            // This ensures clicks on space images are detected
                            if (distance <= 50) {
                                points.push({ pointId, distance });
                            }
                        });
                        
                        // If we found a point, trigger point click handler
                        if (points.length > 0) {
                            console.log(`📍 Found ${points.length} points within range:`, points.map(p => `${p.pointId} (${p.distance.toFixed(1)}px)`));
                            points.sort((a, b) => a.distance - b.distance);
                            const closestPoint = points[0];
                            console.log(`✅ Selecting closest point: ${closestPoint.pointId} at distance ${closestPoint.distance.toFixed(1)}px`);
                            
                            // Trigger point click handler
                            const pointElement = document.getElementById(closestPoint.pointId);
                            if (pointElement) {
                                this.handlePointClick(pointElement);
                            }
                        } else {
                            console.log(`❌ No point or robot found near click location`);
                        }
                    }
                };
                
                svg.addEventListener('click', this.svgClickHandler);
                console.log('✅ Global SVG click handler installed');
            },

            // Clear all robots from the field
            clearAllRobots() {
                // Remove all visual robots
                const existingRobots = document.querySelectorAll('[id^="robot-"]');
                existingRobots.forEach(robot => robot.remove());
                
                // Clear robot data from all points
                Object.keys(this.gameBoard.routePoints).forEach(pointId => {
                    if (this.gameBoard.routePoints[pointId].robot) {
                        delete this.gameBoard.routePoints[pointId].robot;
                    }
                });
                Object.keys(this.gameBoard.entryPoints).forEach(pointId => {
                    if (this.gameBoard.entryPoints[pointId].robot) {
                        delete this.gameBoard.entryPoints[pointId].robot;
                    }
                });
                Object.keys(this.gameBoard.goalPoints).forEach(pointId => {
                    if (this.gameBoard.goalPoints[pointId].robot) {
                        delete this.gameBoard.goalPoints[pointId].robot;
                    }
                });
                
                console.log('🧹 Cleared all robots from field');
            },

            // Deploy team to bench (off-field storage)
            deployTeamToBench(teamRobots, teamType) {
                console.log(`📋 Deploying ${teamType} team to bench:`, teamRobots);
                
                // Store team data for later deployment (legacy arrays)
                if (teamType === 'player') {
                    this.playerBench = teamRobots.slice(); // Copy array
                } else {
                    this.opponentBench = teamRobots.slice(); // Copy array
                }
                
                // ALSO populate benchSlots structure for Repair Bay system
                const benchSlots = this.playerZones[teamType].benchSlots;
                const slotIds = Object.keys(benchSlots).sort(); // Get slot IDs in order
                teamRobots.forEach((robotId, index) => {
                    if (index < slotIds.length) {
                        benchSlots[slotIds[index]].robotId = robotId;
                        console.log(`📍 Placed ${robotId} in ${slotIds[index]}`);
                    }
                });
                
                // Show bench status
                this.updateBenchDisplay();
            },

            // Update bench display (show available robots)
            updateBenchDisplay(team = null) {
                const playerBenchEl = document.getElementById('bench-section');
                const opponentBenchEl = document.getElementById('opponent-bench-section');
                
                // Update player bench
                if ((team === null || team === 'player') && playerBenchEl) {
                    // Convert benchSlots object to array format for rendering
                    const benchArray = [];
                    const benchSlots = this.playerZones.player.benchSlots;
                    Object.keys(benchSlots).forEach(slotId => {
                        benchArray.push(benchSlots[slotId].robotId);
                    });
                    this.renderBenchRobots(playerBenchEl, benchArray, 'player');
                }
                
                // Update opponent bench
                if ((team === null || team === 'opponent') && opponentBenchEl) {
                    // Convert benchSlots object to array format for rendering
                    const benchArray = [];
                    const benchSlots = this.playerZones.opponent.benchSlots;
                    Object.keys(benchSlots).forEach(slotId => {
                        benchArray.push(benchSlots[slotId].robotId);
                    });
                    this.renderBenchRobots(opponentBenchEl, benchArray, 'opponent');
                }
            },

            // Render robots in bench area
            renderBenchRobots(benchElement, robots, teamType) {
                // Create or get container
                let container = benchElement.querySelector('.bench-robots-container');
                if (!container) {
                    container = document.createElement('div');
                    container.className = 'bench-robots-container';
                    benchElement.appendChild(container);
                }
                container.innerHTML = '';
                
                let renderedCount = 0;
                robots.forEach((robotId, index) => {
                    if (!robotId) {
                        console.log(`📋 Bench slot ${index} is empty (robot deployed)`);
                        return; // Skip empty slots (deployed robots)
                    }
                    
                    const robot = RobotDatabase.getRobot(robotId);
                    if (!robot) {
                        console.warn(`⚠️ Robot ${robotId} not found in database`);
                        return;
                    }
                    
                    // FIRST-TURN HANDICAP: Check if robot is unplayable
                    let isUnplayable = false;
                    let effectiveMP = robot.mp;
                    if (this.isFirstMoveOfGame && robot.mp === 1) {
                        isUnplayable = true;
                        effectiveMP = 0;
                        console.log(`⚠️ ${robot.name} is unplayable on first turn (1 MP - 1 handicap = 0 MP)`);
                    }
                    
                    const robotEl = document.createElement('div');
                    robotEl.className = `bench-robot ${teamType}`;
                    robotEl.id = `bench-${teamType}-${index}`;
                    robotEl.setAttribute('data-robot-id', robotId); // For Combat Dial handler
                    
                    // REPAIR BAY: Check if robot is rebooting
                    const isRebooting = this.isRobotRebooting(robotId, teamType);
                    
                    // Add unplayable class for visual feedback (first turn or rebooting)
                    if (isUnplayable || isRebooting) {
                        robotEl.classList.add('unplayable-first-turn');
                        robotEl.style.opacity = '0.4';
                        robotEl.style.filter = 'grayscale(80%)';
                        robotEl.style.cursor = 'not-allowed';
                    }
                    
                    // Determine badge text
                    let badgeText = '';
                    if (isRebooting) {
                        badgeText = '<div class="unplayable-badge" style="background: rgba(255, 100, 0, 0.8);">⏳ Rebooting</div>';
                    } else if (isUnplayable) {
                        badgeText = '<div class="unplayable-badge">1st Turn</div>';
                    }
                    
                    robotEl.innerHTML = `
                        <img src="${robot.image}" alt="${robot.name}" class="bench-robot-image">
                        <div class="bench-robot-name">${robot.name.split(' ')[0]}</div>
                        <div class="bench-robot-mp">${robot.mp}MP${isUnplayable || isRebooting ? ' ⚠️' : ''}</div>
                        ${badgeText}
                    `;
                    
                    // Make clickable for deployment (will be blocked in selectRobotForDeployment)
                    robotEl.onclick = () => this.selectRobotForDeployment(robotId, teamType, index);
                    
                    container.appendChild(robotEl);
                    renderedCount++;
                });
                
                console.log(`📋 Rendered ${renderedCount} robots in ${teamType} bench (${robots.length - renderedCount} deployed)`);
                
                // Re-attach Combat Dial handlers to newly rendered bench robots
                setTimeout(() => {
                    this.addCombatDialHandlersToAllRobots();
                }, 50);
            },

            // Enable robot interaction and movement
            enableRobotInteraction() {
                console.log('🎮 Enabling robot interaction...');
                
                // Add click handlers to all game board points (circles and groups)
                const allPointCircles = document.querySelectorAll('.point');
                const allPointGroups = document.querySelectorAll('[id^="point-"], [id^="entry-"], [id^="goal-"]');
                
                // Add handlers to both circles and groups to catch all clicks
                [...allPointCircles, ...allPointGroups].forEach(point => {
                    point.addEventListener('click', (e) => this.handlePointClick(e.target));
                    point.style.cursor = 'pointer'; // Make it clear they're clickable
                });
                
                // Add visual feedback
                document.body.classList.add('battle-system-active');
                
                console.log(`✅ Added click handlers to ${allPointCircles.length + allPointGroups.length} elements`);
            },

            // Handle clicks on game board points
            handlePointClick(pointElement) {
                // Handle SVG nested elements - find the parent with ID
                let element = pointElement;
                let pointId = element.id;
                
                // If clicked on inner SVG element (circle, line, etc), find parent group
                if (!pointId || pointId === '') {
                    element = pointElement.closest('[id^="point-"], [id^="entry-"], [id^="goal-"]');
                    if (element) {
                        pointId = element.id;
                    }
                }
                
                if (!pointId) {
                    console.log('❌ No valid point ID found');
                    return;
                }
                
                console.log(`🎯 Clicked point: ${pointId}`);
                
                // If we have a selected robot for deployment
                if (this.selectedRobotForDeployment) {
                    this.deployRobotToPoint(this.selectedRobotForDeployment, pointId);
                    return;
                }
                
                // If point has a robot, select it for movement
                const pointData = this.getPointById(pointId);
                if (pointData && pointData.robot) {
                    this.selectRobotForMovement(pointId);
                } else {
                    // If we have a robot selected for movement, move it here
                    if (this.selectedRobotForMovement) {
                        this.moveRobotToPoint(this.selectedRobotForMovement, pointId);
                    }
                }
            },

            // Select robot for deployment from bench
            selectRobotForDeployment(robotId, teamType, benchIndex) {
                // CLEAR FIRST PRINCIPLE: Always clear previous selection before showing new highlights
                console.log('🧹 CLEAR FIRST: Clearing all previous highlights and selections');
                this.clearSelection();
                this.clearAttackableEnemies();
                
                // REPAIR BAY: Check if robot is rebooting
                if (this.isRobotRebooting(robotId, teamType)) {
                    console.log(`⏳ Cannot deploy ${robotId} - robot is rebooting (Wait 1)`);
                    const robotData = RobotDatabase.getRobot(robotId);
                    this.addToHistory(`⏳ ${robotData?.name || robotId} is rebooting - cannot deploy this turn`, 'info', teamType);
                    return;
                }
                
                // Check if robot has already been moved this turn
                if (this.turnActions.hasMovedRobot) {
                    console.log('⚠️ Cannot deploy - already moved/deployed a robot this turn!');
                    this.showTurnActionMessage('You can only move ONE robot per turn! End your turn to continue.');
                    return;
                }
                
                // In debug mode, only allow deploying for current control team
                if (this.debugMode && teamType !== this.currentControlTeam) {
                    console.log(`❌ Currently controlling ${this.currentControlTeam} team. Switch teams to deploy this robot.`);
                    return;
                }
                
                // Get robot data to check MP
                const robot = RobotDatabase.getRobot(robotId);
                if (!robot) {
                    console.log('❌ Robot data not found');
                    return;
                }
                
                // FIRST-TURN HANDICAP CHECK
                let effectiveMP = robot.mp;
                if (this.isFirstMoveOfGame) {
                    effectiveMP = robot.mp - 1;
                    console.log(`⚠️ FIRST-TURN HANDICAP: ${robot.name} MP reduced from ${robot.mp} to ${effectiveMP}`);
                }
                
                // Check if robot has enough MP to deploy (needs at least 1 MP after handicap)
                if (effectiveMP < 1) {
                    console.log(`❌ Cannot deploy ${robot.name} - insufficient MP after first-turn handicap (${effectiveMP} MP)`);
                    this.showTurnActionMessage(`${robot.name} cannot be deployed on first turn (1 MP robots need 2 MP after -1 handicap)`);
                    return;
                }
                
                console.log(`🎯 Selected ${robotId} for deployment from ${teamType} bench`);
                
                this.selectedRobotForDeployment = {
                    robotId: robotId,
                    teamType: teamType,
                    benchIndex: benchIndex
                };
                
                // Visual feedback for bench robot selection
                const benchEl = document.getElementById(`bench-${teamType}-${benchIndex}`);
                if (benchEl) {
                    benchEl.classList.add('selected');
                }
                
                // SMART DEPLOYMENT: Calculate and highlight ALL possible final destinations
                this.highlightSmartDeploymentDestinations(robotId, teamType, effectiveMP);
            },

            // SMART DEPLOYMENT: Calculate all possible final destinations from bench
            highlightSmartDeploymentDestinations(robotId, teamType, effectiveMP) {
                console.log(`🎯 SMART DEPLOYMENT: Calculating destinations for ${robotId} with ${effectiveMP} effective MP`);
                
                // NOTE: Clearing is already done in selectRobotForDeployment via clearSelection()
                // No need to clear again here - follows "Clear First" principle
                
                // Get entry points for this team
                const entryPoints = teamType === 'player' 
                    ? ['entry-bottom-left', 'entry-bottom-right']
                    : ['entry-top-left', 'entry-top-right'];
                
                // Store all valid destinations
                const allValidDestinations = new Set();
                
                // FREE MOVEMENT MODE: Show ALL empty spaces!
                if (this.freeMovementMode) {
                    console.log(`🚀 FREE MOVEMENT MODE: Showing ALL empty spaces for deployment!`);
                    
                    // Get all points from all categories
                    const allPoints = {
                        ...this.gameBoard.entryPoints,
                        ...this.gameBoard.routePoints,
                        ...this.gameBoard.innerPoints,
                        ...this.gameBoard.goalPoints
                    };
                    
                    // Add all empty points
                    Object.keys(allPoints).forEach(pointId => {
                        const point = allPoints[pointId];
                        if (!point.robot) {
                            allValidDestinations.add(pointId);
                        }
                    });
                } else {
                    // Normal mode: MP-based deployment
                    // Deployment costs 1 MP, so remaining MP for movement is effectiveMP - 1
                    const remainingMP = effectiveMP - 1;
                    console.log(`💰 Deployment cost: 1 MP, Remaining MP for movement: ${remainingMP}`);
                    
                    // For each available entry point
                    entryPoints.forEach(entryPointId => {
                        const entryPointData = this.getPointById(entryPointId);
                        
                        console.log(`📍 Checking entry point: ${entryPointId}`, entryPointData);
                        
                        // Skip if entry point is occupied
                        if (entryPointData.robot) {
                            console.log(`⏭️ Skipping ${entryPointId} - occupied by ${entryPointData.robot.id}`);
                            return;
                        }
                        
                        // Entry point itself is always a valid destination
                        allValidDestinations.add(entryPointId);
                        console.log(`✅ ${entryPointId} is valid (entry point itself)`);
                        
                        // If there's remaining MP, calculate reachable points from this entry
                        if (remainingMP > 0) {
                            console.log(`🔍 Calculating reachable points from ${entryPointId} with ${remainingMP} MP...`);
                            const reachableFromEntry = this.calculateValidMovesWithinMP(entryPointId, remainingMP);
                            console.log(`📊 Found ${reachableFromEntry.length} reachable points:`, reachableFromEntry);
                            reachableFromEntry.forEach(destId => {
                                allValidDestinations.add(destId);
                                console.log(`  ✅ ${destId} is valid (${remainingMP} MP from ${entryPointId})`);
                            });
                        } else {
                            console.log(`⚠️ No remaining MP (${remainingMP}), only entry point itself is valid`);
                        }
                    });
                }
                
                console.log(`🎯 Total valid destinations: ${allValidDestinations.size}`, Array.from(allValidDestinations));
                
                // Highlight all valid destinations
                let highlightedCount = 0;
                allValidDestinations.forEach(pointId => {
                    const pointEl = document.getElementById(pointId);
                    if (pointEl) {
                        console.log(`🎨 Adding 'valid-move' class to ${pointId}`);
                        pointEl.classList.add('valid-move');
                        highlightedCount++;
                        
                        // Also highlight entry space images
                        if (entryPoints.includes(pointId)) {
                            const entryImage = document.querySelector(`.entry-space-image[data-entry="${pointId}"]`);
                            if (entryImage) {
                                entryImage.classList.add('valid-deployment');
                                console.log(`🎨 Added 'valid-deployment' class to entry image for ${pointId}`);
                            }
                        }
                        
                        // CRITICAL: Show movable space image for standard points
                        if (pointEl.classList.contains('standard-point')) {
                            const movableImage = document.querySelector(`.movable-space-image[data-point="${pointId}"]`);
                            if (movableImage) {
                                movableImage.classList.add('active');
                                console.log(`🎨 Activated movable space image for ${pointId}`);
                            }
                        }
                    } else {
                        console.warn(`⚠️ Could not find element for ${pointId}`);
                    }
                });
                
                console.log(`✅ Highlighted ${highlightedCount} out of ${allValidDestinations.size} destinations`);
                
                // Store the valid destinations for click handling
                this.smartDeploymentDestinations = allValidDestinations;
            },

            // Deploy robot to a point (SMART DEPLOYMENT: can deploy to any valid destination)
            async deployRobotToPoint(deploymentData, pointId) {
                console.log(`🚀 Attempting to SMART DEPLOY ${deploymentData.robotId} to ${pointId}...`);
                
                const pointData = this.getPointById(pointId);
                if (!pointData) {
                    console.log('❌ Invalid deployment point');
                    return;
                }
                
                // Check if destination is in the valid smart deployment destinations
                if (this.smartDeploymentDestinations && !this.smartDeploymentDestinations.has(pointId)) {
                    console.log('❌ Not a valid smart deployment destination');
                    this.showDeploymentError('Invalid destination! Click on a highlighted space.');
                    return;
                }
                
                // FREE MOVEMENT MODE: Direct instant deployment to ANY empty space!
                if (this.freeMovementMode) {
                    console.log(`🚀 FREE MOVEMENT MODE: Direct deployment to ${pointId}!`);
                    
                    // Check if destination is occupied
                    if (pointData.robot) {
                        console.log('❌ Destination occupied - cannot deploy!');
                        this.showDeploymentError('Destination is occupied!');
                        return;
                    }
                    
                    // Deploy directly to the point (skip entry point routing)
                    const robotDataObj = {
                        id: deploymentData.robotId,
                        team: deploymentData.teamType
                    };
                    
                    // Set robot data directly in gameBoard
                    if (this.gameBoard.entryPoints[pointId]) {
                        this.gameBoard.entryPoints[pointId].robot = robotDataObj;
                    } else if (this.gameBoard.routePoints[pointId]) {
                        this.gameBoard.routePoints[pointId].robot = robotDataObj;
                    } else if (this.gameBoard.innerPoints[pointId]) {
                        this.gameBoard.innerPoints[pointId].robot = robotDataObj;
                    } else if (this.gameBoard.goalPoints[pointId]) {
                        this.gameBoard.goalPoints[pointId].robot = robotDataObj;
                    }
                    
                    // Add visual robot
                    this.addRobotVisual(pointId, deploymentData.robotId, deploymentData.teamType);
                    
                    // Update status indicators
                    this.updateRobotStatusIndicators(pointId, deploymentData.robotId);
                    
                    // Remove from bench
                    if (deploymentData.teamType === 'player') {
                        this.playerBench[deploymentData.benchIndex] = null;
                    } else {
                        this.opponentBench[deploymentData.benchIndex] = null;
                    }
                    
                    const benchSlots = this.playerZones[deploymentData.teamType].benchSlots;
                    const slotIds = Object.keys(benchSlots).sort();
                    if (deploymentData.benchIndex < slotIds.length) {
                        const slotId = slotIds[deploymentData.benchIndex];
                        benchSlots[slotId].robotId = null;
                    }
                    
                    // Update bench display
                    this.updateBenchDisplay();
                    
                    // Clear selection
                    this.selectedRobotForDeployment = null;
                    this.smartDeploymentDestinations = null;
                    document.querySelectorAll('.bench-robot').forEach(el => el.classList.remove('selected'));
                    document.querySelectorAll('.point').forEach(el => {
                        el.classList.remove('valid-deployment', 'valid-move', 'selected');
                    });
                    
                    // Add to history
                    const robot = RobotDatabase.getRobot(deploymentData.robotId);
                    this.addToHistory(`🚀 ${robot.name} deployed instantly to ${pointId} (Free Movement)`, 'deploy', deploymentData.teamType);
                    
                    console.log(`🚀 FREE MOVEMENT: Instant deployment complete!`);
                    return;
                }
                
                // Normal mode: Entry point routing
                // Get entry points for this team
                const validEntryPoints = deploymentData.teamType === 'player' 
                    ? ['entry-bottom-left', 'entry-bottom-right']
                    : ['entry-top-left', 'entry-top-right'];
                
                // Determine if clicking on entry point directly or a further destination
                const isEntryPoint = validEntryPoints.includes(pointId);
                
                if (isEntryPoint) {
                    // Direct deployment to entry point
                    if (pointData.robot) {
                        console.log('❌ Entry Point occupied - cannot deploy!');
                        this.showDeploymentError('Entry Point is occupied! Move the robot away first.');
                        return;
                    }
                    
                    // GHOST ROBOT FIX: Check if entry point has a visual robot without data
                    const ghostVisual = document.getElementById(`robot-${pointId}`);
                    if (ghostVisual) {
                        console.warn(`⚠️ GHOST ROBOT DETECTED at ${pointId}! Visual exists but no data. Removing ghost...`);
                        this.removeRobotVisual(pointId);
                        console.log(`✅ Ghost robot visual removed from ${pointId}`);
                    }
                    
                    console.log(`📍 Direct deployment to entry point ${pointId}`);
                } else {
                    // Smart deployment to a further destination
                    console.log(`🎯 Smart deployment to ${pointId} (will route through entry point)`);
                    
                    // Find which entry point to use (choose closest unoccupied one)
                    let selectedEntryPoint = null;
                    for (const entryId of validEntryPoints) {
                        const entryData = this.getPointById(entryId);
                        console.log(`🔍 Checking entry ${entryId}:`, entryData.robot ? `OCCUPIED by ${entryData.robot.team}` : 'AVAILABLE');
                        
                        if (!entryData.robot) {
                            // Check if destination is reachable from this entry
                            const robot = RobotDatabase.getRobot(deploymentData.robotId);
                            let effectiveMP = robot.mp;
                            if (this.isFirstMoveOfGame) {
                                effectiveMP = robot.mp - 1;
                            }
                            const remainingMP = effectiveMP - 1; // -1 for deployment cost
                            
                            const reachable = this.calculateValidMovesWithinMP(entryId, remainingMP);
                            if (reachable.includes(pointId)) {
                                selectedEntryPoint = entryId;
                                console.log(`✅ Will deploy via ${entryId} (unoccupied and can reach destination)`);
                                break;
                            } else {
                                console.log(`⏭️ ${entryId} available but cannot reach ${pointId} with ${remainingMP} MP`);
                            }
                        } else {
                            console.log(`⏭️ ${entryId} is BLOCKED by ${entryData.robot.team} - skipping`);
                        }
                    }
                    
                    if (!selectedEntryPoint) {
                        console.log('❌ No valid entry point available for this destination');
                        this.showDeploymentError('Cannot reach this destination!');
                        return;
                    }
                    
                    // First deploy to entry point, then move to final destination
                    await this.executeSmartDeployment(deploymentData, selectedEntryPoint, pointId);
                    return;
                }
                
                console.log(`📍 Deploying to valid entry point for ${deploymentData.teamType} team`);
                console.log(`📊 Before deployment - pointData:`, pointData);
                console.log(`📊 Before deployment - pointData.robot:`, pointData.robot);
                
                // Deploy the robot - add to point data DIRECTLY to gameBoard
                // Don't trust the reference - set it directly
                const robotDataObj = {
                    id: deploymentData.robotId,
                    team: deploymentData.teamType
                };
                
                console.log(`🔍 Checking which point category ${pointId} belongs to:`);
                console.log(`  - entryPoints? ${!!this.gameBoard.entryPoints[pointId]}`);
                console.log(`  - routePoints? ${!!this.gameBoard.routePoints[pointId]}`);
                console.log(`  - innerPoints? ${!!this.gameBoard.innerPoints[pointId]}`);
                console.log(`  - goalPoints? ${!!this.gameBoard.goalPoints[pointId]}`);
                
                if (this.gameBoard.entryPoints[pointId]) {
                    this.gameBoard.entryPoints[pointId].robot = robotDataObj;
                    console.log(`✅ Set robot data directly in gameBoard.entryPoints[${pointId}]`);
                    console.log(`📊 Immediate check: gameBoard.entryPoints[${pointId}].robot =`, this.gameBoard.entryPoints[pointId].robot);
                } else if (this.gameBoard.routePoints[pointId]) {
                    this.gameBoard.routePoints[pointId].robot = robotDataObj;
                    console.log(`✅ Set robot data directly in gameBoard.routePoints[${pointId}]`);
                    console.log(`📊 Immediate check: gameBoard.routePoints[${pointId}].robot =`, this.gameBoard.routePoints[pointId].robot);
                } else if (this.gameBoard.innerPoints[pointId]) {
                    this.gameBoard.innerPoints[pointId].robot = robotDataObj;
                    console.log(`✅ Set robot data directly in gameBoard.innerPoints[${pointId}]`);
                    console.log(`📊 Immediate check: gameBoard.innerPoints[${pointId}].robot =`, this.gameBoard.innerPoints[pointId].robot);
                } else if (this.gameBoard.goalPoints[pointId]) {
                    this.gameBoard.goalPoints[pointId].robot = robotDataObj;
                    console.log(`✅ Set robot data directly in gameBoard.goalPoints[${pointId}]`);
                    console.log(`📊 Immediate check: gameBoard.goalPoints[${pointId}].robot =`, this.gameBoard.goalPoints[pointId].robot);
                }
                
                // Verify it persists via getPointById
                const verifyPoint = this.getPointById(pointId);
                console.log(`✅ Verification via getPointById - ${pointId}.robot:`, verifyPoint?.robot);
                console.log(`✅ Robot data added to point`);
                
                // Add visual robot to game field
                this.addRobotVisual(pointId, deploymentData.robotId, deploymentData.teamType);
                console.log(`✅ Visual robot added to field`);
                
                // Update status indicators for newly deployed robot
                this.updateRobotStatusIndicators(pointId, deploymentData.robotId);
                console.log(`🎯 Updated status indicators for deployed robot at ${pointId}`);
                
                // Remove from bench array
                const benchArray = deploymentData.teamType === 'player' ? this.playerBench : this.opponentBench;
                console.log(`📋 Before removal - Bench:`, benchArray);
                
                if (deploymentData.teamType === 'player') {
                    this.playerBench[deploymentData.benchIndex] = null;
                } else {
                    this.opponentBench[deploymentData.benchIndex] = null;
                }
                
                // ALSO remove from benchSlots structure
                const benchSlots = this.playerZones[deploymentData.teamType].benchSlots;
                const slotIds = Object.keys(benchSlots).sort();
                if (deploymentData.benchIndex < slotIds.length) {
                    const slotId = slotIds[deploymentData.benchIndex];
                    benchSlots[slotId].robotId = null;
                    console.log(`📍 Cleared ${slotId} (robot deployed)`);
                }
                
                console.log(`📋 After removal - Bench:`, benchArray);
                console.log(`✅ Robot removed from bench slot ${deploymentData.benchIndex}`);
                
                // Update bench display (this will re-render without the deployed robot)
                this.updateBenchDisplay();
                console.log(`✅ Bench display updated`);
                
                // Clear deployment selection
                this.selectedRobotForDeployment = null;
                document.querySelectorAll('.bench-robot').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.point').forEach(el => {
                    el.classList.remove('valid-deployment', 'selected');
                });
                
                console.log(`✅ Successfully deployed ${deploymentData.robotId} to ${pointId}!`);
                
                // Add to battle history
                const robotData = RobotDatabase.getRobot(deploymentData.robotId);
                const robotName = robotData ? robotData.name : deploymentData.robotId;
                this.addToHistory(`${robotName} deployed to ${pointId}`, 'deploy', deploymentData.teamType);
                
                // Developer Log: Deployment
                this.addDeveloperLog('DEPLOYMENT', {
                    robotId: deploymentData.robotId,
                    robotName: robotName,
                    team: deploymentData.teamType,
                    location: pointId,
                    benchIndex: deploymentData.benchIndex,
                    isEntryPoint: isEntryPoint,
                    turnLocked: true,
                    firstMove: this.isFirstMoveOfGame
                });
                
                // Mark that robot has been deployed this turn - LOCK-IN to this robot only
                this.turnActions.hasMovedRobot = true;
                this.turnActions.actionTakenThisTurn = true;
                this.turnActions.lastMovedRobotPoint = pointId; // LOCK-IN: Only this robot can battle
                console.log(`✅ Turn action recorded: Robot deployed (movement action used)`);
                console.log(`🔒 LOCK-IN: Only robot at ${pointId} can battle this turn`);
                
                // Clear first move flag after first deployment
                if (this.isFirstMoveOfGame) {
                    this.isFirstMoveOfGame = false;
                    console.log(`✅ First move completed - future moves will use full MP`);
                }
                
                // Clear smart deployment destinations
                this.smartDeploymentDestinations = null;
                
                // Update debug status display
                if (this.debugMode) {
                    this.showDebugControls();
                }
                
                // DEPLOYMENT ENDS TURN (costs 1 MP - your entire move)
                console.log(`⏹️ Deployment complete - turn ended (deployment = 1 MP)`);
                
                // FINAL VERIFICATION: Check robot data one more time before ending
                console.log(`🔍 FINAL CHECK - Robot data at ${pointId}:`);
                if (this.gameBoard.entryPoints[pointId]) {
                    console.log(`  gameBoard.entryPoints[${pointId}].robot =`, this.gameBoard.entryPoints[pointId].robot);
                } else if (this.gameBoard.routePoints[pointId]) {
                    console.log(`  gameBoard.routePoints[${pointId}].robot =`, this.gameBoard.routePoints[pointId].robot);
                }
                const finalCheck = this.getPointById(pointId);
                console.log(`  getPointById(${pointId}).robot =`, finalCheck?.robot);
                
                // Clear selection - do NOT auto-select for movement
                this.clearSelection();
                
                // Check for surrounded enemies (instant KO!)
                this.checkForSurrounds(deploymentData.teamType);
                
                // LOCK-IN: Clear ALL battle highlights first (important!)
                this.clearAttackableEnemies();
                
                // TAGGING CURE CHECK: Check if adjacent allies need healing
                const taggingHandled = this.checkTaggingCure(pointId, deploymentData.teamType);
                if (taggingHandled) {
                    // Tagging cure handled the turn ending or showed choice modal
                    return;
                }
                
                // Check for adjacent enemies ONLY for deployed robot
                const adjacentEnemies = this.highlightAdjacentEnemies(pointId, deploymentData.teamType);
                
                // AUTO-END TURN: If no adjacent enemies to battle, end turn automatically
                if (adjacentEnemies === 0) {
                    console.log('⏩ No adjacent enemies after deployment - auto-ending turn');
                    this.addToHistory('Turn auto-ended (no battles available)', 'info', deploymentData.teamType);
                    setTimeout(() => {
                        this.endPlayerTurn();
                    }, 500); // Small delay for better UX
                } else {
                    // Show message about battle options
                    this.showTurnActionMessage(`Robot deployed! You can battle ${adjacentEnemies} adjacent ${adjacentEnemies === 1 ? 'enemy' : 'enemies'} or end your turn.`);
                }
            },
            
            // Execute smart deployment (deploy to entry, then move to final destination)
            async executeSmartDeployment(deploymentData, entryPointId, finalDestinationId) {
                console.log(`🎯 EXECUTING SMART DEPLOYMENT: ${deploymentData.robotId}`);
                console.log(`   Entry: ${entryPointId} → Final: ${finalDestinationId}`);
                
                // CRITICAL: Check if entry point is occupied by enemy robot
                const entryPointData = this.getPointById(entryPointId);
                if (entryPointData && entryPointData.robot) {
                    console.error(`❌ BLOCKED! Entry point ${entryPointId} is occupied by ${entryPointData.robot.team} robot!`);
                    this.showDeploymentError(`Entry point blocked! Cannot deploy through ${entryPointId}.`);
                    return;
                }
                
                // Check for ghost robots at entry point
                const ghostVisual = document.getElementById(`robot-${entryPointId}`);
                if (ghostVisual) {
                    console.warn(`⚠️ GHOST ROBOT at entry ${entryPointId}! Removing...`);
                    this.removeRobotVisual(entryPointId);
                }
                
                // Step 1: Deploy to entry point (add robot data)
                const robotDataObj = {
                    id: deploymentData.robotId,
                    team: deploymentData.teamType
                };
                
                // Set robot data directly in gameBoard
                if (this.gameBoard.entryPoints[entryPointId]) {
                    this.gameBoard.entryPoints[entryPointId].robot = robotDataObj;
                    console.log(`✅ Robot data set in gameBoard.entryPoints[${entryPointId}]`);
                } else if (this.gameBoard.routePoints[entryPointId]) {
                    this.gameBoard.routePoints[entryPointId].robot = robotDataObj;
                    console.log(`✅ Robot data set in gameBoard.routePoints[${entryPointId}]`);
                }
                
                // Add visual robot at entry point
                this.addRobotVisual(entryPointId, deploymentData.robotId, deploymentData.teamType);
                console.log(`✅ Visual robot added to ${entryPointId}`);
                
                // Wait a moment for visual feedback
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Step 2: Move from entry to final destination
                console.log(`🚀 Moving from ${entryPointId} to ${finalDestinationId}...`);
                
                // Animate the movement
                await this.moveRobotVisual(entryPointId, finalDestinationId);
                console.log(`✅ Visual moved to ${finalDestinationId}`);
                
                // Update robot data (clear source, set destination)
                if (this.gameBoard.entryPoints[entryPointId]) {
                    this.gameBoard.entryPoints[entryPointId].robot = null;
                } else if (this.gameBoard.routePoints[entryPointId]) {
                    this.gameBoard.routePoints[entryPointId].robot = null;
                }
                
                if (this.gameBoard.entryPoints[finalDestinationId]) {
                    this.gameBoard.entryPoints[finalDestinationId].robot = robotDataObj;
                } else if (this.gameBoard.routePoints[finalDestinationId]) {
                    this.gameBoard.routePoints[finalDestinationId].robot = robotDataObj;
                } else if (this.gameBoard.innerPoints[finalDestinationId]) {
                    this.gameBoard.innerPoints[finalDestinationId].robot = robotDataObj;
                } else if (this.gameBoard.goalPoints[finalDestinationId]) {
                    this.gameBoard.goalPoints[finalDestinationId].robot = robotDataObj;
                }
                
                console.log(`✅ Robot data moved to ${finalDestinationId}`);
                
                // Update status indicators for smart deployed robot at final position
                this.updateRobotStatusIndicators(finalDestinationId, deploymentData.robotId);
                console.log(`🎯 Updated status indicators for smart deployed robot at ${finalDestinationId}`);
                
                // Remove from bench
                if (deploymentData.teamType === 'player') {
                    this.playerBench[deploymentData.benchIndex] = null;
                } else {
                    this.opponentBench[deploymentData.benchIndex] = null;
                }
                
                // ALSO remove from benchSlots structure
                const benchSlots = this.playerZones[deploymentData.teamType].benchSlots;
                const slotIds = Object.keys(benchSlots).sort();
                if (deploymentData.benchIndex < slotIds.length) {
                    const slotId = slotIds[deploymentData.benchIndex];
                    benchSlots[slotId].robotId = null;
                    console.log(`📍 Cleared ${slotId} (smart deployment complete)`);
                }
                
                // Update bench display
                this.updateBenchDisplay();
                
                // Clear deployment selection
                this.selectedRobotForDeployment = null;
                this.smartDeploymentDestinations = null;
                document.querySelectorAll('.bench-robot').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.point').forEach(el => {
                    el.classList.remove('valid-deployment', 'valid-move', 'selected');
                });
                
                // Add to history
                const robotData = RobotDatabase.getRobot(deploymentData.robotId);
                const robotName = robotData ? robotData.name : deploymentData.robotId;
                this.addToHistory(`${robotName} deployed to ${finalDestinationId}`, 'deploy', deploymentData.teamType);
                
                // Mark turn action - LOCK-IN to this robot only
                this.turnActions.hasMovedRobot = true;
                this.turnActions.actionTakenThisTurn = true;
                this.turnActions.lastMovedRobotPoint = finalDestinationId; // LOCK-IN: Only this robot can battle
                console.log(`✅ Smart deployment complete!`);
                console.log(`🔒 LOCK-IN: Only robot at ${finalDestinationId} can battle this turn`);
                
                // Clear first move flag after first deployment
                if (this.isFirstMoveOfGame) {
                    this.isFirstMoveOfGame = false;
                    console.log(`✅ First move completed - future moves will use full MP`);
                }
                
                // Check for surrounded enemies (instant KO!)
                this.checkForSurrounds(deploymentData.teamType);
                
                // LOCK-IN: Clear ALL battle highlights first (important!)
                this.clearAttackableEnemies();
                
                // TAGGING CURE CHECK: Check if adjacent allies need healing
                const taggingHandled = this.checkTaggingCure(finalDestinationId, deploymentData.teamType);
                if (taggingHandled) {
                    // Tagging cure handled the turn ending or showed choice modal
                    return;
                }
                
                // Check for adjacent enemies ONLY for deployed robot
                const adjacentEnemies = this.highlightAdjacentEnemies(finalDestinationId, deploymentData.teamType);
                
                // AUTO-END TURN: If no adjacent enemies to battle, end turn automatically
                if (adjacentEnemies === 0) {
                    console.log('⏩ No adjacent enemies after smart deployment - auto-ending turn');
                    this.addToHistory('Turn auto-ended (no battles available)', 'info', deploymentData.teamType);
                    setTimeout(() => {
                        this.endPlayerTurn();
                    }, 500); // Small delay for better UX
                } else {
                    // Show message about battle options
                    this.showTurnActionMessage(`Robot deployed! You can battle ${adjacentEnemies} adjacent ${adjacentEnemies === 1 ? 'enemy' : 'enemies'} or end your turn.`);
                }
            },
            
            // Show deployment error message
            showDeploymentError(message) {
                // Create error overlay
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'fixed';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.95)';
                errorDiv.style.color = 'white';
                errorDiv.style.padding = '20px 40px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.fontSize = '18px';
                errorDiv.style.fontWeight = 'bold';
                errorDiv.style.zIndex = '10000';
                errorDiv.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.8)';
                errorDiv.textContent = `⚠️ ${message}`;
                
                document.body.appendChild(errorDiv);
                
                // Remove after 2 seconds
                setTimeout(() => {
                    errorDiv.remove();
                }, 2000);
            },
            
            // Show turn action message (info/warning)
            showTurnActionMessage(message) {
                // Add to battle log instead of showing pop-up
                this.addToHistory(`ℹ️ ${message}`, 'info');
            },

            // Clear current selection
            // Clear attackable enemy highlights
            clearAttackableEnemies() {
                document.querySelectorAll('.attackable-enemy').forEach(robotGroup => {
                    const circle = robotGroup.querySelector('circle');
                    if (circle) {
                        // Get the team to restore correct color
                        const team = robotGroup.classList.contains('player-robot') ? 'player' : 'opponent';
                        const teamColor = team === 'player' ? '#28a745' : '#dc3545';
                        
                        // Reset to normal appearance
                        circle.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.5))';
                        circle.setAttribute('stroke', '#fff');
                        circle.setAttribute('stroke-width', '6');
                    }
                    robotGroup.classList.remove('attackable-enemy');
                });
                console.log('🧹 Cleared attackable enemy highlights');
            },
            
            clearSelection() {
                this.selectedRobotForDeployment = null;
                this.selectedRobotForMovement = null;
                
                // Clear visual feedback
                document.querySelectorAll('.bench-robot').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.point').forEach(el => {
                    el.classList.remove('valid-deployment', 'selected', 'valid-move');
                    el.style.cursor = ''; // Clear cursor
                });
                
                // Clear movable space images
                document.querySelectorAll('.movable-space-image').forEach(img => {
                    img.classList.remove('active');
                });
                
                // Clear entry space image highlights
                document.querySelectorAll('.entry-space-image').forEach(img => {
                    img.classList.remove('valid-deployment');
                });
                
                // Clear goal space image highlights
                document.querySelectorAll('.goal-space-image').forEach(img => {
                    img.classList.remove('valid-goal');
                });
                
                // Clear robot selection highlights (but NOT attackable-enemy highlights!)
                document.querySelectorAll('.battle-robot').forEach(robotGroup => {
                    // Skip if this is an attackable enemy - don't clear its highlight!
                    if (robotGroup.classList.contains('attackable-enemy')) {
                        return; // Keep the red glow on attackable enemies
                    }
                    
                    const circle = robotGroup.querySelector('circle');
                    if (circle) {
                        // Reset to normal size and shadow (DOUBLED SIZE)
                        circle.setAttribute('r', '50'); // DOUBLED from 25
                        circle.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.5))';
                        circle.setAttribute('stroke', '#fff'); // White border
                        circle.setAttribute('stroke-width', '6');
                    }
                });
                
                console.log('🧹 Selection cleared (kept attackable enemy highlights)');
            },

            // Select robot for movement
            selectRobotForMovement(pointId) {
                console.log(`🔍 Attempting to select robot at ${pointId}`);
                console.log(`📊 Turn Actions State:`, this.turnActions);
                
                // FREE MOVEMENT MODE: Skip all restrictions!
                if (!this.freeMovementMode) {
                    // Check if robot has already been moved this turn
                    if (this.turnActions.hasMovedRobot) {
                        console.log('⚠️ Cannot select robot - already moved/deployed a robot this turn!');
                        this.showTurnActionMessage('You can only move ONE robot per turn! End your turn to continue.');
                        return;
                    }
                }
                
                const pointData = this.getPointById(pointId);
                if (!pointData || !pointData.robot) {
                    console.log('❌ No robot at this point');
                    return;
                }
                
                const robotId = pointData.robot.id;
                const robotData = RobotDatabase.getRobot(robotId);
                
                // FREE MOVEMENT MODE: Skip status checks
                if (!this.freeMovementMode) {
                    // STATUS EFFECT CHECK: Only 'waiting' blocks movement (Repair Bay cooldown)
                    const statuses = this.getRobotStatuses(robotId);
                    if (statuses.markers.includes('waiting')) {
                        console.log(`⏳ Cannot move ${robotData?.name || robotId} - Waiting status (Repair Bay cooldown)!`);
                        this.showTurnActionMessage(`${robotData?.name || robotId} cannot move due to Waiting status (Repair Bay cooldown)!`);
                        this.addToHistory(`⏳ ${robotData?.name || robotId} cannot move (Waiting)`, 'info', pointData.robot.team);
                        return;
                    }
                }

                // FREE MOVEMENT MODE: Allow selecting ANY robot regardless of team
                if (!this.freeMovementMode) {
                    // In debug mode, allow controlling current team
                    if (this.debugMode) {
                        if (pointData.robot.team !== this.currentControlTeam) {
                            console.log(`❌ Currently controlling ${this.currentControlTeam} team. Switch teams to move this robot.`);
                            return;
                        }
                    } else {
                        // Normal mode: only allow player to move their own robots
                        if (pointData.robot.team !== 'player') {
                            console.log('❌ Can only move your own robots');
                            return;
                        }
                    }
                }

                console.log(`🎯 Selected robot ${pointData.robot.id} for movement from ${pointId}`);
                
                // Clear previous selection AND attackable enemies
                this.clearSelection();
                this.clearAttackableEnemies();
                
                // Set new selection
                this.selectedRobotForMovement = {
                    pointId: pointId,
                    robotId: pointData.robot.id,
                    team: pointData.robot.team
                };
                
                // Visual feedback for selected robot - make it glow!
                const robotGroup = document.getElementById(`robot-${pointId}`);
                if (robotGroup) {
                    const circle = robotGroup.querySelector('circle');
                    if (circle) {
                        // Make it bigger and add golden glow (DOUBLED SIZE)
                        circle.setAttribute('r', '60'); // DOUBLED from 30
                        circle.style.filter = 'drop-shadow(0 0 20px rgba(255, 215, 0, 0.9))';
                        circle.setAttribute('stroke', '#ffd700'); // Gold border
                        circle.setAttribute('stroke-width', '8'); // Thicker
                    }
                }
                
                // Highlight valid movement points
                this.highlightValidMovementPoints(pointId);
                
                // TRIGGER 2: Highlight adjacent enemies when robot is selected
                const adjacentEnemies = this.highlightAdjacentEnemies(pointId, pointData.robot.team);
                if (adjacentEnemies > 0) {
                    console.log(`⚔️ ${adjacentEnemies} adjacent ${adjacentEnemies === 1 ? 'enemy' : 'enemies'} available for battle!`);
                }
            },

            // Highlight valid movement points based on MP
            highlightValidMovementPoints(fromPointId) {
                // Clear previous highlights
                document.querySelectorAll('.point').forEach(el => el.classList.remove('valid-move'));
                document.querySelectorAll('.movable-space-image').forEach(img => img.classList.remove('active'));
                
                const pointData = this.getPointById(fromPointId);
                if (!pointData || !pointData.robot) return;
                
                let validMoves = [];
                
                // FREE MOVEMENT MODE: Highlight ALL empty spaces!
                if (this.freeMovementMode) {
                    console.log(`🚀 FREE MOVEMENT MODE: Showing ALL empty spaces!`);
                    
                    // Get all points from all categories
                    const allPoints = {
                        ...this.gameBoard.routePoints,
                        ...this.gameBoard.innerPoints,
                        ...this.gameBoard.entryPoints,
                        ...this.gameBoard.goalPoints
                    };
                    
                    // Add all empty points (not occupied and not the current position)
                    Object.keys(allPoints).forEach(pointId => {
                        const point = allPoints[pointId];
                        if (!point.robot && pointId !== fromPointId) {
                            validMoves.push(pointId);
                        }
                    });
                } else {
                    // Normal mode: Use MP-based movement
                    const robot = RobotDatabase.getRobot(pointData.robot.id);
                    if (!robot) return;
                    
                    let maxMP = robot.mp || 1;
                    
                    // FIRST MOVE PENALTY: First move of game has -1 MP
                    if (this.isFirstMoveOfGame) {
                        maxMP = Math.max(0, maxMP - 1);
                        console.log(`⚠️ FIRST MOVE PENALTY: ${robot.name} MP reduced from ${robot.mp} to ${maxMP}`);
                    }
                    
                    console.log(`🎯 Robot ${robot.name} has ${maxMP} MP - calculating valid moves...`);
                    
                    // Use BFS to find all points within MP range
                    validMoves = this.calculateValidMovesWithinMP(fromPointId, maxMP);
                }
                
                // Highlight all valid destination points
                validMoves.forEach(pointId => {
                    const pointEl = document.getElementById(pointId);
                    if (pointEl) {
                        pointEl.classList.add('valid-move');
                        
                        // Show movable space image for standard points only
                        if (pointEl.classList.contains('standard-point')) {
                            const movableImage = document.querySelector(`.movable-space-image[data-point="${pointId}"]`);
                            if (movableImage) {
                                movableImage.classList.add('active');
                            }
                        }
                    }
                });
                
                console.log(`🎯 Highlighted ${validMoves.length} valid moves from ${fromPointId}`);
            },
            
            // Calculate all valid moves within MP range using PROPER STEP COUNTING
            // Rule: MP = number of steps along routes. Cannot move through occupied points.
            // Starting point (where robot is) = distance 0
            // Adjacent points = distance 1 (costs 1 MP to reach)
            // Points 2 steps away = distance 2 (costs 2 MP to reach)
            calculateValidMovesWithinMP(startPointId, maxMP) {
                const validMoves = [];
                const visited = new Map(); // pointId -> {distance, path}
                const queue = [{ pointId: startPointId, distance: 0, path: [startPointId] }];
                
                visited.set(startPointId, { distance: 0, path: [startPointId] });
                this.validMovePaths.clear(); // Clear previous paths
                
                console.log(`🔍 BFS starting from ${startPointId} with ${maxMP} MP`);
                
                while (queue.length > 0) {
                    const { pointId, distance, path } = queue.shift();
                    
                    // Don't explore beyond MP range
                    if (distance >= maxMP) {
                        console.log(`⏹️ Stopping at ${pointId} (distance ${distance} >= maxMP ${maxMP})`);
                        continue;
                    }
                    
                    const pointData = this.getPointById(pointId);
                    if (!pointData || !pointData.connections) continue;
                    
                    console.log(`🔎 Exploring from ${pointId} (distance ${distance}), connections:`, pointData.connections);
                    
                    // Check all connected points
                    pointData.connections.forEach(connectedPointId => {
                        const connectedPoint = this.getPointById(connectedPointId);
                        if (!connectedPoint) return;
                        
                        const newDistance = distance + 1;
                        const newPath = [...path, connectedPointId];
                        
                        // Skip if we've already visited this point with a shorter path
                        if (visited.has(connectedPointId) && visited.get(connectedPointId).distance <= newDistance) {
                            console.log(`⏭️ Skipping ${connectedPointId} (already visited at distance ${visited.get(connectedPointId).distance})`);
                            return;
                        }
                        
                        // BLOCKING RULE: Cannot move through occupied points
                        if (connectedPoint.robot) {
                            console.log(`🚫 ${connectedPointId} is occupied by ${connectedPoint.robot.id}`);
                            return;
                        }
                        
                        // Point is empty and reachable
                        visited.set(connectedPointId, { distance: newDistance, path: newPath });
                        validMoves.push(connectedPointId);
                        
                        // Store the path to this destination
                        this.validMovePaths.set(connectedPointId, newPath);
                        
                        console.log(`✅ ${connectedPointId} is reachable at distance ${newDistance}, path:`, newPath);
                        
                        // Continue searching from this point (if we have MP left)
                        if (newDistance < maxMP) {
                            queue.push({ 
                                pointId: connectedPointId, 
                                distance: newDistance,
                                path: newPath
                            });
                        }
                    });
                }
                
                console.log(`🎯 Found ${validMoves.length} valid moves within ${maxMP} steps from ${startPointId}`);
                console.log(`🗺️ Stored ${this.validMovePaths.size} paths`);
                return validMoves;
            },

            // Move robot to a point (async to wait for animation)
            async moveRobotToPoint(movementData, toPointId) {
                // CRITICAL: Prevent multiple simultaneous movements
                if (this.isMovementInProgress) {
                    console.warn('⚠️ Movement already in progress - ignoring duplicate call');
                    return;
                }
                this.isMovementInProgress = true;
                
                const fromPointId = movementData.pointId;
                const fromPointData = this.getPointById(fromPointId);
                const toPointData = this.getPointById(toPointId);
                
                console.log(`🚀 Attempting to move robot from ${fromPointId} to ${toPointId}`);
                
                if (!fromPointData || !toPointData) {
                    console.log('❌ Invalid movement points');
                    this.isMovementInProgress = false;
                    return;
                }
                
                // Check if source has a robot
                if (!fromPointData.robot) {
                    console.error(`❌ No robot at source ${fromPointId}!`);
                    this.isMovementInProgress = false;
                    return;
                }
                
                // Check if destination is occupied (DATA check)
                if (toPointData.robot) {
                    console.log('❌ Destination point is occupied (data exists)');
                    this.isMovementInProgress = false;
                    return;
                }
                
                // GHOST ROBOT FIX: Check if destination has a visual robot without data
                const ghostVisual = document.getElementById(`robot-${toPointId}`);
                if (ghostVisual) {
                    console.warn(`⚠️ GHOST ROBOT DETECTED at ${toPointId}! Visual exists but no data. Removing ghost...`);
                    this.removeRobotVisual(toPointId);
                    console.log(`✅ Ghost robot visual removed from ${toPointId}`);
                }
                
                // Get robot data
                const robot = RobotDatabase.getRobot(movementData.robotId);
                if (!robot) {
                    console.log('❌ Robot data not found');
                    this.isMovementInProgress = false;
                    return;
                }
                
                // FREE MOVEMENT MODE: Skip MP validation
                if (!this.freeMovementMode) {
                    // Validate move is within MP range
                    const validMoves = this.calculateValidMovesWithinMP(fromPointId, robot.mp);
                    if (!validMoves.includes(toPointId)) {
                        console.log(`❌ Destination not within ${robot.mp} MP range`);
                        this.isMovementInProgress = false;
                        return;
                    }
                    console.log(`✅ Valid move within ${robot.mp} MP range`);
                } else {
                    console.log(`🚀 FREE MOVEMENT MODE: Skipping MP validation - instant teleport!`);
                }
                
                // Animate the visual robot first (wait for animation to complete)
                console.log(`🎬 Starting animation from ${fromPointId} to ${toPointId}...`);
                await this.moveRobotVisual(fromPointId, toPointId);
                console.log(`🎨 Robot visual animation complete`);
                
                // Now update the robot data
                console.log(`📊 Before move - fromPoint.robot:`, fromPointData.robot);
                console.log(`📊 Before move - toPoint.robot:`, toPointData.robot);
                
                // CRITICAL: Set data directly in gameBoard, not via reference
                const robotDataToMove = fromPointData.robot;
                
                // Clear source point directly in gameBoard
                if (this.gameBoard.entryPoints[fromPointId]) {
                    this.gameBoard.entryPoints[fromPointId].robot = null;
                } else if (this.gameBoard.routePoints[fromPointId]) {
                    this.gameBoard.routePoints[fromPointId].robot = null;
                } else if (this.gameBoard.innerPoints[fromPointId]) {
                    this.gameBoard.innerPoints[fromPointId].robot = null;
                } else if (this.gameBoard.goalPoints[fromPointId]) {
                    this.gameBoard.goalPoints[fromPointId].robot = null;
                }
                
                // Set destination point directly in gameBoard
                if (this.gameBoard.entryPoints[toPointId]) {
                    this.gameBoard.entryPoints[toPointId].robot = robotDataToMove;
                } else if (this.gameBoard.routePoints[toPointId]) {
                    this.gameBoard.routePoints[toPointId].robot = robotDataToMove;
                } else if (this.gameBoard.innerPoints[toPointId]) {
                    this.gameBoard.innerPoints[toPointId].robot = robotDataToMove;
                } else if (this.gameBoard.goalPoints[toPointId]) {
                    this.gameBoard.goalPoints[toPointId].robot = robotDataToMove;
                }
                
                console.log(`📊 After move - set directly in gameBoard`);
                
                // Verify the data persists in gameBoard
                const verifyTo = this.getPointById(toPointId);
                const verifyFrom = this.getPointById(fromPointId);
                console.log(`✅ Verification - ${toPointId}.robot:`, verifyTo.robot);
                console.log(`✅ Verification - ${fromPointId}.robot:`, verifyFrom.robot);
                
                // Update DOM attributes for source point
                const fromElement = document.getElementById(fromPointId);
                if (fromElement) {
                    fromElement.setAttribute('data-occupied', 'false');
                    fromElement.setAttribute('data-team', 'neutral');
                }
                
                // Update DOM attributes for destination point
                const toElement = document.getElementById(toPointId);
                if (toElement) {
                    toElement.setAttribute('data-occupied', 'true');
                    toElement.setAttribute('data-team', movementData.team);
                }
                
                console.log(`📦 Robot data moved from ${fromPointId} to ${toPointId}`);
                
                // Developer Log: Movement
                this.addDeveloperLog('MOVEMENT', {
                    robotId: movementData.robotId,
                    robotName: robot.name,
                    team: movementData.team,
                    from: fromPointId,
                    to: toPointId,
                    mp: robot.mp,
                    turnLocked: !this.freeMovementMode,
                    firstMove: this.isFirstMoveOfGame,
                    freeMovement: this.freeMovementMode
                });
                
                // FREE MOVEMENT MODE: Don't consume turn action!
                if (!this.freeMovementMode) {
                    // Mark that robot has been moved this turn - LOCK-IN to this robot only
                    this.turnActions.hasMovedRobot = true;
                    this.turnActions.actionTakenThisTurn = true;
                    this.turnActions.lastMovedRobotPoint = toPointId; // LOCK-IN: Only this robot can battle
                    console.log(`✅ Turn action recorded: Robot moved (movement action used)`);
                    console.log(`🔒 LOCK-IN: Only robot at ${toPointId} can battle this turn`);
                } else {
                    console.log(`🚀 FREE MOVEMENT MODE: Movement does not consume turn action!`);
                }
                
                // Clear first move flag after first movement
                if (this.isFirstMoveOfGame) {
                    this.isFirstMoveOfGame = false;
                    console.log(`✅ First move completed - future moves will use full MP`);
                }
                
                // Update debug status display
                if (this.debugMode) {
                    this.showDebugControls();
                }
                
                // Clear selection and highlights
                this.clearSelection();
                
                console.log(`✅ Successfully moved robot ${movementData.robotId} from ${fromPointId} to ${toPointId}`);
                
                // Update status indicators to follow the robot to new position
                this.updateRobotStatusIndicators(toPointId, movementData.robotId);
                console.log(`🎯 Updated status indicators for robot at new position ${toPointId}`);
                
                // Add to battle history with detailed info
                const robotData = RobotDatabase.getRobot(movementData.robotId);
                const robotName = robotData ? robotData.name : movementData.robotId;
                this.addToHistory(`${robotName} moved from ${fromPointId} to ${toPointId}`, 'move', movementData.team);
                
                // Check for surrounded enemies (instant KO!)
                this.checkForSurrounds(movementData.team);
                
                // LOCK-IN: Clear ALL battle highlights first (important!)
                this.clearAttackableEnemies();
                
                // TRIGGER 3: Highlight ONLY adjacent enemies for the robot that just moved
                const adjacentEnemies = this.highlightAdjacentEnemies(toPointId, movementData.team);
                
                // Check if robot reached a goal (WIN CONDITION!)
                if (this.checkWinConditions(movementData.team)) {
                    console.log(`🏆 ${movementData.team} reached the goal and wins!`);
                    const robotData = RobotDatabase.getRobot(movementData.robotId);
                    const robotName = robotData ? robotData.name : movementData.robotId;
                    this.addToHistory(`🏆 ${robotName} captured the goal!`, 'win', movementData.team);
                    this.addToHistory(`🏆 ${movementData.team.toUpperCase()} WINS THE BATTLE!`, 'win', null);
                    this.isMovementInProgress = false; // Reset flag
                    return; // Stop processing, game is over
                }
                
                // AUTO-END TURN: If no adjacent enemies to battle, end turn automatically
                if (adjacentEnemies === 0) {
                    console.log('⏩ No adjacent enemies - auto-ending turn');
                    this.addToHistory('Turn auto-ended (no battles available)', 'info', movementData.team);
                    setTimeout(() => {
                        this.endPlayerTurn();
                    }, 500); // Small delay for better UX
                } else {
                    // Show message about turn action
                    this.showTurnActionMessage(`Robot moved! You can battle ${adjacentEnemies} adjacent ${adjacentEnemies === 1 ? 'enemy' : 'enemies'} or end your turn.`);
                }
                
                // Reset movement flag
                this.isMovementInProgress = false;
            },

            // ==========================================
            // SURROUNDING MECHANIC
            // ==========================================
            
            // Check if any enemy robots are surrounded and knock them out
            checkForSurrounds(attackerTeam) {
                const enemyTeam = attackerTeam === 'player' ? 'opponent' : 'player';
                const surroundedEnemies = [];
                
                console.log(`\n🔍 === CHECKING FOR SURROUNDS (after ${attackerTeam} move) ===`);
                
                // Get all points on the board
                const allPoints = {
                    ...this.gameBoard.routePoints,
                    ...this.gameBoard.innerPoints,
                    ...this.gameBoard.entryPoints,
                    ...this.gameBoard.goalPoints
                };
                
                // Check each enemy robot
                Object.entries(allPoints).forEach(([pointId, pointData]) => {
                    if (pointData.robot && pointData.robot.team === enemyTeam) {
                        // Get all connections for this point
                        const connections = pointData.connections || [];
                        
                        // Check if ALL adjacent spaces are occupied by attacker's team
                        const allAdjacentOccupied = connections.length > 0 && connections.every(connectedId => {
                            const connectedPoint = this.getPointById(connectedId);
                            return connectedPoint?.robot && connectedPoint.robot.team === attackerTeam;
                        });
                        
                        if (allAdjacentOccupied) {
                            surroundedEnemies.push({ pointId, robot: pointData.robot });
                        }
                    }
                });
                
                // Remove surrounded enemies
                if (surroundedEnemies.length > 0) {
                    console.log(`💥 SURROUNDED! Removing ${surroundedEnemies.length} enemy robot(s):`);
                    surroundedEnemies.forEach(({ pointId, robot }) => {
                        const robotData = RobotDatabase.getRobot(robot.id);
                        console.log(`   - ${robotData?.name || robot.id} at ${pointId}`);
                        this.addToHistory(`${robotData?.name || robot.id} SURROUNDED at ${pointId}! Instant KO!`, 'battle', enemyTeam);
                        this.knockOutRobot(pointId);  // Fixed: was removeRobotFromPoint
                    });
                } else {
                    console.log(`✅ No enemies surrounded this turn`);
                }
            },
            
            // Initiate battle between two robots
            initiateBattle(attackerPointId, defenderPointId) {
                // Check if battle has already been initiated this turn
                if (this.turnActions.hasBattled) {
                    console.log('⚠️ Cannot battle - already battled this turn!');
                    this.showTurnActionMessage('You can only initiate ONE battle per turn!');
                    return;
                }
                
                // LOCK-IN CHECK: If a robot has moved, only that robot can battle
                if (this.turnActions.lastMovedRobotPoint && this.turnActions.lastMovedRobotPoint !== attackerPointId) {
                    console.log(`🔒 LOCK-IN ENFORCED: Cannot battle with robot at ${attackerPointId}`);
                    console.log(`   Only robot at ${this.turnActions.lastMovedRobotPoint} (the one that moved) can battle this turn`);
                    this.showTurnActionMessage(`You can only battle with the robot you just moved! (at ${this.turnActions.lastMovedRobotPoint})`);
                    return;
                }
                
                const attackerPoint = this.getPointById(attackerPointId);
                const defenderPoint = this.getPointById(defenderPointId);
                
                if (!attackerPoint?.robot || !defenderPoint?.robot) {
                    console.error('❌ Invalid battle participants');
                    return;
                }
                
                // STATUS EFFECT CHECK: Prevent battle initiation if attacker has action-blocking status
                const attackerStatuses = this.getRobotStatuses(attackerPoint.robot.id);
                const actionBlockers = ['sleep', 'frozen', 'waiting'];
                const blockingStatus = actionBlockers.find(s => 
                    attackerStatuses.conditions.includes(s) || attackerStatuses.markers.includes(s)
                );
                
                if (blockingStatus) {
                    const attackerRobotTemp = RobotDatabase.getRobot(attackerPoint.robot.id);
                    const statusNames = {
                        'sleep': '💤 Sleep',
                        'frozen': '🧊 Frozen',
                        'waiting': '⏳ Waiting'
                    };
                    const displayName = statusNames[blockingStatus] || blockingStatus;
                    console.log(`❌ Cannot initiate battle - ${attackerRobotTemp?.name} is affected by ${displayName}!`);
                    this.showTurnActionMessage(`${attackerRobotTemp?.name} cannot initiate battle due to ${displayName} status!`);
                    this.addToHistory(`❌ ${attackerRobotTemp?.name} cannot battle (${displayName})`, 'info', attackerPoint.robot.team);
                    return;
                }
                
                const attackerRobot = RobotDatabase.getRobot(attackerPoint.robot.id);
                const defenderRobot = RobotDatabase.getRobot(defenderPoint.robot.id);
                
                if (!attackerRobot || !defenderRobot) {
                    console.error('❌ Robot data not found');
                    return;
                }
                
                console.log(`⚔️ Initiating battle: ${attackerRobot.name} vs ${defenderRobot.name}`);
                
                // Add to battle history with positions
                const attackerTeam = attackerPoint.robot.team;
                this.addToHistory(`⚔️ ${attackerRobot.name} (${attackerPointId}) attacks ${defenderRobot.name} (${defenderPointId})`, 'battle', attackerTeam);
                
                // Mark that battle has been initiated this turn
                this.turnActions.hasBattled = true;
                this.turnActions.actionTakenThisTurn = true;
                console.log(`✅ Turn action recorded: Battle initiated (battle action used)`);
                
                // Update debug status display
                if (this.debugMode) {
                    this.showDebugControls();
                }
                
                // Store battle data
                this.currentBattle = {
                    attackerPointId: attackerPointId,
                    defenderPointId: defenderPointId,
                    attackerRobot: attackerRobot,
                    defenderRobot: defenderRobot,
                    attackerRobotInstanceId: attackerPoint.robot.id, // Instance ID for status effects
                    defenderRobotInstanceId: defenderPoint.robot.id, // Instance ID for status effects
                    attackerTeam: attackerPoint.robot.team,
                    defenderTeam: defenderPoint.robot.team
                };
                
                // Show battle modal
                this.showBattleModal();
            },
            
            // Show battle modal with robot info
            showBattleModal() {
                if (!this.currentBattle) return;
                
                const { attackerRobot, defenderRobot, attackerTeam, defenderTeam, attackerPointId, defenderPointId } = this.currentBattle;
                
                // Get status effects for both robots
                const attackerStatuses = this.getRobotStatuses(this.getPointById(attackerPointId)?.robot?.id);
                const defenderStatuses = this.getRobotStatuses(this.getPointById(defenderPointId)?.robot?.id);
                
                // Build status effect HTML helper function
                const buildStatusHTML = (statuses) => {
                    if (statuses.conditions.length === 0 && statuses.markers.length === 0) {
                        return '';
                    }
                    const allStatuses = [...statuses.conditions, ...statuses.markers];
                    return allStatuses.map(s => {
                        const def = this.statusEffectDefinitions[s];
                        return def ? `<span style="font-size: 10px; padding: 2px 4px; background: ${def.color}; border-radius: 3px; margin-left: 4px;">${def.icon}</span>` : '';
                    }).join('');
                };
                
                // Update modal content
                document.getElementById('battlePlayerImage').src = attackerRobot.image;
                document.getElementById('battlePlayerName').innerHTML = `${attackerRobot.name}${buildStatusHTML(attackerStatuses)}`;
                document.getElementById('battlePlayerRole').textContent = `${attackerRobot.role} • ${attackerRobot.mp} MP`;
                
                document.getElementById('battleOpponentImage').src = defenderRobot.image;
                document.getElementById('battleOpponentName').innerHTML = `${defenderRobot.name}${buildStatusHTML(defenderStatuses)}`;
                document.getElementById('battleOpponentRole').textContent = `${defenderRobot.role} • ${defenderRobot.mp} MP`;
                
                // Hide combatants, show wheels with move lists immediately
                document.querySelector('.battle-combatants').style.display = 'none';
                document.getElementById('battleWheels').style.display = 'flex';
                document.getElementById('battleResult').classList.remove('active');
                
                // Set wheel labels
                const attackerLabel = attackerTeam === 'player' ? 'PLAYER' : 'OPPONENT';
                const defenderLabel = defenderTeam === 'player' ? 'PLAYER' : 'OPPONENT';
                
                document.getElementById('attackerWheelLabel').textContent = `${attackerLabel} - ${attackerRobot.name}`;
                document.getElementById('defenderWheelLabel').textContent = `${defenderLabel} - ${defenderRobot.name}`;
                
                // Build wheels and detailed move lists with status effects
                const attackerRobotId = this.getPointById(attackerPointId)?.robot?.id;
                const defenderRobotId = this.getPointById(defenderPointId)?.robot?.id;
                
                this.buildWheelVisual('attackerWheelSegments', attackerRobot.wheel);
                this.buildWheelVisual('defenderWheelSegments', defenderRobot.wheel);
                this.buildBattleMovesList('attackerMovesList', attackerRobot.wheel, attackerRobotId);
                this.buildBattleMovesList('defenderMovesList', defenderRobot.wheel, defenderRobotId);
                
                // Restore action buttons (without Info button)
                const buttonsContainer = document.querySelector('.battle-action-buttons');
                buttonsContainer.innerHTML = `
                    <button class="battle-action-btn attack" onclick="GameBoard.executeBattle()">
                        ⚔️ Attack!
                    </button>
                    <button class="battle-action-btn cancel" onclick="GameBoard.cancelBattle()">
                        ↩️ Cancel
                    </button>
                `;
                buttonsContainer.style.display = 'flex';
                
                // Reset wheel results (hide them since we show move lists instead)
                const attackerResult = document.getElementById('attackerWheelResult');
                const defenderResult = document.getElementById('defenderWheelResult');
                
                attackerResult.style.display = 'none';
                defenderResult.style.display = 'none';
                
                attackerResult.querySelector('.move-name').textContent = 'Spinning...';
                attackerResult.querySelector('.move-power').textContent = '';
                attackerResult.classList.remove('revealed');
                attackerResult.style.color = '#fff';
                
                defenderResult.querySelector('.move-name').textContent = 'Spinning...';
                defenderResult.querySelector('.move-power').textContent = '';
                defenderResult.classList.remove('revealed');
                defenderResult.style.color = '#fff';
                
                // Reset wheel rotations
                const attackerWheelSegments = document.getElementById('attackerWheelSegments');
                const defenderWheelSegments = document.getElementById('defenderWheelSegments');
                if (attackerWheelSegments) {
                    attackerWheelSegments.style.transform = 'rotate(0deg)';
                    attackerWheelSegments.style.transition = 'none';
                }
                if (defenderWheelSegments) {
                    defenderWheelSegments.style.transform = 'rotate(0deg)';
                    defenderWheelSegments.style.transition = 'none';
                }
                
                // Show overlay
                document.getElementById('battleOverlay').classList.add('active');
                
                // Populate debugger with battle data
                this.populateDebugger(attackerRobot, defenderRobot, attackerTeam, defenderTeam);
                
                console.log('🎮 Battle modal displayed with move lists');
            },
            
            // ==========================================
            // STATUS EFFECT BATTLE INTEGRATION
            // ==========================================
            
            // Apply status effects to a wheel spin result
            applyStatusEffectsToBattleSpin(robotId, spinResult, role = 'attacker', opponentRobotId = null) {
                if (!spinResult) return spinResult;
                
                let modifiedSpin = { ...spinResult };
                
                // Strip instance ID suffixes to get base robot ID for database lookup
                const baseRobotId = robotId.replace(/-opp$/, '').replace(/-c-\d+$/, '').replace(/-uc-\d+$/, '').replace(/-r-\d+$/, '').replace(/-ex-\d+$/, '');
                const robotData = RobotDatabase.getRobot(baseRobotId);
                const originalDamage = spinResult.damage || 0;
                
                console.log(`\n🔧 Applying status effects to ${robotData?.name || robotId} (${role}):`);
                console.log(`   Instance ID: ${robotId}`);
                console.log(`   Status effects:`, this.robotStatusEffects[robotId]);
                console.log(`   Has poison?`, this.hasStatusEffect(robotId, 'poison'));
                console.log(`   Original: ${spinResult.moveName} (${spinResult.moveType}) - ${originalDamage} damage`);
                
                // 1. CONFUSION: Shift result one segment clockwise
                if (this.hasStatusEffect(robotId, 'confusion')) {
                    console.log(`😵 ${robotData?.name || robotId} is Confused - shifting result clockwise`);
                    modifiedSpin = this.shiftSpinResultClockwise(robotId, modifiedSpin);
                }
                
                // 2. FROZEN: All attacks become Miss (cannot take actions)
                if (this.hasStatusEffect(robotId, 'frozen')) {
                    const frozenMoveType = modifiedSpin.moveType ? modifiedSpin.moveType.toLowerCase() : '';
                    if (frozenMoveType === 'white' || frozenMoveType === 'gold') {
                        console.log(`🧊 ${robotData?.name || robotId} is Frozen - attack becomes Miss!`);
                        modifiedSpin = {
                            ...modifiedSpin,
                            moveType: 'blue',
                            moveName: 'Miss (Frozen)',
                            damage: 0
                        };
                    }
                    // Thaw after battle (only when defending/being attacked)
                    if (role === 'defender') {
                        this.removeStatusEffect(robotId, 'frozen');
                        console.log(`🌊 ${robotData?.name || robotId} thawed from Frozen!`);
                    }
                }
                
                // 3. SLEEP: Wake up when attacked (but doesn't affect current battle outcome)
                if (role === 'defender' && this.hasStatusEffect(robotId, 'sleep')) {
                    this.removeStatusEffect(robotId, 'sleep');
                    console.log(`💤 ${robotData?.name || robotId} woke up from Sleep!`);
                }
                
                // 4. PARALYSIS & BURN: Convert smallest attack to Miss
                if (this.hasStatusEffect(robotId, 'paralysis') || this.hasStatusEffect(robotId, 'burn')) {
                    const statusName = this.hasStatusEffect(robotId, 'paralysis') ? 'Paralysis' : 'Burn';
                    const icon = this.hasStatusEffect(robotId, 'paralysis') ? '⚡' : '🔥';
                    
                    if (this.isSmallestAttackSegment(robotId, modifiedSpin)) {
                        console.log(`${icon} ${robotData?.name || robotId} has ${statusName} - smallest attack becomes Miss!`);
                        modifiedSpin = {
                            ...modifiedSpin,
                            moveType: 'blue',
                            moveName: `Miss (${statusName})`,
                            damage: 0
                        };
                    }
                }
                
                // 5. POISON, NOXIOUS, BURN: Reduce damage on White/Gold attacks
                console.log(`   🔍 Checking damage reduction: moveType=${modifiedSpin.moveType}, damage=${modifiedSpin.damage}`);
                const moveTypeLower = modifiedSpin.moveType ? modifiedSpin.moveType.toLowerCase() : '';
                if (moveTypeLower === 'white' || moveTypeLower === 'gold') {
                    let damageReduction = 0;
                    const reductions = [];
                    
                    console.log(`   🔍 White/Gold attack detected, checking status effects...`);
                    if (this.hasStatusEffect(robotId, 'poison')) {
                        damageReduction += 20;
                        reductions.push('Poison -20');
                        console.log(`   🧪 Poison detected! damageReduction now: ${damageReduction}`);
                    }
                    if (this.hasStatusEffect(robotId, 'noxious')) {
                        damageReduction += 40;
                        reductions.push('Noxious -40');
                        console.log(`   ☠️ Noxious detected! damageReduction now: ${damageReduction}`);
                    }
                    if (this.hasStatusEffect(robotId, 'burn')) {
                        damageReduction += 10;
                        reductions.push('Burn -10');
                        console.log(`   🔥 Burn detected! damageReduction now: ${damageReduction}`);
                    }
                    
                    console.log(`   📊 Final damageReduction: ${damageReduction}, modifiedSpin.damage: ${modifiedSpin.damage}`);
                    console.log(`   📊 Condition check: damageReduction > 0? ${damageReduction > 0}, modifiedSpin.damage > 0? ${modifiedSpin.damage > 0}`);
                    
                    if (damageReduction > 0 && modifiedSpin.damage > 0) {
                        const originalDamage = modifiedSpin.damage;
                        modifiedSpin.damage = Math.max(0, modifiedSpin.damage - damageReduction);
                        console.log(`🧪 ${robotData?.name || robotId} damage reduced: ${originalDamage} → ${modifiedSpin.damage} (${reductions.join(', ')})`);
                    } else {
                        console.log(`   ⚠️ Damage reduction NOT applied: damageReduction=${damageReduction}, damage=${modifiedSpin.damage}`);
                    }
                }
                
                const finalDamage = modifiedSpin.damage || 0;
                if (finalDamage !== originalDamage) {
                    console.log(`   ✅ MODIFIED: ${modifiedSpin.moveName} (${modifiedSpin.moveType}) - ${finalDamage} damage (was ${originalDamage})`);
                } else {
                    console.log(`   ✅ NO CHANGE: ${modifiedSpin.moveName} (${modifiedSpin.moveType}) - ${finalDamage} damage`);
                }
                
                return modifiedSpin;
            },
            
            // Shift a spin result one segment clockwise (for Confusion)
            shiftSpinResultClockwise(robotId, spinResult) {
                // Strip instance ID suffixes to get base robot ID
                const baseRobotId = robotId.replace(/-opp$/, '').replace(/-c-\d+$/, '').replace(/-uc-\d+$/, '').replace(/-r-\d+$/, '').replace(/-ex-\d+$/, '');
                const robotData = RobotDatabase.getRobot(baseRobotId);
                const wheel = robotData.wheel;
                
                // Find current segment index
                let currentIndex = -1;
                for (let i = 0; i < wheel.length; i++) {
                    if (wheel[i].moveName === spinResult.moveName && 
                        wheel[i].moveType === spinResult.moveType) {
                        currentIndex = i;
                        break;
                    }
                }
                
                if (currentIndex === -1) return spinResult;
                
                // Get next segment (clockwise)
                const nextIndex = (currentIndex + 1) % wheel.length;
                const nextSegment = wheel[nextIndex];
                
                console.log(`   Shifted from ${spinResult.moveName} → ${nextSegment.moveName}`);
                return { ...nextSegment };
            },
            
            // Check if a spin result is the smallest attack segment on the wheel
            isSmallestAttackSegment(robotId, spinResult) {
                // Strip instance ID suffixes to get base robot ID
                const baseRobotId = robotId.replace(/-opp$/, '').replace(/-c-\d+$/, '').replace(/-uc-\d+$/, '').replace(/-r-\d+$/, '').replace(/-ex-\d+$/, '');
                const robotData = RobotDatabase.getRobot(baseRobotId);
                const wheel = robotData.wheel;
                
                // Only check if it's an attack (white or gold)
                const spinMoveType = spinResult.moveType ? spinResult.moveType.toLowerCase() : '';
                if (spinMoveType !== 'white' && spinMoveType !== 'gold') {
                    return false;
                }
                
                // Find all attack segments
                const attackSegments = wheel.filter(seg => {
                    const segMoveType = seg.moveType ? seg.moveType.toLowerCase() : '';
                    return segMoveType === 'white' || segMoveType === 'gold';
                });
                
                if (attackSegments.length === 0) return false;
                
                // Find smallest damage value
                const smallestDamage = Math.min(...attackSegments.map(seg => seg.damage || 0));
                
                // Check if this spin matches the smallest
                return spinResult.damage === smallestDamage;
            },
            
            // Execute the battle using Data Disk system
            async executeBattle() {
                if (!this.currentBattle) return;
                
                const { attackerRobot, defenderRobot, attackerPointId, defenderPointId, attackerTeam, defenderTeam } = this.currentBattle;
                
                console.log(`⚔️ Executing battle: ${attackerRobot.name} vs ${defenderRobot.name}`);
                
                // Hide action buttons and combatants
                document.querySelector('.battle-action-buttons').style.display = 'none';
                document.querySelector('.battle-combatants').style.display = 'none';
                
                // Show spinning wheels
                const wheelsContainer = document.getElementById('battleWheels');
                wheelsContainer.style.display = 'flex';
                
                // Set wheel labels based on team
                // Note: attacker is typically opponent, defender is typically player
                const attackerLabel = attackerTeam === 'player' ? 'PLAYER' : 'OPPONENT';
                const defenderLabel = defenderTeam === 'player' ? 'PLAYER' : 'OPPONENT';
                
                document.getElementById('attackerWheelLabel').textContent = `${attackerLabel} - ${attackerRobot.name}`;
                document.getElementById('defenderWheelLabel').textContent = `${defenderLabel} - ${defenderRobot.name}`;
                
                // Use the existing Data Disk combat system
                const result = await this.simulateDataDiskBattleWithAnimation(attackerRobot, defenderRobot);
                
                console.log('📊 Battle result:', result);
                
                // Show result after animation completes
                setTimeout(() => {
                    wheelsContainer.style.display = 'none';
                    this.removeMoveFlashes(); // Clean up overlays
                    this.displayBattleResult(result);
                }, 500);
            },
            
            // Simulate Data Disk battle WITH animation
            async simulateDataDiskBattleWithAnimation(attacker, defender) {
                // Check if debugger mode is enabled and moves are selected
                let attackerSpinData, defenderSpinData;
                
                if (this.debugger.enabled && 
                    this.debugger.selectedPlayerMove !== null && 
                    this.debugger.selectedOpponentMove !== null) {
                    
                    console.log('🛠️ DEBUGGER MODE: Forcing battle outcome');
                    
                    // Determine which robot is player and which is opponent
                    const { attackerTeam, defenderTeam } = this.currentBattle;
                    const playerIsAttacker = attackerTeam === 'player';
                    
                    // Get forced move indices
                    const attackerMoveIndex = playerIsAttacker ? this.debugger.selectedPlayerMove : this.debugger.selectedOpponentMove;
                    const defenderMoveIndex = playerIsAttacker ? this.debugger.selectedOpponentMove : this.debugger.selectedPlayerMove;
                    
                    // Force specific moves
                    attackerSpinData = this.forceWheelPosition(attacker.wheel, attackerMoveIndex);
                    defenderSpinData = this.forceWheelPosition(defender.wheel, defenderMoveIndex);
                    
                    console.log(`🛠️ Forced ${attacker.name} to spin: ${attackerSpinData.segment.moveName}`);
                    console.log(`🛠️ Forced ${defender.name} to spin: ${defenderSpinData.segment.moveName}`);
                } else {
                    // Normal random spin
                    attackerSpinData = this.spinWheelWithPosition(attacker.wheel);
                    defenderSpinData = this.spinWheelWithPosition(defender.wheel);
                }
                
                let attackerSpin = attackerSpinData.segment;
                let defenderSpin = defenderSpinData.segment;
                
                console.log(`🎲 ${attacker.name} spun: ${attackerSpin.moveName} (${attackerSpin.moveType}) at position ${attackerSpinData.spinPosition}`);
                console.log(`🎲 ${defender.name} spun: ${defenderSpin.moveName} (${defenderSpin.moveType}) at position ${defenderSpinData.spinPosition}`);
                
                // Developer Log: Spin Results
                this.addDeveloperLog('SPIN_RESULT', {
                    attacker: {
                        robot: attacker.name,
                        robotId: attacker.id,
                        move: attackerSpin.moveName,
                        moveType: attackerSpin.moveType,
                        damage: attackerSpin.damage,
                        stars: attackerSpin.stars,
                        spinPosition: attackerSpinData.spinPosition,
                        forced: this.debugger.enabled
                    },
                    defender: {
                        robot: defender.name,
                        robotId: defender.id,
                        move: defenderSpin.moveName,
                        moveType: defenderSpin.moveType,
                        damage: defenderSpin.damage,
                        stars: defenderSpin.stars,
                        spinPosition: defenderSpinData.spinPosition,
                        forced: this.debugger.enabled
                    }
                });
                
                // ==========================================
                // NOTE: Psycho Cut bonus spins happen AFTER initial wheel animations
                // This is handled further down in the code flow
                // ==========================================
                
                // APPLY STATUS EFFECTS to battle spins
                // Use instance IDs (e.g., "unit-002-c-0") not database IDs (e.g., "unit-002")
                const attackerRobotId = this.currentBattle.attackerRobotInstanceId;
                const defenderRobotId = this.currentBattle.defenderRobotInstanceId;
                
                console.log(`🔍 Using instance IDs for status effects: attacker=${attackerRobotId}, defender=${defenderRobotId}`);
                
                attackerSpin = this.applyStatusEffectsToBattleSpin(attackerRobotId, attackerSpin, 'attacker', defenderRobotId);
                defenderSpin = this.applyStatusEffectsToBattleSpin(defenderRobotId, defenderSpin, 'defender', attackerRobotId);
                
                console.log(`\n📊 FINAL BATTLE SPINS (after status effects):`);
                console.log(`  Attacker (${attacker.name}): ${attackerSpin.moveName} - ${attackerSpin.damage || 0} damage`);
                console.log(`  Defender (${defender.name}): ${defenderSpin.moveName} - ${defenderSpin.damage || 0} damage`);
                
                // Build wheel visuals with actual wheel data
                this.buildWheelVisual('attackerWheelSegments', attacker.wheel);
                this.buildWheelVisual('defenderWheelSegments', defender.wheel);
                
                // Build wheel legends
                this.buildWheelLegend('attackerWheelLegend', attacker.wheel);
                this.buildWheelLegend('defenderWheelLegend', defender.wheel);
                
                // Calculate exact rotation angles to land on the correct segment
                const attackerRotation = this.calculateWheelRotation(attacker.wheel, attackerSpinData.spinPosition);
                const defenderRotation = this.calculateWheelRotation(defender.wheel, defenderSpinData.spinPosition);
                
                console.log(`🎯 Attacker wheel will rotate to: ${attackerRotation}deg`);
                console.log(`🎯 Defender wheel will rotate to: ${defenderRotation}deg`);
                
                // Start spinning animation with EXACT target rotation
                const attackerWheel = document.getElementById('attackerWheelSegments');
                const defenderWheel = document.getElementById('defenderWheelSegments');
                
                attackerWheel.style.animation = 'none';
                defenderWheel.style.animation = 'none';
                
                // Trigger reflow
                void attackerWheel.offsetWidth;
                void defenderWheel.offsetWidth;
                
                // Apply exact rotation using inline styles
                attackerWheel.style.transition = 'transform 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                defenderWheel.style.transition = 'transform 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                
                attackerWheel.style.transform = `rotate(${attackerRotation}deg)`;
                defenderWheel.style.transform = `rotate(${defenderRotation}deg)`;
                
                // Wait for spin animation
                await this.delay(2000);
                
                // Show move names over the wheels (they'll stay until results screen)
                this.showMoveFlash('attackerWheelContainer', attackerSpin.moveName, attackerSpin.moveType);
                this.showMoveFlash('defenderWheelContainer', defenderSpin.moveName, defenderSpin.moveType);
                
                // Wait for overlay animation to complete
                await this.delay(400);
                
                // ==========================================
                // PSYCHO CUT BONUS SPIN MECHANIC
                // ==========================================
                // "Spin again - if Psycho Cut is spun, it deals +50 damage"
                // Execute AFTER initial wheel animations complete
                
                // Check if attacker spun Psycho Cut
                if (attackerSpin.moveName === 'Psycho Cut') {
                    console.log(`\n🌀 ═══════════════════════════════════════`);
                    console.log(`🌀 PSYCHO CUT TRIGGERED: ${attacker.name}`);
                    console.log(`🌀 Executing bonus spin mechanic...`);
                    console.log(`🌀 ═══════════════════════════════════════\n`);
                    
                    // Get team info from currentBattle
                    const attackerTeamForLog = this.currentBattle.attackerTeam;
                    
                    // Show "BONUS SPIN!" flash over attacker wheel
                    this.removeMoveFlashes(); // Clear previous flashes
                    this.showMoveFlash('attackerWheelContainer', '🌀 BONUS SPIN!', 'Special');
                    await this.delay(800); // Let player see the announcement
                    
                    // Execute bonus spin
                    let bonusSpinData;
                    if (this.debugger.enabled) {
                        console.log(`🛠️ DEBUGGER MODE: Check for forced bonus spin`);
                        // In debugger mode, we need a way to force the bonus spin
                        // For now, let it spin randomly - could add UI control later
                        bonusSpinData = this.spinWheelWithPosition(attacker.wheel);
                        console.log(`🛠️ Bonus spin (random): ${bonusSpinData.segment.moveName}`);
                    } else {
                        bonusSpinData = this.spinWheelWithPosition(attacker.wheel);
                    }
                    
                    const bonusSpin = bonusSpinData.segment;
                    console.log(`🎲 BONUS ROLL: ${attacker.name} spun ${bonusSpin.moveName} (${bonusSpin.moveType}) at position ${bonusSpinData.spinPosition}`);
                    
                    // Calculate rotation for bonus spin (add more rotations for visual effect)
                    const bonusRotation = this.calculateWheelRotation(attacker.wheel, bonusSpinData.spinPosition) + 1440; // Extra 4 spins
                    console.log(`🎯 Bonus spin - attacker wheel will rotate to: ${bonusRotation}deg`);
                    
                    // Animate bonus spin
                    const attackerWheel = document.getElementById('attackerWheelSegments');
                    this.removeMoveFlashes(); // Clear bonus spin announcement
                    
                    attackerWheel.style.transition = 'none'; // Reset
                    void attackerWheel.offsetWidth; // Force reflow
                    attackerWheel.style.transition = 'transform 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    attackerWheel.style.transform = `rotate(${bonusRotation}deg)`;
                    
                    await this.delay(2000); // Wait for bonus spin animation
                    
                    // Check result and apply bonus
                    if (bonusSpin.moveName === 'Psycho Cut') {
                        // JACKPOT! Double Psycho Cut = +50 damage bonus
                        console.log(`✨ JACKPOT! Bonus spin landed on Psycho Cut again!`);
                        console.log(`💥 Applying +50 damage bonus (70 → 120)`);
                        
                        // Modify the original spin object's damage
                        attackerSpin.damage = 120; // 70 base + 50 bonus
                        
                        // Show "+50 DAMAGE!" flash
                        this.showMoveFlash('attackerWheelContainer', '⚡ +50 DAMAGE!', 'Boost');
                        await this.delay(1200); // Let player see the bonus
                        
                        // Log to history
                        this.addToHistory(`${attacker.name}'s Psycho Cut hits TWICE! +50 damage bonus!`, 'battle', attackerTeamForLog);
                        
                        // Developer log
                        this.addDeveloperLog('PSYCHO_CUT_BONUS', {
                            robot: attacker.name,
                            result: 'SUCCESS',
                            bonusSpin: bonusSpin.moveName,
                            finalDamage: 120,
                            message: 'Bonus roll landed on Psycho Cut - damage increased from 70 to 120'
                        });
                    } else {
                        // Bonus spin failed - use original Psycho Cut
                        console.log(`❌ Bonus spin was ${bonusSpin.moveName}, not Psycho Cut`);
                        console.log(`✅ Using original Psycho Cut (70 damage)`);
                        
                        // Show original move flash
                        this.showMoveFlash('attackerWheelContainer', attackerSpin.moveName, attackerSpin.moveType);
                        await this.delay(800);
                        
                        // Log to history
                        this.addToHistory(`${attacker.name}'s bonus spin: ${bonusSpin.moveName}. Using original Psycho Cut.`, 'battle', attackerTeamForLog);
                        
                        // Developer log
                        this.addDeveloperLog('PSYCHO_CUT_BONUS', {
                            robot: attacker.name,
                            result: 'FAILED',
                            bonusSpin: bonusSpin.moveName,
                            finalDamage: 70,
                            message: 'Bonus roll did not land on Psycho Cut - using base damage'
                        });
                    }
                    
                    console.log(`🌀 Psycho Cut bonus spin complete for ${attacker.name}\n`);
                }
                
                // Check if defender spun Psycho Cut
                if (defenderSpin.moveName === 'Psycho Cut') {
                    console.log(`\n🌀 ═══════════════════════════════════════`);
                    console.log(`🌀 PSYCHO CUT TRIGGERED: ${defender.name}`);
                    console.log(`🌀 Executing bonus spin mechanic...`);
                    console.log(`🌀 ═══════════════════════════════════════\n`);
                    
                    // Get team info from currentBattle
                    const defenderTeamForLog = this.currentBattle.defenderTeam;
                    
                    // Show "BONUS SPIN!" flash over defender wheel
                    this.removeMoveFlashes(); // Clear previous flashes
                    this.showMoveFlash('defenderWheelContainer', '🌀 BONUS SPIN!', 'Special');
                    await this.delay(800); // Let player see the announcement
                    
                    // Execute bonus spin
                    let bonusSpinData;
                    if (this.debugger.enabled) {
                        console.log(`🛠️ DEBUGGER MODE: Check for forced bonus spin`);
                        // In debugger mode, we need a way to force the bonus spin
                        // For now, let it spin randomly - could add UI control later
                        bonusSpinData = this.spinWheelWithPosition(defender.wheel);
                        console.log(`🛠️ Bonus spin (random): ${bonusSpinData.segment.moveName}`);
                    } else {
                        bonusSpinData = this.spinWheelWithPosition(defender.wheel);
                    }
                    
                    const bonusSpin = bonusSpinData.segment;
                    console.log(`🎲 BONUS ROLL: ${defender.name} spun ${bonusSpin.moveName} (${bonusSpin.moveType}) at position ${bonusSpinData.spinPosition}`);
                    
                    // Calculate rotation for bonus spin (add more rotations for visual effect)
                    const bonusRotation = this.calculateWheelRotation(defender.wheel, bonusSpinData.spinPosition) + 1440; // Extra 4 spins
                    console.log(`🎯 Bonus spin - defender wheel will rotate to: ${bonusRotation}deg`);
                    
                    // Animate bonus spin
                    const defenderWheel = document.getElementById('defenderWheelSegments');
                    this.removeMoveFlashes(); // Clear bonus spin announcement
                    
                    defenderWheel.style.transition = 'none'; // Reset
                    void defenderWheel.offsetWidth; // Force reflow
                    defenderWheel.style.transition = 'transform 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    defenderWheel.style.transform = `rotate(${bonusRotation}deg)`;
                    
                    await this.delay(2000); // Wait for bonus spin animation
                    
                    // Check result and apply bonus
                    if (bonusSpin.moveName === 'Psycho Cut') {
                        // JACKPOT! Double Psycho Cut = +50 damage bonus
                        console.log(`✨ JACKPOT! Bonus spin landed on Psycho Cut again!`);
                        console.log(`💥 Applying +50 damage bonus (70 → 120)`);
                        
                        // Modify the original spin object's damage
                        defenderSpin.damage = 120; // 70 base + 50 bonus
                        
                        // Show "+50 DAMAGE!" flash
                        this.showMoveFlash('defenderWheelContainer', '⚡ +50 DAMAGE!', 'Boost');
                        await this.delay(1200); // Let player see the bonus
                        
                        // Log to history
                        this.addToHistory(`${defender.name}'s Psycho Cut hits TWICE! +50 damage bonus!`, 'battle', defenderTeamForLog);
                        
                        // Developer log
                        this.addDeveloperLog('PSYCHO_CUT_BONUS', {
                            robot: defender.name,
                            result: 'SUCCESS',
                            bonusSpin: bonusSpin.moveName,
                            finalDamage: 120,
                            message: 'Bonus roll landed on Psycho Cut - damage increased from 70 to 120'
                        });
                    } else {
                        // Bonus spin failed - use original Psycho Cut
                        console.log(`❌ Bonus spin was ${bonusSpin.moveName}, not Psycho Cut`);
                        console.log(`✅ Using original Psycho Cut (70 damage)`);
                        
                        // Show original move flash
                        this.showMoveFlash('defenderWheelContainer', defenderSpin.moveName, defenderSpin.moveType);
                        await this.delay(800);
                        
                        // Log to history
                        this.addToHistory(`${defender.name}'s bonus spin: ${bonusSpin.moveName}. Using original Psycho Cut.`, 'battle', defenderTeamForLog);
                        
                        // Developer log
                        this.addDeveloperLog('PSYCHO_CUT_BONUS', {
                            robot: defender.name,
                            result: 'FAILED',
                            bonusSpin: bonusSpin.moveName,
                            finalDamage: 70,
                            message: 'Bonus roll did not land on Psycho Cut - using base damage'
                        });
                    }
                    
                    console.log(`🌀 Psycho Cut bonus spin complete for ${defender.name}\n`);
                }
                
                // Clear all flashes before continuing to normal flow
                this.removeMoveFlashes();
                
                // Reveal results with color-coded text
                const attackerResult = document.getElementById('attackerWheelResult');
                const defenderResult = document.getElementById('defenderWheelResult');
                
                const attackerColor = this.getMoveColor(attackerSpin.moveType);
                const defenderColor = this.getMoveColor(defenderSpin.moveType);
                
                // Format move name with pip identifier if present
                const attackerMoveName = attackerSpin.pipCount > 0 
                    ? `${attackerSpin.moveName} (${'•'.repeat(attackerSpin.pipCount)})`
                    : attackerSpin.moveName;
                const defenderMoveName = defenderSpin.pipCount > 0 
                    ? `${defenderSpin.moveName} (${'•'.repeat(defenderSpin.pipCount)})`
                    : defenderSpin.moveName;
                
                // Update attacker result
                attackerResult.querySelector('.move-name').textContent = attackerMoveName;
                attackerResult.querySelector('.move-power').textContent = this.getMovePowerDisplay(attackerSpin);
                attackerResult.style.color = attackerColor;
                attackerResult.classList.add('revealed');
                
                // Update defender result
                defenderResult.querySelector('.move-name').textContent = defenderMoveName;
                defenderResult.querySelector('.move-power').textContent = this.getMovePowerDisplay(defenderSpin);
                defenderResult.style.color = defenderColor;
                defenderResult.classList.add('revealed');
                
                // Log spins to battle history
                const attackerTeam = this.currentBattle.attackerTeam;
                const defenderTeam = this.currentBattle.defenderTeam;
                this.addToHistory(`${attacker.name} spun: ${attackerSpin.moveName} (${attackerSpin.moveType})`, 'battle', attackerTeam);
                this.addToHistory(`${defender.name} spun: ${defenderSpin.moveName} (${defenderSpin.moveType})`, 'battle', defenderTeam);
                
                // Wait a moment to show results
                await this.delay(1500);
                
                // Determine winner based on move priority
                const winner = this.determineBattleWinner(attackerSpin, defenderSpin);
                
                // Developer Log: Battle Outcome
                this.addDeveloperLog('BATTLE_OUTCOME', {
                    winner: winner,
                    attacker: {
                        robot: attacker.name,
                        move: attackerSpin.moveName,
                        moveType: attackerSpin.moveType,
                        power: attackerSpin.damage || attackerSpin.stars
                    },
                    defender: {
                        robot: defender.name,
                        move: defenderSpin.moveName,
                        moveType: defenderSpin.moveType,
                        power: defenderSpin.damage || defenderSpin.stars
                    },
                    battleLogic: this.getBattleLogicExplanation(attackerSpin, defenderSpin, winner)
                });
                
                return {
                    winner: winner, // 'attacker', 'defender', or 'draw'
                    attackerMove: attackerSpin,
                    defenderMove: defenderSpin,
                    attacker: attacker,
                    defender: defender
                };
            },
            
            // Simulate Data Disk battle (simplified version - no animation)
            async simulateDataDiskBattle(attacker, defender) {
                // Spin both wheels
                let attackerSpin = this.spinWheel(attacker.wheel);
                let defenderSpin = this.spinWheel(defender.wheel);
                
                console.log(`🎲 ${attacker.name} spun: ${attackerSpin.moveName} (${attackerSpin.moveType})`);
                console.log(`🎲 ${defender.name} spun: ${defenderSpin.moveName} (${defenderSpin.moveType})`);
                
                // APPLY STATUS EFFECTS to battle spins
                // Use instance IDs (e.g., "unit-002-c-0") not database IDs (e.g., "unit-002")
                const attackerRobotId = this.currentBattle.attackerRobotInstanceId;
                const defenderRobotId = this.currentBattle.defenderRobotInstanceId;
                
                console.log(`🔍 Using instance IDs for status effects: attacker=${attackerRobotId}, defender=${defenderRobotId}`);
                
                attackerSpin = this.applyStatusEffectsToBattleSpin(attackerRobotId, attackerSpin, 'attacker', defenderRobotId);
                defenderSpin = this.applyStatusEffectsToBattleSpin(defenderRobotId, defenderSpin, 'defender', attackerRobotId);
                
                console.log(`\n📊 FINAL BATTLE SPINS (after status effects):`);
                console.log(`  Attacker (${attacker.name}): ${attackerSpin.moveName} - ${attackerSpin.damage || 0} damage`);
                console.log(`  Defender (${defender.name}): ${defenderSpin.moveName} - ${defenderSpin.damage || 0} damage`);
                
                // Log spins to battle history
                const attackerTeam = this.currentBattle.attackerTeam;
                const defenderTeam = this.currentBattle.defenderTeam;
                this.addToHistory(`${attacker.name} spun: ${attackerSpin.moveName} (${attackerSpin.moveType})`, 'battle', attackerTeam);
                this.addToHistory(`${defender.name} spun: ${defenderSpin.moveName} (${defenderSpin.moveType})`, 'battle', defenderTeam);
                
                // Developer Log: Spin Results (Simulated Battle)
                this.addDeveloperLog('SPIN_RESULT', {
                    battleType: 'simulated',
                    attacker: {
                        robot: attacker.name,
                        robotId: attacker.id,
                        move: attackerSpin.moveName,
                        moveType: attackerSpin.moveType,
                        damage: attackerSpin.damage,
                        stars: attackerSpin.stars
                    },
                    defender: {
                        robot: defender.name,
                        robotId: defender.id,
                        move: defenderSpin.moveName,
                        moveType: defenderSpin.moveType,
                        damage: defenderSpin.damage,
                        stars: defenderSpin.stars
                    }
                });
                
                // Determine winner based on move priority
                const winner = this.determineBattleWinner(attackerSpin, defenderSpin);
                
                // Developer Log: Battle Outcome (Simulated Battle)
                this.addDeveloperLog('BATTLE_OUTCOME', {
                    battleType: 'simulated',
                    winner: winner,
                    attacker: {
                        robot: attacker.name,
                        move: attackerSpin.moveName,
                        moveType: attackerSpin.moveType,
                        power: attackerSpin.damage || attackerSpin.stars
                    },
                    defender: {
                        robot: defender.name,
                        move: defenderSpin.moveName,
                        moveType: defenderSpin.moveType,
                        power: defenderSpin.damage || defenderSpin.stars
                    },
                    battleLogic: this.getBattleLogicExplanation(attackerSpin, defenderSpin, winner)
                });
                
                return {
                    winner: winner, // 'attacker', 'defender', or 'draw'
                    attackerMove: attackerSpin,
                    defenderMove: defenderSpin,
                    attacker: attacker,
                    defender: defender
                };
            },
            
            // Assign pip identifiers to duplicate colored moves
            assignPipIdentifiers(wheelData) {
                const colorCounts = {};
                const colorIndices = {};
                
                // First pass: count how many times each color appears
                wheelData.forEach(segment => {
                    const colorKey = segment.moveType.toLowerCase();
                    colorCounts[colorKey] = (colorCounts[colorKey] || 0) + 1;
                });
                
                // Second pass: assign pip counts only to colors that appear multiple times
                return wheelData.map(segment => {
                    const colorKey = segment.moveType.toLowerCase();
                    
                    if (colorCounts[colorKey] > 1) {
                        // This color appears multiple times - assign pip identifier
                        colorIndices[colorKey] = (colorIndices[colorKey] || 0) + 1;
                        return {
                            ...segment,
                            pipCount: colorIndices[colorKey]
                        };
                    } else {
                        // This color is unique - no pip needed
                        return {
                            ...segment,
                            pipCount: 0
                        };
                    }
                });
            },
            
            // Build visual wheel with actual segments
            buildWheelVisual(elementId, wheelData) {
                const wheelElement = document.getElementById(elementId);
                if (!wheelElement) return;
                
                // Clear any existing pip overlays from previous battles
                const existingPips = wheelElement.querySelectorAll('.wheel-pip-container');
                existingPips.forEach(pip => pip.remove());
                
                // Clear any existing star overlays from previous battles
                const existingStars = wheelElement.querySelectorAll('.wheel-star-container');
                existingStars.forEach(star => star.remove());
                
                // Assign pip identifiers
                const wheelDataWithPips = this.assignPipIdentifiers(wheelData);
                
                // Store pip data for later use
                wheelElement.dataset.pipData = JSON.stringify(wheelDataWithPips);
                
                // Create conic gradient based on actual wheel segments
                let gradientSegments = [];
                let currentAngle = 0;
                
                wheelDataWithPips.forEach((segment, index) => {
                    const segmentAngle = (segment.size / 96) * 360;
                    const color = this.getMoveColorHex(segment.moveType);
                    
                    // Check if next segment has same color (for separator line)
                    const nextSegment = wheelDataWithPips[(index + 1) % wheelDataWithPips.length];
                    const nextColor = nextSegment ? this.getMoveColorHex(nextSegment.moveType) : null;
                    const needsSeparator = (nextColor === color);
                    
                    // Debug logging for separator detection
                    if (needsSeparator) {
                        console.log(`🔲 SEPARATOR NEEDED: ${segment.moveName} (${segment.moveType}) → ${nextSegment.moveName} (${nextSegment.moveType})`);
                        console.log(`   Color: ${color}, Angle: ${currentAngle}° to ${currentAngle + segmentAngle}°`);
                    }
                    
                    if (needsSeparator) {
                        // Add visible black separator line (3deg) between same-color segments
                        const lineWidth = 3; // degrees - highly visible separator
                        gradientSegments.push(`${color} ${currentAngle}deg ${currentAngle + segmentAngle - lineWidth}deg`);
                        gradientSegments.push(`#222222 ${currentAngle + segmentAngle - lineWidth}deg ${currentAngle + segmentAngle}deg`);
                        console.log(`   ✅ Added separator: ${color} ends at ${currentAngle + segmentAngle - lineWidth}°, black line ${currentAngle + segmentAngle - lineWidth}° to ${currentAngle + segmentAngle}°`);
                    } else {
                        // Normal segment without separator
                        gradientSegments.push(`${color} ${currentAngle}deg ${currentAngle + segmentAngle}deg`);
                    }
                    
                    // Add pip overlay if this segment has a pip identifier
                    if (segment.pipCount > 0) {
                        this.addPipOverlay(wheelElement, currentAngle, segmentAngle, segment.pipCount);
                    }
                    
                    // Add star overlay if this segment has stars
                    if (segment.stars !== undefined && segment.stars !== null) {
                        this.addStarOverlay(wheelElement, currentAngle, segmentAngle, segment.stars);
                    }
                    
                    currentAngle += segmentAngle;
                });
                
                const gradientString = `conic-gradient(${gradientSegments.join(', ')})`;
                console.log(`🎨 Final gradient (${gradientSegments.length} segments):`, gradientString.substring(0, 200) + '...');
                wheelElement.style.background = gradientString;
            },
            
            // Add pip overlay to wheel segment
            addPipOverlay(wheelElement, startAngle, segmentAngle, pipCount) {
                const centerAngle = startAngle + (segmentAngle / 2);
                const radius = 45; // Distance from center (wheel radius is ~80px, place at ~55% radius)
                
                // Create pip container (full wheel overlay)
                const pipContainer = document.createElement('div');
                pipContainer.className = 'wheel-pip-container';
                
                // Calculate angular spacing for multiple pips (spread them along an arc)
                const pipSpreadAngle = pipCount > 1 ? Math.min(8, segmentAngle * 0.4) : 0; // Max 8 degrees spread
                const startSpread = centerAngle - (pipSpreadAngle * (pipCount - 1) / 2);
                
                // Add pips in an arc formation
                for (let i = 0; i < pipCount; i++) {
                    const pipAngle = pipCount > 1 ? startSpread + (i * pipSpreadAngle / (pipCount - 1)) : centerAngle;
                    const radians = (pipAngle - 90) * (Math.PI / 180); // -90 to align with top
                    const x = 50 + (radius * Math.cos(radians)); // 50% = center
                    const y = 50 + (radius * Math.sin(radians));
                    
                    const pip = document.createElement('div');
                    pip.className = 'wheel-pip';
                    pip.style.left = `${x}%`;
                    pip.style.top = `${y}%`;
                    pip.style.transform = 'translate(-50%, -50%)';
                    pipContainer.appendChild(pip);
                }
                
                // Append to wheel element so pips rotate WITH the wheel
                wheelElement.appendChild(pipContainer);
            },
            
            // Add star overlay to wheel segment
            addStarOverlay(wheelElement, startAngle, segmentAngle, starCount) {
                const centerAngle = startAngle + (segmentAngle / 2);
                const radius = 35; // Closer to center than pips
                
                // Create star container
                const starContainer = document.createElement('div');
                starContainer.className = 'wheel-star-container';
                
                // Calculate angular spacing for multiple stars (spread them along an arc)
                const starSpreadAngle = starCount > 1 ? Math.min(20, segmentAngle * 0.7) : 0; // Max 20 degrees spread
                const startSpread = centerAngle - (starSpreadAngle * (starCount - 1) / 2);
                
                // Dynamic font size based on star count (more stars = smaller size)
                let fontSize;
                if (starCount === 1) {
                    fontSize = 12; // Normal size for single star
                } else if (starCount === 2) {
                    fontSize = 9; // Smaller for 2 stars
                } else if (starCount === 3) {
                    fontSize = 7; // Even smaller for 3 stars
                } else {
                    fontSize = 6; // Smallest for 4+ stars
                }
                
                // Add stars in an arc formation
                for (let i = 0; i < starCount; i++) {
                    const starAngle = starCount > 1 ? startSpread + (i * starSpreadAngle / (starCount - 1)) : centerAngle;
                    const radians = (starAngle - 90) * (Math.PI / 180); // -90 to align with top
                    const x = 50 + (radius * Math.cos(radians)); // 50% = center
                    const y = 50 + (radius * Math.sin(radians));
                    
                    const starDisplay = document.createElement('div');
                    starDisplay.className = 'wheel-star-display';
                    starDisplay.style.left = `${x}%`;
                    starDisplay.style.top = `${y}%`;
                    starDisplay.style.fontSize = `${fontSize}px`; // Apply dynamic size
                    starDisplay.style.transform = 'translate(-50%, -50%)';
                    starDisplay.textContent = '⭐'; // Single star emoji
                    
                    starContainer.appendChild(starDisplay);
                }
                
                // Append to wheel element so stars rotate WITH the wheel
                wheelElement.appendChild(starContainer);
            },
            
            // Build wheel legend showing all possible outcomes
            buildWheelLegend(legendId, wheelData) {
                const legendElement = document.getElementById(legendId);
                if (!legendElement) return;
                
                // Clear existing legend
                legendElement.innerHTML = '';
                
                // Assign pip identifiers to duplicate colors
                const wheelDataWithPips = this.assignPipIdentifiers(wheelData);
                
                // Group segments by move name AND pip count to show duplicates separately
                const moveMap = new Map();
                wheelDataWithPips.forEach(segment => {
                    const uniqueKey = `${segment.moveName}_${segment.pipCount}`;
                    
                    if (!moveMap.has(uniqueKey)) {
                        moveMap.set(uniqueKey, {
                            moveName: segment.moveName,
                            moveType: segment.moveType,
                            damage: segment.damage,
                            stars: segment.stars,
                            pipCount: segment.pipCount,
                            totalSize: segment.size
                        });
                    } else {
                        const existing = moveMap.get(uniqueKey);
                        existing.totalSize += segment.size;
                    }
                });
                
                // Create legend items sorted by size (most likely first)
                const sortedMoves = Array.from(moveMap.values()).sort((a, b) => b.totalSize - a.totalSize);
                
                sortedMoves.forEach(move => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = this.getMoveColorHex(move.moveType);
                    
                    const textSpan = document.createElement('span');
                    textSpan.className = 'legend-text';
                    
                    // Format text with pip identifier if present
                    let displayText = move.moveName;
                    if (move.pipCount > 0) {
                        const pips = '•'.repeat(move.pipCount);
                        displayText += ` (${pips})`;
                    }
                    if (move.damage !== undefined && move.damage !== null && move.damage > 0) {
                        displayText += ` - ⚔️ ${move.damage}`;
                    } else if (move.stars !== undefined && move.stars !== null) {
                        displayText += ` - ⭐ ${move.stars}`;
                    } else if (move.moveType.toLowerCase() === 'blue') {
                        displayText += ` - Defensive`;
                    } else if (move.moveType.toLowerCase() === 'red') {
                        displayText += ` - Miss`;
                    }
                    textSpan.textContent = displayText;
                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(textSpan);
                    legendElement.appendChild(legendItem);
                });
            },
            
            // Build detailed battle moves list (similar to Combat Dial)
            buildBattleMovesList(listId, wheelData, robotId = null) {
                const listElement = document.getElementById(listId);
                if (!listElement) return;
                
                // Get status effects if robotId provided
                const statuses = robotId ? this.getRobotStatuses(robotId) : { conditions: [], markers: [] };
                
                // Clear existing list
                listElement.innerHTML = '';
                
                // Assign pip identifiers to handle duplicate colors
                const wheelDataWithPips = this.assignPipIdentifiers(wheelData);
                
                // Sort wheel data: Miss moves at bottom, others by size (most common first)
                const sortedWheel = [...wheelDataWithPips].sort((a, b) => {
                    const aIsMiss = a.moveName.toLowerCase().includes('miss');
                    const bIsMiss = b.moveName.toLowerCase().includes('miss');
                    
                    // If one is Miss and the other isn't, Miss goes to bottom
                    if (aIsMiss && !bIsMiss) return 1;
                    if (!aIsMiss && bIsMiss) return -1;
                    
                    // Otherwise sort by size (largest first)
                    return b.size - a.size;
                });
                
                sortedWheel.forEach(move => {
                    const moveEl = document.createElement('div');
                    moveEl.className = `battle-wheel-move ${move.moveType}`;
                    
                    // Icon for move type
                    const typeIcons = {
                        'White': '⚔️',
                        'Gold': '⭐',
                        'Purple': '✨',
                        'Blue': '🛡️',
                        'Red': '❌'
                    };
                    const icon = typeIcons[move.moveType] || '•';
                    
                    // Build damage/stars display with status effect modifications
                    let statsHtml = '';
                    if (move.damage !== undefined && move.damage !== null) {
                        // Check for damage reductions from status effects (Poison, Noxious, Burn)
                        let modifiedDamage = move.damage;
                        let damageReduction = 0;
                        const moveTypeLower = move.moveType ? move.moveType.toLowerCase() : '';
                        
                        // Only apply damage reduction to White/Gold attacks
                        if (robotId && (moveTypeLower === 'white' || moveTypeLower === 'gold')) {
                            if (this.hasStatusEffect(robotId, 'poison')) {
                                damageReduction += 20;
                            }
                            if (this.hasStatusEffect(robotId, 'noxious')) {
                                damageReduction += 40;
                            }
                            if (this.hasStatusEffect(robotId, 'burn')) {
                                damageReduction += 10;
                            }
                        }
                        
                        modifiedDamage = Math.max(0, move.damage - damageReduction);
                        
                        if (damageReduction > 0) {
                            statsHtml = `<div class="battle-wheel-move-damage">
                                <span style="text-decoration: line-through; color: #999; font-size: 7px;">${move.damage}</span>
                                <span style="color: #ff6b6b; font-weight: bold;"> ${modifiedDamage}💥</span>
                            </div>`;
                        } else {
                            statsHtml = `<div class="battle-wheel-move-damage">${move.damage}💥</div>`;
                        }
                    } else if (move.stars) {
                        statsHtml = `<div class="battle-wheel-move-damage">${'⭐'.repeat(move.stars)}</div>`;
                    }
                    statsHtml += `<div class="battle-wheel-move-size">${move.size}/96</div>`;
                    
                    // Format move name with pip identifier if present
                    let displayName = move.moveName;
                    if (move.pipCount > 0) {
                        const pips = '•'.repeat(move.pipCount);
                        displayName += ` (${pips})`;
                    }
                    
                    // Show full effect text - handle "None" case for normal attacks
                    let effectText = move.effect;
                    
                    // Miss moves should have no description
                    if (move.moveName.toLowerCase().includes('miss')) {
                        effectText = '';
                    } else if (!effectText || effectText === 'None' || effectText.trim() === '') {
                        // Normal attacks without special effects
                        effectText = 'Normal attack';
                    }
                    
                    moveEl.innerHTML = `
                        <div class="battle-wheel-move-icon">${icon}</div>
                        <div class="battle-wheel-move-info">
                            <div class="battle-wheel-move-name">${displayName}</div>
                            <div class="battle-wheel-move-effect">${effectText}</div>
                        </div>
                        <div class="battle-wheel-move-stats">
                            ${statsHtml}
                        </div>
                    `;
                    
                    listElement.appendChild(moveEl);
                });
            },
            
            // Get move type color (for text)
            getMoveColor(moveType) {
                const colors = {
                    'red': '#ff4444',
                    'blue': '#4444ff',
                    'gold': '#ffaa00',
                    'purple': '#aa44ff',
                    'white': '#ffffff'
                };
                return colors[moveType.toLowerCase()] || '#ffffff';
            },
            
            // Get move type color (hex for gradients)
            getMoveColorHex(moveType) {
                const colors = {
                    'red': '#ff4444',
                    'blue': '#4444ff',
                    'gold': '#ffaa00',
                    'purple': '#aa44ff',
                    'white': '#ffffff'
                };
                return colors[moveType.toLowerCase()] || '#ffffff';
            },
            
            // Get move power display text
            getMovePowerDisplay(moveSegment) {
                // If it's a miss, show the effect or "Miss"
                if (moveSegment.moveName.toLowerCase().includes('miss')) {
                    return moveSegment.effect || 'Miss';
                }
                
                // Always show the effect if available
                if (moveSegment.effect && moveSegment.effect !== 'None') {
                    return moveSegment.effect;
                }
                
                // For attacks with power, show power value
                if (moveSegment.power && moveSegment.power > 0) {
                    return `Power: ${moveSegment.power}`;
                }
                
                // For special moves without effect, show type
                const typeLabels = {
                    'red': 'Red Attack',
                    'blue': 'Blue Defense',
                    'gold': 'Gold Attack',
                    'purple': 'Purple Special',
                    'white': 'White Attack'
                };
                return typeLabels[moveSegment.moveType.toLowerCase()] || moveSegment.moveType;
            },
            
            // Delay helper
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // Spin a robot's wheel WITH position tracking (for accurate visual)
            spinWheelWithPosition(wheel) {
                // Assign pip identifiers to duplicate colors
                const wheelWithPips = this.assignPipIdentifiers(wheel);
                
                const random = Math.floor(Math.random() * 96) + 1;
                let cumulative = 0;
                
                for (const segment of wheelWithPips) {
                    cumulative += segment.size;
                    if (random <= cumulative) {
                        return {
                            segment: segment,
                            spinPosition: random  // Exact position (1-96)
                        };
                    }
                }
                
                // Fallback (shouldn't happen)
                return {
                    segment: wheelWithPips[0],
                    spinPosition: 1
                };
            },
            
            // Force wheel to land on a specific move (for debugger)
            forceWheelPosition(wheel, moveIndex) {
                // Assign pip identifiers to duplicate colors
                const wheelWithPips = this.assignPipIdentifiers(wheel);
                
                // Get the target segment
                const targetSegment = wheelWithPips[moveIndex];
                
                // Calculate cumulative position up to this segment
                let cumulative = 0;
                for (let i = 0; i < moveIndex; i++) {
                    cumulative += wheelWithPips[i].size;
                }
                
                // Pick a random position within this segment (for visual variety)
                const segmentMidpoint = cumulative + Math.floor(targetSegment.size / 2);
                
                return {
                    segment: targetSegment,
                    spinPosition: segmentMidpoint
                };
            },
            
            // Calculate exact rotation angle to land on a specific position
            calculateWheelRotation(wheel, spinPosition) {
                // Find the segment and its position in the wheel
                let cumulative = 0;
                let segmentStartAngle = 0;
                let segmentEndAngle = 0;
                
                for (const segment of wheel) {
                    cumulative += segment.size;
                    
                    if (spinPosition <= cumulative) {
                        // This is the segment we landed on
                        segmentStartAngle = ((cumulative - segment.size) / 96) * 360;
                        segmentEndAngle = (cumulative / 96) * 360;
                        
                        // Calculate position within this segment
                        const positionInSegment = spinPosition - (cumulative - segment.size);
                        const segmentAngle = segmentEndAngle - segmentStartAngle;
                        const exactAngle = segmentStartAngle + (positionInSegment / segment.size) * segmentAngle;
                        
                        // Add multiple full rotations (4 spins = 1440deg) plus the exact angle
                        // We need to rotate COUNTER-CLOCKWISE to position, so we subtract the angle
                        // Pointer is at top (0deg), so we rotate to bring the landed position to the top
                        const finalRotation = 1440 - exactAngle;
                        
                        return finalRotation;
                    }
                }
                
                // Fallback
                return 1440;
            },
            
            // Spin a robot's wheel (simple version for non-animated battles)
            spinWheel(wheel) {
                const random = Math.floor(Math.random() * 96) + 1;
                let cumulative = 0;
                
                for (const segment of wheel) {
                    cumulative += segment.size;
                    if (random <= cumulative) {
                        return segment;
                    }
                }
                
                // Fallback (shouldn't happen)
                return wheel[0];
            },
            
            // Determine battle winner based on CORRECT COMBAT RULES from design document
            determineBattleWinner(attackerMove, defenderMove) {
                const atkType = attackerMove.moveType.toLowerCase();
                const defType = defenderMove.moveType.toLowerCase();
                
                console.log(`⚔️ Combat: ${atkType} vs ${defType}`);
                
                // Priority: Blue (5) > Gold (4) > Purple (3) > White (2) > Red (1)
                const priority = {
                    'blue': 5,
                    'gold': 4,
                    'purple': 3,
                    'white': 2,
                    'red': 1
                };
                
                const atkPriority = priority[atkType] || 0;
                const defPriority = priority[defType] || 0;
                
                // === SPECIAL DRAW CONDITIONS ===
                // Red vs Red = Draw
                if (atkType === 'red' && defType === 'red') {
                    console.log('🤝 Red vs Red = Draw');
                    return 'draw';
                }
                
                // === BLUE PROTECTION ===
                // Blue is DEFENSIVE - it protects from being knocked out but doesn't knock out opponent
                // If either side uses Blue, result is DRAW (both robots stay on board)
                if (atkType === 'blue' || defType === 'blue') {
                    console.log('🔵 Blue = Protection! Draw (no knockout)');
                    return 'draw';
                }
                
                // === GOLD BEATS PURPLE ===
                if (atkType === 'gold' && defType === 'purple') {
                    console.log('🟡 Gold beats Purple!');
                    return 'attacker';
                }
                if (defType === 'gold' && atkType === 'purple') {
                    console.log('🟡 Gold beats Purple!');
                    return 'defender';
                }
                
                // === PURPLE BEATS WHITE ===
                if (atkType === 'purple' && defType === 'white') {
                    console.log('🟣 Purple beats White!');
                    return 'attacker';
                }
                if (defType === 'purple' && atkType === 'white') {
                    console.log('🟣 Purple beats White!');
                    return 'defender';
                }
                
                // === WHITE VS WHITE - COMPARE DAMAGE ===
                if (atkType === 'white' && defType === 'white') {
                    const atkDamage = attackerMove.damage || 0;
                    const defDamage = defenderMove.damage || 0;
                    console.log(`⚪ White vs White: ${atkDamage} vs ${defDamage} (AFTER status effects)`);
                    if (atkDamage > defDamage) {
                        console.log(`✅ Attacker wins: ${atkDamage} > ${defDamage}`);
                        return 'attacker';
                    }
                    if (defDamage > atkDamage) {
                        console.log(`✅ Defender wins: ${defDamage} > ${atkDamage}`);
                        return 'defender';
                    }
                    console.log(`🤝 Draw: ${atkDamage} = ${defDamage}`);
                    return 'draw';
                }
                
                // === GOLD VS GOLD - COMPARE DAMAGE ===
                if (atkType === 'gold' && defType === 'gold') {
                    const atkDamage = attackerMove.damage || 0;
                    const defDamage = defenderMove.damage || 0;
                    console.log(`🟡 Gold vs Gold: ${atkDamage} vs ${defDamage} (AFTER status effects)`);
                    if (atkDamage > defDamage) {
                        console.log(`✅ Attacker wins: ${atkDamage} > ${defDamage}`);
                        return 'attacker';
                    }
                    if (defDamage > atkDamage) {
                        console.log(`✅ Defender wins: ${defDamage} > ${atkDamage}`);
                        return 'defender';
                    }
                    console.log(`🤝 Draw: ${atkDamage} = ${defDamage}`);
                    return 'draw';
                }
                
                // === WHITE VS GOLD - COMPARE DAMAGE ===
                if ((atkType === 'white' && defType === 'gold') || (atkType === 'gold' && defType === 'white')) {
                    const atkDamage = attackerMove.damage || 0;
                    const defDamage = defenderMove.damage || 0;
                    console.log(`⚪🟡 White vs Gold: ${atkDamage} vs ${defDamage} (AFTER status effects)`);
                    if (atkDamage > defDamage) {
                        console.log(`✅ Attacker wins: ${atkDamage} > ${defDamage}`);
                        return 'attacker';
                    }
                    if (defDamage > atkDamage) {
                        console.log(`✅ Defender wins: ${defDamage} > ${atkDamage}`);
                        return 'defender';
                    }
                    console.log(`🤝 Draw: ${atkDamage} = ${defDamage}`);
                    return 'draw';
                }
                
                // === PURPLE VS PURPLE - COMPARE STAR RATING ===
                if (atkType === 'purple' && defType === 'purple') {
                    const atkStars = attackerMove.stars || 0;
                    const defStars = defenderMove.stars || 0;
                    console.log(`🟣 Purple vs Purple: ${atkStars}⭐ vs ${defStars}⭐`);
                    if (atkStars > defStars) return 'attacker';
                    if (defStars > atkStars) return 'defender';
                    return 'draw';
                }
                
                // === DEFAULT PRIORITY COMPARISON ===
                if (atkPriority > defPriority) {
                    console.log(`✅ Attacker wins by priority (${atkPriority} > ${defPriority})`);
                    return 'attacker';
                }
                if (defPriority > atkPriority) {
                    console.log(`✅ Defender wins by priority (${defPriority} > ${atkPriority})`);
                    return 'defender';
                }
                
                console.log('🤝 Draw by default');
                return 'draw';
            },
            
            // Get battle logic explanation for developer log
            getBattleLogicExplanation(attackerMove, defenderMove, winner) {
                const atkType = attackerMove.moveType.toLowerCase();
                const defType = defenderMove.moveType.toLowerCase();
                
                // Red vs Red
                if (atkType === 'red' && defType === 'red') {
                    return 'Red vs Red = Draw (both miss)';
                }
                
                // Blue protection
                if (atkType === 'blue' || defType === 'blue') {
                    return 'Blue protection active = Draw (no knockout)';
                }
                
                // Gold beats Purple
                if ((atkType === 'gold' && defType === 'purple') || (defType === 'gold' && atkType === 'purple')) {
                    return 'Gold beats Purple (special rule)';
                }
                
                // Purple beats White
                if ((atkType === 'purple' && defType === 'white') || (defType === 'purple' && atkType === 'white')) {
                    return 'Purple beats White (special rule)';
                }
                
                // White vs White
                if (atkType === 'white' && defType === 'white') {
                    const atkDmg = attackerMove.damage || 0;
                    const defDmg = defenderMove.damage || 0;
                    return `White vs White: Compare damage (${atkDmg} vs ${defDmg})`;
                }
                
                // Gold vs Gold
                if (atkType === 'gold' && defType === 'gold') {
                    const atkDmg = attackerMove.damage || 0;
                    const defDmg = defenderMove.damage || 0;
                    return `Gold vs Gold: Compare damage (${atkDmg} vs ${defDmg})`;
                }
                
                // White vs Gold
                if ((atkType === 'white' && defType === 'gold') || (atkType === 'gold' && defType === 'white')) {
                    const atkDmg = attackerMove.damage || 0;
                    const defDmg = defenderMove.damage || 0;
                    return `White vs Gold: Compare damage (${atkDmg} vs ${defDmg})`;
                }
                
                // Purple vs Purple
                if (atkType === 'purple' && defType === 'purple') {
                    const atkStars = attackerMove.stars || 0;
                    const defStars = defenderMove.stars || 0;
                    return `Purple vs Purple: Compare stars (${atkStars}⭐ vs ${defStars}⭐)`;
                }
                
                // Priority comparison
                const priority = { 'blue': 5, 'gold': 4, 'purple': 3, 'white': 2, 'red': 1 };
                const atkPri = priority[atkType] || 0;
                const defPri = priority[defType] || 0;
                return `Priority comparison: ${atkType}(${atkPri}) vs ${defType}(${defPri})`;
            },
            
            // Display floating move name overlay over a wheel
            showMoveFlash(wheelContainerId, moveName, moveType) {
                const wheelContainer = document.getElementById(wheelContainerId);
                if (!wheelContainer) return;
                
                // Get the spinning wheel element
                const spinningWheel = wheelContainer.querySelector('.spinning-wheel');
                if (!spinningWheel) return;
                
                // Get move color
                const moveColor = this.getMoveTypeColor(moveType);
                
                // Create overlay element
                const overlay = document.createElement('div');
                overlay.className = 'move-flash-overlay';
                overlay.dataset.wheelContainer = wheelContainerId;
                
                const textElement = document.createElement('div');
                textElement.className = 'move-flash-text';
                textElement.textContent = moveName;
                textElement.style.color = moveColor;
                textElement.style.borderColor = moveColor;
                
                overlay.appendChild(textElement);
                spinningWheel.appendChild(overlay);
                
                // Store reference for later removal
                return overlay;
            },
            
            // Remove move name overlays
            removeMoveFlashes() {
                const overlays = document.querySelectorAll('.move-flash-overlay');
                overlays.forEach(overlay => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                });
            },
            
            // ==========================================
            // SPECIAL EFFECT MOVES SYSTEM
            // ==========================================
            
            // Check if a move has a special effect
            hasSpecialEffect(result) {
                const winningMove = result.winner === 'attacker' ? result.attackerMove : result.defenderMove;
                if (!winningMove) return false;
                
                const moveName = winningMove.moveName;
                
                // List of moves with special effects
                const specialEffectMoves = [
                    'Psychic Shove',
                    'Annihilate',
                    // Add more special effect moves here as needed
                ];
                
                return specialEffectMoves.includes(moveName);
            },
            
            // Handle special effect moves
            async handleSpecialEffect(move, winnerPointId, loserPointId, result) {
                const moveName = move.moveName;
                
                console.log(`🌟 Handling special effect: ${moveName}`);
                
                switch (moveName) {
                    case 'Psychic Shove':
                        await this.handlePsychicShove(winnerPointId, loserPointId, result);
                        break;
                    case 'Annihilate':
                        await this.handleAnnihilate(winnerPointId, loserPointId, result);
                        break;
                    default:
                        console.warn(`⚠️ Unknown special effect: ${moveName}`);
                }
            },
            
            // Handle Psychic Shove: Knock opponent back in straight line, chain knockback, apply Wait
            // NOTE: Parameters are already winner/loser (not attacker/defender)
            async handlePsychicShove(winnerPointId, loserPointId, result) {
                // Get loser's name for logging
                const loserName = result.winner === 'attacker' ? result.defender.name : result.attacker.name;
                
                console.log(`🧠 Psychic Shove: ${loserName} at ${loserPointId} knocked back by winner at ${winnerPointId}`);
                
                // Calculate knockback direction (straight line away from winner)
                const knockbackPath = this.calculateKnockbackPath(winnerPointId, loserPointId);
                
                if (knockbackPath.length === 0) {
                    console.log(`⚠️ No valid knockback path - ${loserName} stays in place`);
                    const loserTeam = result.winner === 'attacker' ? result.defender.team : result.attacker.team;
                    this.addToHistory(`${loserName} cannot be knocked back!`, 'battle', loserTeam);
                    return;
                }
                
                // Collect all affected Pokémon (including chain collisions)
                const affectedRobots = await this.executeKnockback(loserPointId, knockbackPath);
                
                // Check if any robots were actually moved
                if (affectedRobots.length === 0) {
                    console.log(`🛑 Psychic Shove FAILED: Path completely blocked - no robots moved`);
                    console.log(`   "As far back as possible" = ZERO distance`);
                    console.log(`   No robots affected → No Wait status applied`);
                    const loserTeam = result.winner === 'attacker' ? result.defender.team : result.attacker.team;
                    this.addToHistory(`${loserName} cannot be knocked back - path blocked!`, 'battle', loserTeam);
                    return;
                }
                
                // Apply Wait status to all affected Pokémon (BOTH TEAMS)
                console.log(`📋 Applying Wait status to ${affectedRobots.length} affected Pokémon:`);
                for (const robotInfo of affectedRobots) {
                    console.log(`  - ${robotInfo.robotName} (${robotInfo.team} team) at ${robotInfo.newPointId}`);
                    this.applyStatusEffect(robotInfo.newPointId, 'waiting');
                    console.log(`⏸️ ${robotInfo.robotName} (${robotInfo.team}) gained Wait status at ${robotInfo.newPointId}`);
                    this.addToHistory(`⏸️ ${robotInfo.robotName} gained Wait status`, 'battle', robotInfo.team);
                }
                
                console.log(`✅ Psychic Shove complete - ${affectedRobots.length} Pokémon affected (including friendly fire!)`);
            },
            
            // Calculate knockback path in straight line away from attacker
            calculateKnockbackPath(fromPointId, targetPointId) {
                const fromPoint = this.getPointById(fromPointId);
                const targetPoint = this.getPointById(targetPointId);
                
                if (!fromPoint || !targetPoint) return [];
                
                // Calculate direction vector (from attacker to target)
                const dx = targetPoint.x - fromPoint.x;
                const dy = targetPoint.y - fromPoint.y;
                
                // Normalize direction
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance === 0) return [];
                
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                console.log(`📐 Knockback direction from ${fromPointId} to ${targetPointId}: (${dirX.toFixed(2)}, ${dirY.toFixed(2)})`);
                
                // Build path by following connections that continue in the knockback direction
                const path = [];
                let currentPointId = targetPointId;
                const visited = new Set([targetPointId]);
                
                // Follow connections up to 10 steps
                for (let step = 0; step < 10; step++) {
                    const currentPoint = this.getPointById(currentPointId);
                    if (!currentPoint || !currentPoint.connections) break;
                    
                    // Find the best connected point that continues in the knockback direction
                    let bestNextPoint = null;
                    let bestScore = -Infinity;
                    
                    for (const connectedId of currentPoint.connections) {
                        if (visited.has(connectedId)) continue;
                        
                        const connectedPoint = this.getPointById(connectedId);
                        if (!connectedPoint) {
                            console.log(`  ⚠️ Could not find point: ${connectedId}`);
                            continue;
                        }
                        
                        // Calculate vector from current to connected point
                        const toConnectedX = connectedPoint.x - currentPoint.x;
                        const toConnectedY = connectedPoint.y - currentPoint.y;
                        
                        // Dot product: how well does this connection align with knockback direction?
                        const dotProduct = toConnectedX * dirX + toConnectedY * dirY;
                        
                        console.log(`    Checking ${connectedId}: dot=${dotProduct.toFixed(2)}`);
                        
                        // Only consider points that continue in the knockback direction
                        if (dotProduct > 0 && dotProduct > bestScore) {
                            bestScore = dotProduct;
                            bestNextPoint = { id: connectedId, x: connectedPoint.x, y: connectedPoint.y };
                        }
                    }
                    
                    if (bestNextPoint) {
                        path.push(bestNextPoint);
                        visited.add(bestNextPoint.id);
                        currentPointId = bestNextPoint.id;
                        console.log(`  ➡️ Step ${step + 1}: ${bestNextPoint.id} (score: ${bestScore.toFixed(2)})`);
                    } else {
                        console.log(`  🛑 No more points in knockback direction`);
                        break;
                    }
                }
                
                console.log(`📍 Knockback path from ${targetPointId}:`, path.map(p => p.id));
                return path;
            },
            
            // Execute knockback with chain collisions
            async executeKnockback(startPointId, knockbackPath) {
                const affectedRobots = [];
                
                // Get the initial target robot
                const initialRobotData = this.getPointById(startPointId)?.robot;
                if (!initialRobotData) {
                    console.log(`⚠️ No robot at ${startPointId} to knock back`);
                    return affectedRobots;
                }
                
                // Build a list of ALL robots that need to move (including the initial target)
                // Format: [{pointId, robot, pathIndex}] where pathIndex is position in knockbackPath
                const robotChain = [{
                    pointId: startPointId,
                    robot: initialRobotData,
                    pathIndex: -1  // Initial robot is BEFORE the path
                }];
                
                // Scan the knockback path for robots in the way
                for (let i = 0; i < knockbackPath.length; i++) {
                    const pathPoint = this.getPointById(knockbackPath[i].id);
                    if (pathPoint.robot) {
                        robotChain.push({
                            pointId: knockbackPath[i].id,
                            robot: pathPoint.robot,
                            pathIndex: i
                        });
                    }
                }
                
                console.log(`🔗 Chain of ${robotChain.length} robots to move`);
                
                // CRITICAL: Check if there's ANY empty space in the path
                // If the entire path is blocked, NO robots can move (Immovable Object scenario)
                let hasEmptySpace = false;
                for (let i = 0; i < knockbackPath.length; i++) {
                    const pathPoint = this.getPointById(knockbackPath[i].id);
                    if (!pathPoint.robot) {
                        hasEmptySpace = true;
                        break;
                    }
                }
                
                if (!hasEmptySpace) {
                    console.log(`🛑 IMMOVABLE OBJECT: Entire knockback path is blocked - no robots can move`);
                    console.log(`   Path checked: ${knockbackPath.map(p => p.id).join(' → ')}`);
                    console.log(`   All spaces occupied - "as far back as possible" = ZERO distance`);
                    console.log(`   ❌ Psychic Shove effect FAILS - no robots affected, no Wait applied`);
                    return affectedRobots; // Return empty array
                }
                
                // Move robots from BACK TO FRONT (farthest first)
                // Each robot moves as far as possible along the path
                for (let i = robotChain.length - 1; i >= 0; i--) {
                    const robotInfo = robotChain[i];
                    const robotData = RobotDatabase.getRobot(robotInfo.robot.id);
                    const robotName = robotData?.name || robotInfo.robot.id;
                    
                    // Find the farthest available space for this robot
                    // Search from the robot's current position in the path
                    let targetPointId = null;
                    let searchStartIndex = robotInfo.pathIndex + 1;
                    
                    // Scan the path to find the farthest empty space
                    for (let j = searchStartIndex; j < knockbackPath.length; j++) {
                        const checkPoint = this.getPointById(knockbackPath[j].id);
                        if (!checkPoint.robot) {
                            // Found an empty space - keep searching for farther ones
                            targetPointId = knockbackPath[j].id;
                        } else {
                            // Hit an occupied space - stop searching
                            break;
                        }
                    }
                    
                    if (!targetPointId) {
                        console.log(`⚠️ No space for ${robotName} - staying at ${robotInfo.pointId}`);
                        continue;
                    }
                    
                    // Move the robot
                    const success = await this.moveRobotForKnockback(robotInfo.pointId, targetPointId);
                    if (success) {
                        affectedRobots.push({
                            robotId: robotInfo.robot.id,
                            robotName: robotName,
                            team: robotInfo.robot.team,
                            oldPointId: robotInfo.pointId,
                            newPointId: targetPointId
                        });
                        console.log(`💨 ${robotName} (${robotInfo.robot.team}) knocked back from ${robotInfo.pointId} to ${targetPointId}`);
                    }
                }
                
                return affectedRobots;
            },
            
            // Handle Annihilate: Move robot 2 steps away (self-displacement)
            // Can trigger on win OR draw (Annihilate is Blue, so always draws)
            async handleAnnihilate(robotPointId, opponentPointId, result) {
                // Determine which robot spun Annihilate
                // If called from draw handler, we need to check which robot is at robotPointId
                const robotAtPoint = this.getPointById(robotPointId)?.robot;
                if (!robotAtPoint) {
                    console.error(`❌ No robot at ${robotPointId} for Annihilate effect`);
                    // End turn even if effect failed
                    this.endPlayerTurn();
                    return;
                }
                
                const robotName = robotAtPoint.name;
                const robotTeam = robotAtPoint.team;
                
                console.log(`🌀 Annihilate: ${robotName} at ${robotPointId} repositioning 2 steps away`);
                
                // Phase 2: Find all valid 2-step destinations
                const validDestinations = this.findTwoStepPaths(robotPointId);
                
                // Phase 3: Handle different cases
                if (validDestinations.length === 0) {
                    // Case A: No valid moves
                    console.log(`⚠️ Annihilate FAILED: No valid 2-step paths found`);
                    this.addToHistory(`${robotName} cannot reposition - no clear paths!`, 'battle', robotTeam);
                    // End turn after failed effect
                    this.endPlayerTurn();
                    return;
                } else if (validDestinations.length === 1) {
                    // Case B: One valid move - auto-execute
                    const destination = validDestinations[0];
                    console.log(`✅ Annihilate: Auto-moving to ${destination.pointId} (only valid path)`);
                    await this.executeAnnihilateMovement(robotPointId, destination, robotName, robotTeam);
                    // End turn after repositioning
                    this.endPlayerTurn();
                } else {
                    // Case C: Multiple valid moves - player choice required
                    console.log(`🎯 Annihilate: ${validDestinations.length} valid destinations - awaiting player choice`);
                    await this.promptAnnihilateDestination(robotPointId, validDestinations, robotName, robotTeam);
                    // End turn after player choice and repositioning
                    this.endPlayerTurn();
                }
            },
            
            // Find all valid 2-step paths from a starting point
            // Returns array of {pointId, path: [start, intermediate, destination]}
            findTwoStepPaths(startPointId) {
                console.log(`🔍 Searching for valid 2-step paths from ${startPointId}...`);
                
                const validDestinations = [];
                const startPoint = this.getPointById(startPointId);
                
                if (!startPoint || !startPoint.connections) {
                    console.log(`⚠️ Start point ${startPointId} has no connections`);
                    return validDestinations;
                }
                
                // Step 1: Check all adjacent points (intermediate points)
                for (const intermediateId of startPoint.connections) {
                    const intermediatePoint = this.getPointById(intermediateId);
                    
                    if (!intermediatePoint) continue;
                    
                    // Intermediate point must be EMPTY
                    if (intermediatePoint.robot) {
                        console.log(`  ❌ ${intermediateId} is occupied (intermediate) - path blocked`);
                        continue;
                    }
                    
                    // Step 2: From intermediate, check all connections (final destinations)
                    if (!intermediatePoint.connections) continue;
                    
                    for (const destinationId of intermediatePoint.connections) {
                        // Don't go back to start
                        if (destinationId === startPointId) continue;
                        
                        const destinationPoint = this.getPointById(destinationId);
                        
                        if (!destinationPoint) continue;
                        
                        // Destination must be EMPTY
                        if (destinationPoint.robot) {
                            console.log(`  ❌ ${destinationId} is occupied (destination) - path blocked`);
                            continue;
                        }
                        
                        // Valid 2-step path found!
                        const path = [startPointId, intermediateId, destinationId];
                        validDestinations.push({
                            pointId: destinationId,
                            path: path
                        });
                        console.log(`  ✅ Valid path: ${path.join(' → ')}`);
                    }
                }
                
                console.log(`📊 Found ${validDestinations.length} valid 2-step destinations`);
                return validDestinations;
            },
            
            // Execute Annihilate movement (single destination, no choice needed)
            async executeAnnihilateMovement(fromPointId, destination, robotName, robotTeam) {
                console.log(`🎬 Executing Annihilate movement: ${fromPointId} → ${destination.pointId}`);
                console.log(`   Path: ${destination.path.join(' → ')}`);
                
                // Get robot data
                const fromPoint = this.getPointById(fromPointId);
                const robotData = fromPoint.robot;
                
                if (!robotData) {
                    console.error(`❌ No robot at ${fromPointId}`);
                    return;
                }
                
                // Get robot visual element
                const robotGroup = document.querySelector(`[data-robot-id="${robotData.id}"]`);
                if (!robotGroup) {
                    console.error(`❌ Robot visual not found for ${robotData.id}`);
                    return;
                }
                
                // Phase 4: Animate movement along the path
                await this.animateAlongPath(robotGroup, destination.path, fromPointId, destination.pointId);
                
                // Move robot data
                const toPoint = this.getPointById(destination.pointId);
                toPoint.robot = robotData;
                fromPoint.robot = null;
                
                console.log(`✅ Annihilate complete: ${robotName} repositioned to ${destination.pointId}`);
                this.addToHistory(`🌀 ${robotName} repositioned 2 steps away`, 'battle', robotTeam);
            },
            
            // Prompt player to choose Annihilate destination (multiple valid paths)
            async promptAnnihilateDestination(fromPointId, validDestinations, robotName, robotTeam) {
                console.log(`🎯 Prompting player to choose Annihilate destination...`);
                
                // Highlight all valid destinations (same as normal movement)
                validDestinations.forEach(dest => {
                    const pointEl = document.getElementById(dest.pointId);
                    if (pointEl) {
                        pointEl.classList.add('valid-move', 'annihilate-destination');
                        
                        // Activate movable space image for standard points (same as normal movement)
                        if (pointEl.classList.contains('standard-point')) {
                            const movableImage = document.querySelector(`.movable-space-image[data-point="${dest.pointId}"]`);
                            if (movableImage) {
                                movableImage.classList.add('active');
                                console.log(`  🎨 Highlighted ${dest.pointId} with movable image`);
                            }
                        } else {
                            console.log(`  🎨 Highlighted ${dest.pointId}`);
                        }
                    }
                });
                
                // Show instruction
                this.addToHistory(`🌀 Choose where ${robotName} repositions (2 steps)`, 'battle', robotTeam);
                
                // Wait for player to click a valid destination
                return new Promise((resolve) => {
                    let isProcessing = false; // Prevent multiple triggers
                    
                    const clickHandler = async (event) => {
                        // Prevent multiple executions
                        if (isProcessing) return;
                        
                        // Find which point was clicked - handle both direct point clicks AND movable image clicks
                        let clickedPointId = null;
                        
                        // Check if clicked on a movable space image
                        const movableImage = event.target.closest('.movable-space-image');
                        if (movableImage) {
                            clickedPointId = movableImage.dataset.point;
                            console.log(`🌀 Annihilate: Clicked movable image for ${clickedPointId}`);
                        } else {
                            // Check if clicked on a point directly
                            const pointElement = event.target.closest('.point');
                            if (pointElement) {
                                clickedPointId = pointElement.id;
                                console.log(`🌀 Annihilate: Clicked point element ${clickedPointId}`);
                            }
                        }
                        
                        if (!clickedPointId) {
                            console.log(`🌀 Annihilate: Click not on a point, ignoring`);
                            return;
                        }
                        
                        // Check if clicked point is a valid destination
                        const selectedDestination = validDestinations.find(d => d.pointId === clickedPointId);
                        
                        if (selectedDestination) {
                            // STOP PROPAGATION to prevent other handlers from interfering
                            event.stopPropagation();
                            event.preventDefault();
                            
                            isProcessing = true; // Lock to prevent re-entry
                            console.log(`✅ Annihilate: Player selected ${clickedPointId} - stopping propagation`);
                            
                            // Remove click listener FIRST to prevent duplicate calls (use capture phase)
                            document.removeEventListener('click', clickHandler, true);
                            
                            // Remove highlights (same as normal movement)
                            validDestinations.forEach(dest => {
                                const pointEl = document.getElementById(dest.pointId);
                                if (pointEl) {
                                    pointEl.classList.remove('valid-move', 'annihilate-destination');
                                    
                                    // Deactivate movable space image
                                    if (pointEl.classList.contains('standard-point')) {
                                        const movableImage = document.querySelector(`.movable-space-image[data-point="${dest.pointId}"]`);
                                        if (movableImage) {
                                            movableImage.classList.remove('active');
                                        }
                                    }
                                }
                            });
                            
                            // Execute movement
                            await this.executeAnnihilateMovement(fromPointId, selectedDestination, robotName, robotTeam);
                            resolve();
                        } else {
                            console.log(`🌀 Annihilate: ${clickedPointId} not a valid destination, ignoring`);
                        }
                    };
                    
                    // Add click listener to document with CAPTURE PHASE (runs before other handlers)
                    console.log(`🌀 Annihilate: Installing capture-phase click handler`);
                    document.addEventListener('click', clickHandler, true);
                });
            },
            
            // Get all board points with coordinates
            getAllBoardPoints() {
                const points = [];
                
                // Helper to add points with coordinates
                const addPoints = (pointsObj) => {
                    for (const [id, data] of Object.entries(pointsObj)) {
                        const element = document.getElementById(id);
                        if (element) {
                            const rect = element.getBoundingClientRect();
                            points.push({
                                id: id,
                                x: rect.left + rect.width / 2,
                                y: rect.top + rect.height / 2,
                                data: data
                            });
                        }
                    }
                };
                
                addPoints(this.gameBoard.entryPoints);
                addPoints(this.gameBoard.routePoints);
                addPoints(this.gameBoard.innerPoints);
                addPoints(this.gameBoard.goalPoints);
                
                return points;
            },
            
            // Move robot for knockback (simpler version for special effects)
            async moveRobotForKnockback(fromPointId, toPointId) {
                const fromPoint = this.getPointById(fromPointId);
                const toPoint = this.getPointById(toPointId);
                
                if (!fromPoint || !toPoint || !fromPoint.robot) {
                    console.error(`❌ Invalid knockback move: ${fromPointId} → ${toPointId}`);
                    return false;
                }
                
                if (toPoint.robot) {
                    console.error(`❌ Destination occupied: ${toPointId}`);
                    return false;
                }
                
                const robotData = fromPoint.robot;
                const robotId = robotData.id;
                
                console.log(`💨 Knockback: Moving ${robotData.name} from ${fromPointId} to ${toPointId}`);
                
                // Animate the visual robot
                await this.moveRobotVisual(fromPointId, toPointId);
                
                // Update data in gameBoard
                if (this.gameBoard.entryPoints[fromPointId]) {
                    this.gameBoard.entryPoints[fromPointId].robot = null;
                } else if (this.gameBoard.routePoints[fromPointId]) {
                    this.gameBoard.routePoints[fromPointId].robot = null;
                } else if (this.gameBoard.innerPoints[fromPointId]) {
                    this.gameBoard.innerPoints[fromPointId].robot = null;
                } else if (this.gameBoard.goalPoints[fromPointId]) {
                    this.gameBoard.goalPoints[fromPointId].robot = null;
                }
                
                if (this.gameBoard.entryPoints[toPointId]) {
                    this.gameBoard.entryPoints[toPointId].robot = robotData;
                } else if (this.gameBoard.routePoints[toPointId]) {
                    this.gameBoard.routePoints[toPointId].robot = robotData;
                } else if (this.gameBoard.innerPoints[toPointId]) {
                    this.gameBoard.innerPoints[toPointId].robot = robotData;
                } else if (this.gameBoard.goalPoints[toPointId]) {
                    this.gameBoard.goalPoints[toPointId].robot = robotData;
                }
                
                // Update DOM attributes
                const fromElement = document.getElementById(fromPointId);
                if (fromElement) {
                    fromElement.setAttribute('data-occupied', 'false');
                    fromElement.setAttribute('data-team', 'neutral');
                }
                
                const toElement = document.getElementById(toPointId);
                if (toElement) {
                    toElement.setAttribute('data-occupied', 'true');
                    toElement.setAttribute('data-team', robotData.team);
                }
                
                console.log(`✅ Knockback complete: ${robotData.name} moved to ${toPointId}`);
                return true;
            },
            
            // Get move type color for styling text
            getMoveTypeColor(moveType) {
                const colors = {
                    'white': '#ffffff',
                    'gold': '#ffd700',
                    'purple': '#b19cd9',
                    'blue': '#4a9eff',
                    'red': '#ff6b6b',
                    'special': '#ff00ff',  // Magenta for special effects like "BONUS SPIN!"
                    'boost': '#00ff00'     // Bright green for damage boosts like "+50 DAMAGE!"
                };
                return colors[moveType.toLowerCase()] || '#ffffff';
            },
            
            // Format move name with color styling
            formatColoredMoveName(moveName, moveType) {
                const color = this.getMoveTypeColor(moveType);
                return `<span style="color: ${color}; font-weight: bold;">${moveName}</span>`;
            },
            
            // Get user-friendly battle explanation for result screen
            getUserFriendlyBattleExplanation(winnerMove, loserMove, winner) {
                const winType = winnerMove.moveType.toLowerCase();
                const loseType = loserMove.moveType.toLowerCase();
                
                // Gold beats Purple (special rule)
                if (winType === 'gold' && loseType === 'purple') {
                    return 'due to Gold moves beating Purple moves';
                }
                
                // Purple beats White (special rule)
                if (winType === 'purple' && loseType === 'white') {
                    return 'due to Purple moves beating White moves';
                }
                
                // White vs White - higher damage wins
                if (winType === 'white' && loseType === 'white') {
                    const winDmg = winnerMove.damage || 0;
                    const loseDmg = loserMove.damage || 0;
                    if (winDmg > loseDmg) {
                        return 'due to higher damage';
                    }
                }
                
                // Gold vs Gold - higher damage wins
                if (winType === 'gold' && loseType === 'gold') {
                    const winDmg = winnerMove.damage || 0;
                    const loseDmg = loserMove.damage || 0;
                    if (winDmg > loseDmg) {
                        return 'due to higher damage';
                    }
                }
                
                // White vs Gold - higher damage wins
                if ((winType === 'white' && loseType === 'gold') || (winType === 'gold' && loseType === 'white')) {
                    const winDmg = winnerMove.damage || 0;
                    const loseDmg = loserMove.damage || 0;
                    if (winDmg > loseDmg) {
                        return 'due to higher damage';
                    }
                }
                
                // Purple vs Purple - higher stars wins
                if (winType === 'purple' && loseType === 'purple') {
                    const winStars = winnerMove.stars || 0;
                    const loseStars = loserMove.stars || 0;
                    if (winStars > loseStars) {
                        return 'due to more stars';
                    }
                }
                
                // White vs Purple - Purple wins by type advantage
                if (winType === 'purple' && loseType === 'white') {
                    return 'due to Purple moves beating White moves';
                }
                
                // Gold vs Purple - Gold wins by type advantage
                if (winType === 'gold' && loseType === 'purple') {
                    return 'due to Gold moves beating Purple moves';
                }
                
                // White vs Red - White wins by priority
                if (winType === 'white' && loseType === 'red') {
                    return 'due to White moves beating Miss';
                }
                
                // Gold vs Red - Gold wins by priority
                if (winType === 'gold' && loseType === 'red') {
                    return 'due to Gold moves beating Miss';
                }
                
                // Gold vs White - if same damage, no explanation needed
                // Purple vs White - Purple wins by type
                // Any other case - return empty (no explanation needed)
                return '';
            },
            
            // Check if a winning move is a status effect (Purple move)
            isStatusEffectMove(result) {
                if (result.winner === 'attacker') {
                    return result.attackerMove.moveType.toLowerCase() === 'purple';
                } else if (result.winner === 'defender') {
                    return result.defenderMove.moveType.toLowerCase() === 'purple';
                }
                return false;
            },
            
            // Extract status type from move name or effect
            getStatusFromMove(move) {
                const moveName = move.moveName.toLowerCase();
                const effect = (move.effect || '').toLowerCase();
                
                // Check move name first (return standardized status names)
                if (moveName.includes('poison powder') || moveName.includes('toxic')) {
                    return 'poison';
                }
                if (moveName.includes('sleep powder') || moveName.includes('hypnosis') || moveName.includes('sleep')) {
                    return 'sleep';
                }
                if (moveName.includes('paralyze') || moveName.includes('stun') || moveName.includes('thunder wave')) {
                    return 'paralysis';
                }
                if (moveName.includes('burn') || moveName.includes('flame') || moveName.includes('scorch')) {
                    return 'burn';
                }
                if (moveName.includes('confuse') || moveName.includes('confusion')) {
                    return 'confusion';
                }
                if (moveName.includes('freeze') || moveName.includes('frozen')) {
                    return 'frozen';
                }
                if (moveName.includes('noxious')) {
                    return 'noxious';
                }
                
                // Check effect description (return standardized status names)
                if (effect.includes('noxious')) return 'noxious';
                if (effect.includes('poison')) return 'poison';
                if (effect.includes('sleep') || effect.includes('asleep')) return 'sleep';
                if (effect.includes('paralyz')) return 'paralysis';
                if (effect.includes('burn')) return 'burn';
                if (effect.includes('confus')) return 'confusion';
                if (effect.includes('freeze') || effect.includes('frozen')) return 'frozen';
                if (effect.includes('wait')) return 'waiting';
                
                // Generic status if we can't determine (fallback, shouldn't be used)
                return null;
            },
            
            // Apply status effect to a robot (battle system wrapper)
            applyStatusEffect(pointId, status) {
                const pointData = this.getPointById(pointId);
                if (!pointData || !pointData.robot) return false;
                
                const robotId = pointData.robot.id;
                
                // Use centralized status effect system
                const wasApplied = this.addStatusEffect(robotId, status);
                
                const robotData = RobotDatabase.getRobot(robotId);
                if (wasApplied) {
                    console.log(`✨ Applied ${status} to ${robotData?.name || robotId} at ${pointId}`);
                } else {
                    console.log(`⚠️ Failed to apply ${status} to ${robotData?.name || robotId} at ${pointId}`);
                }
                
                // Developer Log: Status Effect
                const statusDef = this.statusEffectDefinitions[status];
                this.addDeveloperLog('STATUS_EFFECT', {
                    robotId: robotId,
                    robotName: robotData?.name || robotId,
                    team: pointData.robot.team,
                    location: pointId,
                    status: status,
                    statusName: statusDef?.name || status,
                    effect: statusDef?.effect || 'Unknown',
                    wasApplied: wasApplied,
                    currentStatuses: this.getRobotStatuses(robotId)
                });
                
                // Update visual indicators
                this.updateRobotStatusIndicators(pointId, robotId);
                this.updateRobotStatusDisplay(pointId);
                
                return wasApplied;
            },
            
            // Update visual display of robot status
            updateRobotStatusDisplay(pointId) {
                const pointData = this.getPointById(pointId);
                if (!pointData || !pointData.robot) return;
                
                const element = document.querySelector(`[data-point-id="${pointId}"]`);
                if (!element) return;
                
                // Remove existing status indicator
                const existingStatus = element.querySelector('.status-indicator-svg');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                // Display all active statuses
                if (pointData.robot.statusConditions && pointData.robot.statusConditions.length > 0) {
                    const statusIcons = {
                        'poisoned': '🟣',
                        'asleep': '💤',
                        'paralyzed': '⚡',
                        'burned': '🔥',
                        'confused': '😵',
                        'frozen': '❄️'
                    };
                    
                    const statusText = pointData.robot.statusConditions
                        .map(s => statusIcons[s] || '✨')
                        .join('');
                    
                    // Create SVG text element for status
                    const svgNS = "http://www.w3.org/2000/svg";
                    const statusGroup = document.createElementNS(svgNS, 'g');
                    statusGroup.setAttribute('class', 'status-indicator-svg');
                    
                    // Background circle
                    const bgCircle = document.createElementNS(svgNS, 'circle');
                    bgCircle.setAttribute('cx', '40');
                    bgCircle.setAttribute('cy', '10');
                    bgCircle.setAttribute('r', '12');
                    bgCircle.setAttribute('fill', 'rgba(0, 0, 0, 0.8)');
                    bgCircle.setAttribute('stroke', 'rgba(255, 255, 255, 0.5)');
                    bgCircle.setAttribute('stroke-width', '1');
                    statusGroup.appendChild(bgCircle);
                    
                    // Status text
                    const textEl = document.createElementNS(svgNS, 'text');
                    textEl.setAttribute('x', '40');
                    textEl.setAttribute('y', '10');
                    textEl.setAttribute('text-anchor', 'middle');
                    textEl.setAttribute('dominant-baseline', 'central');
                    textEl.setAttribute('font-size', '16');
                    textEl.textContent = statusText;
                    statusGroup.appendChild(textEl);
                    
                    element.appendChild(statusGroup);
                }
            },
            
            // Display battle result
            displayBattleResult(result) {
                const resultDiv = document.getElementById('battleResult');
                const titleDiv = document.getElementById('battleResultTitle');
                const detailsDiv = document.getElementById('battleResultDetails');
                
                let title = '';
                let details = '';
                let titleClass = '';
                
                const attackerTeam = this.currentBattle.attackerTeam;
                const defenderTeam = this.currentBattle.defenderTeam;
                const attackerPointId = this.currentBattle.attackerPointId;
                const defenderPointId = this.currentBattle.defenderPointId;
                
                // Determine if this is a status effect or knockout
                const isStatusEffect = this.isStatusEffectMove(result);
                
                if (result.winner === 'attacker') {
                    if (isStatusEffect) {
                        const status = this.getStatusFromMove(result.attackerMove);
                        const statusDisplay = this.statusEffectDefinitions[status]?.name || status;
                        const statusDef = this.statusEffectDefinitions[status];
                        
                        // Check if status can be applied (for poison/noxious interaction)
                        const defenderRobotId = this.getPointById(defenderPointId)?.robot?.id;
                        let canApply = true;
                        
                        if (defenderRobotId && status === 'poison' && this.hasStatusEffect(defenderRobotId, 'noxious')) {
                            canApply = false;
                        }
                        
                        if (canApply) {
                            title = '✨ Status Effect!';
                            titleClass = 'status';
                            
                            // Build detailed message with effect description
                            let effectDesc = '';
                            if (statusDef?.damageReduction) {
                                effectDesc = `<br><em style="color: #ff9999; font-size: 0.9em;">→ Attacks will deal -${statusDef.damageReduction} damage</em>`;
                            } else if (statusDef?.description) {
                                effectDesc = `<br><em style="color: #ff9999; font-size: 0.9em;">→ ${statusDef.description}</em>`;
                            }
                            
                            // Format move names with colors
                            const attackerColoredMove = this.formatColoredMoveName(result.attackerMove.moveName, result.attackerMove.moveType);
                            const defenderColoredMove = this.formatColoredMoveName(result.defenderMove.moveName, result.defenderMove.moveType);
                            
                            details = `${result.attacker.name}'s ${attackerColoredMove} vs ${result.defender.name}'s ${defenderColoredMove}<br><strong style="color: #ffd93d;">${result.defender.name} is now ${statusDisplay}!</strong>${effectDesc}`;
                            this.addToHistory(`✨ ${result.defender.name} is now ${statusDisplay}!`, 'battle', defenderTeam);
                        } else {
                            title = '⚠️ Ineffective!';
                            titleClass = 'status';
                            
                            // Format move names with colors
                            const attackerColoredMove = this.formatColoredMoveName(result.attackerMove.moveName, result.attackerMove.moveType);
                            const defenderColoredMove = this.formatColoredMoveName(result.defenderMove.moveName, result.defenderMove.moveType);
                            
                            details = `${result.attacker.name}'s ${attackerColoredMove} vs ${result.defender.name}'s ${defenderColoredMove}<br><strong style="color: #ff9999;">Status effect blocked!</strong><br><em style="color: #ffcc99; font-size: 0.9em;">→ ${result.defender.name} is already Noxious (stronger effect)</em>`;
                            this.addToHistory(`⚠️ ${result.defender.name} resisted ${statusDisplay} (already Noxious)`, 'battle', defenderTeam);
                        }
                    } else {
                        title = '🎉 Victory!';
                        titleClass = 'victory';
                        
                        // Build detailed message with damage values
                        const attackerDamage = result.attackerMove.damage || 0;
                        const defenderDamage = result.defenderMove.damage || 0;
                        const defenderMoveName = result.defenderMove.moveName;
                        
                        // Get explanation for why the battle was won
                        const explanation = this.getUserFriendlyBattleExplanation(result.attackerMove, result.defenderMove, 'attacker');
                        const explanationText = explanation ? ` ${explanation}` : '';
                        
                        // Format move names with colors
                        const attackerColoredMove = this.formatColoredMoveName(result.attackerMove.moveName, result.attackerMove.moveType);
                        const defenderColoredMove = this.formatColoredMoveName(defenderMoveName, result.defenderMove.moveType);
                        
                        details = `${result.attacker.name}'s ${attackerColoredMove} (${attackerDamage}) defeated ${result.defender.name}'s ${defenderColoredMove} (${defenderDamage})!${explanationText}`;
                        this.addToHistory(`🎉 ${result.attacker.name} wins the battle!`, 'battle', attackerTeam);
                    }
                } else if (result.winner === 'defender') {
                    if (isStatusEffect) {
                        const status = this.getStatusFromMove(result.defenderMove);
                        const statusDisplay = this.statusEffectDefinitions[status]?.name || status;
                        const statusDef = this.statusEffectDefinitions[status];
                        
                        // Check if status can be applied (for poison/noxious interaction)
                        const attackerRobotId = this.getPointById(attackerPointId)?.robot?.id;
                        let canApply = true;
                        
                        if (attackerRobotId && status === 'poison' && this.hasStatusEffect(attackerRobotId, 'noxious')) {
                            canApply = false;
                        }
                        
                        if (canApply) {
                            title = '✨ Status Effect!';
                            titleClass = 'status';
                            
                            // Build detailed message with effect description
                            let effectDesc = '';
                            if (statusDef?.damageReduction) {
                                effectDesc = `<br><em style="color: #ff9999; font-size: 0.9em;">→ Attacks will deal -${statusDef.damageReduction} damage</em>`;
                            } else if (statusDef?.description) {
                                effectDesc = `<br><em style="color: #ff9999; font-size: 0.9em;">→ ${statusDef.description}</em>`;
                            }
                            
                            // Format move names with colors
                            const attackerColoredMove = this.formatColoredMoveName(result.attackerMove.moveName, result.attackerMove.moveType);
                            const defenderColoredMove = this.formatColoredMoveName(result.defenderMove.moveName, result.defenderMove.moveType);
                            
                            details = `${result.attacker.name}'s ${attackerColoredMove} vs ${result.defender.name}'s ${defenderColoredMove}<br><strong style="color: #ffd93d;">${result.attacker.name} is now ${statusDisplay}!</strong>${effectDesc}`;
                            this.addToHistory(`✨ ${result.attacker.name} is now ${statusDisplay}!`, 'battle', attackerTeam);
                        } else {
                            title = '⚠️ Ineffective!';
                            titleClass = 'status';
                            
                            // Format move names with colors
                            const attackerColoredMove = this.formatColoredMoveName(result.attackerMove.moveName, result.attackerMove.moveType);
                            const defenderColoredMove = this.formatColoredMoveName(result.defenderMove.moveName, result.defenderMove.moveType);
                            
                            details = `${result.attacker.name}'s ${attackerColoredMove} vs ${result.defender.name}'s ${defenderColoredMove}<br><strong style="color: #ff9999;">Status effect blocked!</strong><br><em style="color: #ffcc99; font-size: 0.9em;">→ ${result.attacker.name} is already Noxious (stronger effect)</em>`;
                            this.addToHistory(`⚠️ ${result.attacker.name} resisted ${statusDisplay} (already Noxious)`, 'battle', attackerTeam);
                        }
                    } else {
                        title = '💥 Defeated!';
                        titleClass = 'defeat';
                        
                        // Build detailed message with damage values
                        const defenderDamage = result.defenderMove.damage || 0;
                        const attackerDamage = result.attackerMove.damage || 0;
                        const attackerMoveName = result.attackerMove.moveName;
                        
                        // Get explanation for why the battle was won
                        const explanation = this.getUserFriendlyBattleExplanation(result.defenderMove, result.attackerMove, 'defender');
                        const explanationText = explanation ? ` ${explanation}` : '';
                        
                        // Format move names with colors
                        const defenderColoredMove = this.formatColoredMoveName(result.defenderMove.moveName, result.defenderMove.moveType);
                        const attackerColoredMove = this.formatColoredMoveName(attackerMoveName, result.attackerMove.moveType);
                        
                        details = `${result.defender.name}'s ${defenderColoredMove} (${defenderDamage}) defeated ${result.attacker.name}'s ${attackerColoredMove} (${attackerDamage})!${explanationText}`;
                        this.addToHistory(`🎉 ${result.defender.name} wins the battle!`, 'battle', defenderTeam);
                    }
                } else {
                    title = '🤝 Draw!';
                    titleClass = 'draw';
                    
                    // Format move names with colors
                    const attackerColoredMove = this.formatColoredMoveName(result.attackerMove.moveName, result.attackerMove.moveType);
                    const defenderColoredMove = this.formatColoredMoveName(result.defenderMove.moveName, result.defenderMove.moveType);
                    
                    details = `Both robots spun ${attackerColoredMove} vs ${defenderColoredMove} - No winner!`;
                    this.addToHistory(`🤝 Battle ended in a draw!`, 'battle', null);
                }
                
                titleDiv.textContent = title;
                titleDiv.className = `battle-result-title ${titleClass}`;
                detailsDiv.innerHTML = details;
                
                resultDiv.classList.add('active');
                
                // Store result for processing
                this.currentBattle.result = result;
            },
            
            // Close battle result and apply consequences
            async closeBattleResult() {
                if (!this.currentBattle || !this.currentBattle.result) return;
                
                const { result, attackerPointId, defenderPointId, attackerTeam, defenderTeam } = this.currentBattle;
                
                // Check if this is a status effect move
                const isStatusEffect = this.isStatusEffectMove(result);
                
                // Check if this is a special effect move (like Psychic Shove)
                const hasSpecialEffect = this.hasSpecialEffect(result);
                
                // Apply battle consequences
                if (result.winner === 'attacker') {
                    if (hasSpecialEffect) {
                        // Handle special effect moves
                        await this.handleSpecialEffect(result.attackerMove, attackerPointId, defenderPointId, result);
                    } else if (isStatusEffect) {
                        // Apply status effect to defender
                        const status = this.getStatusFromMove(result.attackerMove);
                        const statusDisplay = this.statusEffectDefinitions[status]?.name || status;
                        const wasApplied = this.applyStatusEffect(defenderPointId, status);
                        
                        if (wasApplied) {
                            console.log(`✨ ${result.defender.name} was inflicted with ${statusDisplay}!`);
                            this.addToHistory(`✨ ${result.defender.name} is now ${statusDisplay}`, 'battle', defenderTeam);
                        } else {
                            console.log(`⚠️ ${result.defender.name} resisted ${statusDisplay}!`);
                            this.addToHistory(`⚠️ ${result.defender.name} resisted ${statusDisplay}`, 'battle', defenderTeam);
                        }
                    } else {
                        // Defender is knocked out
                        this.knockOutRobot(defenderPointId);
                        console.log(`💀 ${result.defender.name} was knocked out!`);
                        this.addToHistory(`💀 ${result.defender.name} knocked out at ${defenderPointId}`, 'battle', defenderTeam);
                    }
                } else if (result.winner === 'defender') {
                    if (hasSpecialEffect) {
                        // Handle special effect moves
                        await this.handleSpecialEffect(result.defenderMove, defenderPointId, attackerPointId, result);
                    } else if (isStatusEffect) {
                        // Apply status effect to attacker
                        const status = this.getStatusFromMove(result.defenderMove);
                        const statusDisplay = this.statusEffectDefinitions[status]?.name || status;
                        const wasApplied = this.applyStatusEffect(attackerPointId, status);
                        
                        if (wasApplied) {
                            console.log(`✨ ${result.attacker.name} was inflicted with ${statusDisplay}!`);
                            this.addToHistory(`✨ ${result.attacker.name} is now ${statusDisplay}`, 'battle', attackerTeam);
                        } else {
                            console.log(`⚠️ ${result.attacker.name} resisted ${statusDisplay}!`);
                            this.addToHistory(`⚠️ ${result.attacker.name} resisted ${statusDisplay}`, 'battle', attackerTeam);
                        }
                    } else {
                        // Attacker is knocked out
                        this.knockOutRobot(attackerPointId);
                        console.log(`💀 ${result.attacker.name} was knocked out!`);
                        this.addToHistory(`💀 ${result.attacker.name} knocked out at ${attackerPointId}`, 'battle', attackerTeam);
                    }
                } else {
                    // Draw - check for special effects that trigger even on draws (like Annihilate)
                    // Store info to handle AFTER modal closes
                    this.pendingAnnihilate = null;
                    
                    // Check attacker's move
                    if (result.attackerMove.moveName === 'Annihilate') {
                        console.log(`🌀 Draw, but attacker spun Annihilate - will trigger after modal closes`);
                        this.pendingAnnihilate = {
                            robotPointId: attackerPointId,
                            opponentPointId: defenderPointId,
                            result: result
                        };
                    }
                    
                    // Check defender's move
                    if (result.defenderMove.moveName === 'Annihilate') {
                        console.log(`🌀 Draw, but defender spun Annihilate - will trigger after modal closes`);
                        this.pendingAnnihilate = {
                            robotPointId: defenderPointId,
                            opponentPointId: attackerPointId,
                            result: result
                        };
                    }
                    
                    this.addToHistory(`Both robots remain on the board`, 'info', null);
                }
                // If draw, both robots stay
                
                // Close modal
                document.getElementById('battleOverlay').classList.remove('active');
                document.querySelector('.battle-action-buttons').style.display = 'flex';
                
                // Clear battle data (but keep pendingAnnihilate)
                this.currentBattle = null;
                
                // Clear debugger selections for next battle
                this.clearDebuggerSelections();
                
                console.log('✅ Battle resolved');
                
                // Handle pending Annihilate effect (after modal is closed)
                if (this.pendingAnnihilate) {
                    console.log(`🌀 Processing pending Annihilate effect...`);
                    const annihilateInfo = this.pendingAnnihilate;
                    this.pendingAnnihilate = null; // Clear it immediately to prevent re-triggering
                    
                    // Now trigger the effect AFTER modal is closed
                    await this.handleAnnihilate(
                        annihilateInfo.robotPointId,
                        annihilateInfo.opponentPointId,
                        annihilateInfo.result
                    );
                    
                    // Return early - handleAnnihilate will handle turn ending if needed
                    return;
                }
                
                // CHECK FOR WAITWIN: Did this battle eliminate the opponent?
                if (this.checkWaitWin(attackerTeam)) {
                    console.log(`🏆 ${attackerTeam} wins by System Lock after battle!`);
                    return; // Game over - don't end turn
                }
                
                // IMPORTANT: End the turn of whoever initiated the battle
                console.log(`🔄 Battle complete - ending ${attackerTeam}'s turn`);
                console.log(`📊 Current state: debugMode=${this.debugMode}, currentControlTeam=${this.currentControlTeam}, gameState=${this.currentState}`);
                
                // Always use endPlayerTurn which handles both debug mode and normal mode
                this.endPlayerTurn();
            },
            
            // ==========================================
            // REPAIR BAY SYSTEM
            // ==========================================
            
            // Knock out a robot (send to Repair Bay)
            knockOutRobot(pointId) {
                const pointData = this.getPointById(pointId);
                if (!pointData || !pointData.robot) return;
                
                const robotId = pointData.robot.id;
                const team = pointData.robot.team;
                
                console.log(`💀 Robot ${robotId} defeated - sending to Repair Bay`);
                
                // Developer Log: Knockout
                const robotData = RobotDatabase.getRobot(robotId);
                this.addDeveloperLog('KNOCKOUT', {
                    robotId: robotId,
                    robotName: robotData?.name || robotId,
                    team: team,
                    location: pointId,
                    action: 'Knocked out - sending to Repair Bay'
                });
                
                // Remove visual robot from board
                this.removeRobotVisual(pointId);
                
                // Remove robot data from point - DIRECTLY in gameBoard
                if (this.gameBoard.entryPoints[pointId]) {
                    delete this.gameBoard.entryPoints[pointId].robot;
                } else if (this.gameBoard.routePoints[pointId]) {
                    delete this.gameBoard.routePoints[pointId].robot;
                } else if (this.gameBoard.innerPoints[pointId]) {
                    delete this.gameBoard.innerPoints[pointId].robot;
                } else if (this.gameBoard.goalPoints[pointId]) {
                    delete this.gameBoard.goalPoints[pointId].robot;
                }
                
                // Send to Repair Bay (handles FIFO queue logic)
                this.sendToRepairBay(robotId, team);
            },
            
            // Send robot to Repair Bay (FIFO queue with 2-slot capacity)
            sendToRepairBay(robotId, team) {
                const repairBay = this.playerZones[team].repairBay;
                
                console.log(`🔧 Sending ${robotId} to ${team} Repair Bay`);
                console.log(`   Current bay status: ${repairBay.length}/2 slots occupied`);
                
                // Add robot to repair bay queue
                const repairEntry = {
                    robotId: robotId,
                    timestamp: Date.now()
                };
                repairBay.push(repairEntry);
                
                // Check if bay is over capacity (3rd robot)
                let overflowOccurred = false;
                let pushedRobotId = null;
                if (repairBay.length > 2) {
                    console.log(`⚠️ Repair Bay overflow! Pushing oldest robot back to bench...`);
                    
                    // Remove oldest robot (first in queue)
                    const pushedRobot = repairBay.shift();
                    pushedRobotId = pushedRobot.robotId;
                    overflowOccurred = true;
                    
                    // Return to bench with "Rebooting: 1" status
                    this.returnToBench(pushedRobot.robotId, team, true);
                }
                
                // Developer Log: Repair Bay
                const robotData = RobotDatabase.getRobot(robotId);
                this.addDeveloperLog('REPAIR', {
                    action: 'Sent to Repair Bay',
                    robotId: robotId,
                    robotName: robotData?.name || robotId,
                    team: team,
                    bayCapacity: `${repairBay.length}/2`,
                    overflow: overflowOccurred,
                    pushedRobotId: pushedRobotId
                });
                
                // Update visual display
                this.updateRepairBayDisplay(team);
                
                // Log history
                this.addToHistory(`🔧 ${robotData?.name || robotId} sent to Repair Bay`, 'info', team);
            },
            
            // Return robot from Repair Bay to Bench
            returnToBench(robotId, team, addRebootingStatus = false) {
                console.log(`♻️ Returning ${robotId} to ${team} bench`);
                
                // UNIVERSAL CURE: Clear ALL status effects (Repair Bay cures everything)
                this.clearAllStatusEffects(robotId);
                
                // Find an empty bench slot
                const benchSlots = this.playerZones[team].benchSlots;
                let targetSlot = null;
                
                for (const [slotId, slotData] of Object.entries(benchSlots)) {
                    if (slotData.robotId === null) {
                        targetSlot = slotId;
                        break;
                    }
                }
                
                if (!targetSlot) {
                    console.error(`❌ No empty bench slot available for ${robotId}!`);
                    this.addToHistory(`⚠️ Bench full - ${robotId} could not return!`, 'error', team);
                    return;
                }
                
                // Place robot on bench
                benchSlots[targetSlot].robotId = robotId;
                
                // Add "Rebooting: 2" status if needed (decrements at turn start, so 2 ensures 1 full turn wait)
                if (addRebootingStatus) {
                    if (!this.rebootingRobots) {
                        this.rebootingRobots = {}; // Initialize if doesn't exist
                    }
                    // Store with team prefix to avoid conflicts when both teams have same robot IDs
                    const rebootKey = `${team}:${robotId}`;
                    this.rebootingRobots[rebootKey] = 2; // Wait 1 full turn (2 because it decrements immediately on next turn start)
                    console.log(`⏳ ${robotId} (${team}) has "Rebooting: 2" status - cannot deploy for 1 full turn`);
                }
                
                // Update visual display
                this.updateBenchDisplay(team);
                
                // Log history
                const robotData = RobotDatabase.getRobot(robotId);
                const rebootMsg = addRebootingStatus ? ' (Rebooting: 1)' : '';
                this.addToHistory(`♻️ ${robotData?.name || robotId} returned to bench${rebootMsg}`, 'info', team);
            },
            
            // Update Repair Bay visual display
            updateRepairBayDisplay(team) {
                const repairBay = this.playerZones[team].repairBay;
                const prefix = team === 'player' ? 'player' : 'opponent';
                
                console.log(`🎨 Updating ${team} Repair Bay display`);
                
                // Update both slots
                for (let i = 1; i <= 2; i++) {
                    const slotElement = document.getElementById(`${prefix}-repair-slot-${i}`);
                    if (!slotElement) continue;
                    
                    // Clear slot first
                    const existingRobot = slotElement.querySelector('.bench-robot');
                    if (existingRobot) {
                        existingRobot.remove();
                    }
                    
                    // Check if robot exists in this slot position (index i-1)
                    if (repairBay[i - 1]) {
                        const robotId = repairBay[i - 1].robotId;
                        const robotData = RobotDatabase.getRobot(robotId);
                        
                        slotElement.setAttribute('data-occupied', 'true');
                        slotElement.setAttribute('data-robot-id', robotId);
                        
                        // Create deactivated robot visual
                        const robotDiv = document.createElement('div');
                        robotDiv.className = 'bench-robot repair-bay-robot';
                        robotDiv.setAttribute('data-robot-id', robotId); // For Combat Dial handler
                        robotDiv.style.width = '40px';
                        robotDiv.style.height = '40px';
                        robotDiv.style.backgroundImage = `url('${robotData.image}')`;
                        robotDiv.style.backgroundSize = 'contain';
                        robotDiv.style.backgroundRepeat = 'no-repeat';
                        robotDiv.style.backgroundPosition = 'center';
                        robotDiv.style.position = 'absolute';
                        // Grayscale and opacity applied via CSS
                        
                        slotElement.appendChild(robotDiv);
                        
                        console.log(`  Slot ${i}: ${robotData?.name || robotId} (deactivated)`);
                    } else {
                        slotElement.setAttribute('data-occupied', 'false');
                        slotElement.setAttribute('data-robot-id', '');
                        console.log(`  Slot ${i}: Empty`);
                    }
                }
                
                // Re-attach Combat Dial handlers to repair bay robots
                setTimeout(() => {
                    this.addCombatDialHandlersToAllRobots();
                }, 50);
            },
            
            // Process rebooting status at turn start
            processRebootingStatus(team) {
                if (!this.rebootingRobots) return;
                
                console.log(`⏳ Processing Rebooting status for ${team}...`);
                
                const benchSlots = this.playerZones[team].benchSlots;
                const toRemove = [];
                let processedAny = false;
                
                // Only process robots that belong to this team (check key prefix)
                for (const [rebootKey, waitCount] of Object.entries(this.rebootingRobots)) {
                    // Extract team from key (format: "team:robotId")
                    const [keyTeam, robotId] = rebootKey.split(':');
                    
                    // Only process if this robot belongs to current team
                    if (keyTeam === team) {
                        processedAny = true;
                        
                        // Decrement wait count first
                        this.rebootingRobots[rebootKey]--;
                        console.log(`⏳ ${robotId} (${team}) rebooting countdown: ${waitCount} → ${this.rebootingRobots[rebootKey]}`);
                        
                        // If countdown reaches 0, remove rebooting status
                        if (this.rebootingRobots[rebootKey] <= 0) {
                            toRemove.push(rebootKey);
                            console.log(`✅ ${robotId} (${team}) rebooting complete - can now deploy`);
                            const robotData = RobotDatabase.getRobot(robotId);
                            this.addToHistory(`✅ ${robotData?.name || robotId} ready for deployment`, 'info', team);
                        }
                    }
                }
                
                // Remove completed reboots
                toRemove.forEach(rebootKey => {
                    delete this.rebootingRobots[rebootKey];
                });
                
                // Update bench display ONLY if we processed any robots for this team
                if (processedAny) {
                    this.updateBenchDisplay(team);
                    console.log(`🎨 Bench display refreshed after rebooting status update`);
                }
            },
            
            // Check if robot has rebooting status
            isRobotRebooting(robotId, team) {
                if (!this.rebootingRobots) return false;
                
                // Check for team-specific rebooting key
                const rebootKey = `${team}:${robotId}`;
                return this.rebootingRobots[rebootKey] !== undefined;
            },
            
            // ==========================================
            // REPAIR BAY UTILITY FUNCTIONS
            // ==========================================
            
            // Manually return oldest robot from Repair Bay to Bench (for testing/manual repair)
            manualRepairFromBay(team) {
                const repairBay = this.playerZones[team].repairBay;
                
                if (repairBay.length === 0) {
                    console.log(`⚠️ ${team} Repair Bay is empty - nothing to repair`);
                    return false;
                }
                
                // Get oldest robot (first in queue)
                const repairEntry = repairBay.shift();
                console.log(`🔧 Manually repairing ${repairEntry.robotId} from ${team} Repair Bay`);
                
                // Return to bench WITHOUT rebooting status (manual repair = instant)
                this.returnToBench(repairEntry.robotId, team, false);
                
                // Update Repair Bay display
                this.updateRepairBayDisplay(team);
                
                return true;
            },
            
            // Clear all Repair Bay state (for game reset/debugging)
            clearRepairBayState() {
                console.log('🧹 Clearing all Repair Bay state...');
                
                // Clear repair bay queues
                this.playerZones.player.repairBay = [];
                this.playerZones.opponent.repairBay = [];
                
                // Clear rebooting status
                this.rebootingRobots = {};
                
                // Update displays
                this.updateRepairBayDisplay('player');
                this.updateRepairBayDisplay('opponent');
                
                console.log('✅ Repair Bay state cleared');
            },
            
            // Debug: Show Repair Bay status
            debugShowRepairBay() {
                console.log('🔧 REPAIR BAY STATUS REPORT');
                console.log('═══════════════════════════════════════');
                
                // Player bay
                const playerBay = this.playerZones.player.repairBay;
                console.log(`\n👤 Player Repair Bay (${playerBay.length}/2):`);
                playerBay.forEach((entry, index) => {
                    const robot = RobotDatabase.getRobot(entry.robotId);
                    console.log(`  [${index + 1}] ${robot?.name || entry.robotId} - waiting since ${new Date(entry.timestamp).toLocaleTimeString()}`);
                });
                
                // Opponent bay
                const opponentBay = this.playerZones.opponent.repairBay;
                console.log(`\n🤖 Opponent Repair Bay (${opponentBay.length}/2):`);
                opponentBay.forEach((entry, index) => {
                    const robot = RobotDatabase.getRobot(entry.robotId);
                    console.log(`  [${index + 1}] ${robot?.name || entry.robotId} - waiting since ${new Date(entry.timestamp).toLocaleTimeString()}`);
                });
                
                // Rebooting robots
                console.log(`\n⏳ Rebooting Robots:`);
                if (Object.keys(this.rebootingRobots).length === 0) {
                    console.log('  (none)');
                } else {
                    for (const [robotId, waitCount] of Object.entries(this.rebootingRobots)) {
                        const robot = RobotDatabase.getRobot(robotId);
                        console.log(`  ${robot?.name || robotId}: ${waitCount} turn(s) remaining`);
                    }
                }
                
                console.log('\n═══════════════════════════════════════');
            },
            
            // Cancel battle (don't attack)
            cancelBattle() {
                console.log('↩️ Battle cancelled');
                
                // Store battle data before clearing
                const attackerPointId = this.currentBattle?.attackerPointId;
                const attackerTeam = this.currentBattle?.attackerTeam;
                
                // Reset battle flag since battle was cancelled
                this.turnActions.hasBattled = false;
                this.turnActions.actionTakenThisTurn = this.turnActions.hasMovedRobot; // Keep movement flag if robot moved
                console.log('✅ Battle action reset - player can still act this turn');
                
                // Close modal
                document.getElementById('battleOverlay').classList.remove('active');
                document.querySelector('.battle-action-buttons').style.display = 'flex';
                
                // Clear battle data
                this.currentBattle = null;
                
                // Clear debugger selections
                this.clearDebuggerSelections();
                
                // Re-highlight adjacent enemies so player can attack again
                if (attackerPointId && attackerTeam) {
                    console.log(`🔄 Re-highlighting adjacent enemies for ${attackerPointId}`);
                    this.highlightAdjacentEnemies(attackerPointId, attackerTeam);
                }
            },
            
            // Combat Dial Info System - Tap and Hold to View
            holdTimer: null,
            holdDuration: 250, // milliseconds to trigger (0.25 seconds = easier to trigger!)
            
            // Initialize Combat Dial tap-and-hold handlers
            initializeCombatDialHandlers() {
                console.log('🎯 Initializing Combat Dial tap-and-hold handlers...');
                
                // We'll add handlers dynamically to robots as they appear
                // This includes: board robots, bench robots, and repair bay robots
                this.addCombatDialHandlersToAllRobots();
                
                console.log('✅ Combat Dial handlers initialized');
            },
            
            // Add handlers to all current robots on screen
            addCombatDialHandlersToAllRobots() {
                let handlerCount = 0;
                
                // Board robots (SVG elements) - attach ONLY to group, not circle (avoid event bubbling duplicates)
                const boardRobots = document.querySelectorAll('.battle-robot');
                boardRobots.forEach(robotEl => {
                    const robotId = this.getRobotIdFromElement(robotEl);
                    if (robotId) {
                        // Attach handler (will skip if already attached to this element instance)
                        this.addCombatDialHandlerToElement(robotEl, robotId);
                        handlerCount++;
                        
                        // DON'T attach to clickCircle - causes event bubbling that resets timer!
                        // The group element is sufficient for capturing clicks
                    }
                });
                
                // Bench robots (HTML elements)
                const benchRobots = document.querySelectorAll('.bench-robot:not(.repair-bay-robot)');
                benchRobots.forEach(robotEl => {
                    const robotId = this.getRobotIdFromElement(robotEl);
                    if (robotId) {
                        // Attach handler (will skip if already attached to this element instance)
                        this.addCombatDialHandlerToElement(robotEl, robotId);
                        handlerCount++;
                    }
                });
                
                // Repair bay robots (HTML elements)
                const repairRobots = document.querySelectorAll('.repair-bay-robot');
                repairRobots.forEach(robotEl => {
                    const robotId = this.getRobotIdFromElement(robotEl);
                    if (robotId) {
                        // Attach handler (will skip if already attached to this element instance)
                        this.addCombatDialHandlerToElement(robotEl, robotId);
                        handlerCount++;
                    }
                });
                
                console.log(`🎯 Added Combat Dial handlers to ${handlerCount} robots (board: ${boardRobots.length}, bench: ${benchRobots.length}, repair: ${repairRobots.length})`);
            },
            
            // Get robot ID from element (works for board, bench, and repair bay)
            getRobotIdFromElement(element) {
                // Check for data-robot-id attribute
                if (element.hasAttribute('data-robot-id')) {
                    const robotId = element.getAttribute('data-robot-id');
                    if (robotId) return robotId;
                }
                
                // Check parent for data-robot-id (repair bay robots)
                if (element.parentElement && element.parentElement.hasAttribute('data-robot-id')) {
                    const robotId = element.parentElement.getAttribute('data-robot-id');
                    if (robotId) return robotId;
                }
                
                // For board robots, check the ID pattern
                const elId = element.id;
                if (elId && elId.startsWith('robot-')) {
                    const pointId = elId.replace('robot-', '');
                    const point = this.getPointById(pointId);
                    return point?.robot?.id;
                }
                
                // Check onclick attribute (bench robots)
                const onclick = element.getAttribute('onclick');
                if (onclick) {
                    const match = onclick.match(/'([^']+)'/);
                    if (match) return match[1];
                }
                
                return null;
            },
            
            // Add tap-and-hold handler to a specific element
            addCombatDialHandlerToElement(element, robotId) {
                // Check if handler already attached to THIS SPECIFIC element instance
                if (element._combatDialHandlers) {
                    // Already has handler on this exact element, skip to avoid duplicates
                    console.log(`⏭️ Skipping duplicate handler for ${robotId} (already attached to this element)`);
                    return;
                }
                
                // Mark as having handlers (using property instead of attribute for element-specific tracking)
                element._hasCombatDialHandler = true;
                
                // Store coordinates in element's dataset so all handlers can access them
                element.dataset.holdStartX = '0';
                element.dataset.holdStartY = '0';
                const moveThreshold = 30; // pixels - increased tolerance
                
                // Create bound handlers that we can remove later
                const handlers = {
                    mousedown: (e) => {
                        console.log(`🖱️ Mouse down on robot ${robotId} at (${e.clientX}, ${e.clientY})`);
                        element.dataset.holdStartX = e.clientX.toString();
                        element.dataset.holdStartY = e.clientY.toString();
                        this.startCombatDialHold(robotId, e);
                    },
                    mouseup: (e) => {
                        console.log(`🖱️ Mouse up on robot ${robotId}`);
                        this.cancelCombatDialHold();
                    },
                    mousemove: (e) => {
                        // Only check if we have a hold timer active
                        if (!this.holdTimer) return;
                        
                        const startX = parseFloat(element.dataset.holdStartX || '0');
                        const startY = parseFloat(element.dataset.holdStartY || '0');
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > moveThreshold) {
                            console.log(`🖱️ Mouse moved ${distance.toFixed(1)}px - cancelling hold`);
                            this.cancelCombatDialHold();
                        }
                    },
                    touchstart: (e) => {
                        console.log(`👆 Touch start on robot ${robotId}`);
                        if (e.touches[0]) {
                            element.dataset.holdStartX = e.touches[0].clientX.toString();
                            element.dataset.holdStartY = e.touches[0].clientY.toString();
                        }
                        this.startCombatDialHold(robotId, e);
                    },
                    touchmove: (e) => {
                        // Only check if we have a hold timer active
                        if (!this.holdTimer) return;
                        
                        if (e.touches[0]) {
                            const startX = parseFloat(element.dataset.holdStartX || '0');
                            const startY = parseFloat(element.dataset.holdStartY || '0');
                            const dx = e.touches[0].clientX - startX;
                            const dy = e.touches[0].clientY - startY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > moveThreshold) {
                                console.log(`👆 Touch moved ${distance.toFixed(1)}px - cancelling hold`);
                                this.cancelCombatDialHold();
                            }
                        }
                    },
                    touchend: () => {
                        console.log(`👆 Touch end on robot ${robotId}`);
                        this.cancelCombatDialHold();
                    },
                    touchcancel: () => {
                        console.log(`👆 Touch cancel on robot ${robotId}`);
                        this.cancelCombatDialHold();
                    }
                };
                
                // Add all handlers
                element.addEventListener('mousedown', handlers.mousedown, false);
                element.addEventListener('mouseup', handlers.mouseup, false);
                element.addEventListener('mousemove', handlers.mousemove, false);
                element.addEventListener('touchstart', handlers.touchstart, { passive: true });
                element.addEventListener('touchmove', handlers.touchmove, { passive: true });
                element.addEventListener('touchend', handlers.touchend, false);
                element.addEventListener('touchcancel', handlers.touchcancel, false);
                
                // Store handlers for potential cleanup
                element._combatDialHandlers = handlers;
                
                console.log(`✅ Combat Dial handler attached to robot ${robotId}`);
            },
            
            // Start the hold timer
            startCombatDialHold(robotId, event) {
                // Only block during active animation, not during selection
                if (this.isMovementInProgress) {
                    return;
                }
                
                // Clear any existing timer
                this.cancelCombatDialHold();
                
                console.log(`⏱️ Started hold timer for ${robotId} (${this.holdDuration}ms = ${this.holdDuration/1000}s)`);
                console.log(`📍 Hold started at coordinates: (${Math.round(event.clientX)}, ${Math.round(event.clientY)})`);
                
                // Start new timer
                this.holdTimer = setTimeout(() => {
                    console.log(`✅ 🎉 HOLD COMPLETE - Opening Combat Dial for ${robotId}!`);
                    this.showCombatDialInfo(robotId);
                }, this.holdDuration);
            },
            
            // Cancel the hold timer
            cancelCombatDialHold() {
                if (this.holdTimer) {
                    console.log(`❌ Hold timer cancelled (released too early or moved)`);
                    clearTimeout(this.holdTimer);
                    this.holdTimer = null;
                }
            },
            
            // Show Combat Dial info overlay
            showCombatDialInfo(robotId) {
                console.log(`📊 Showing Combat Dial info for ${robotId}`);
                
                const robot = RobotDatabase.getRobot(robotId);
                if (!robot) {
                    console.error(`❌ Robot ${robotId} not found in database`);
                    return;
                }
                
                // Get active status effects for this robot
                const statuses = this.getRobotStatuses(robotId);
                const hasStatusEffects = statuses.conditions.length > 0 || statuses.markers.length > 0;
                
                // Update modal content
                document.getElementById('combatDialRobotImage').src = robot.image;
                document.getElementById('combatDialRobotName').textContent = robot.name;
                document.getElementById('combatDialRobotRole').textContent = robot.role;
                
                // Build stats display with status effect modifications
                let statsHtml = `MP: ${robot.mp}`;
                if (statuses.markers.includes('mp-1')) {
                    statsHtml = `MP: <span style="color: #ff6b6b; text-decoration: line-through;">${robot.mp}</span> <span style="color: #ff6b6b; font-weight: bold;">${robot.mp - 1}</span> (MP-1)`;
                }
                document.getElementById('combatDialRobotStats').innerHTML = statsHtml;
                
                // Add status effects display
                if (hasStatusEffects) {
                    const statusDisplay = `
                        <div style="margin-top: 10px; padding: 8px; background: rgba(255,107,107,0.1); border-radius: 6px; border-left: 3px solid #ff6b6b;">
                            <div style="font-weight: bold; color: #ff6b6b; margin-bottom: 5px;">⚠️ ACTIVE STATUS EFFECTS</div>
                            ${statuses.conditions.map(s => {
                                const def = this.statusEffectDefinitions[s];
                                return `<div style="margin: 3px 0; font-size: 12px;">
                                    ${def?.icon || '⚠️'} <strong>${def?.name || s}</strong>: ${def?.description || 'Unknown effect'}
                                </div>`;
                            }).join('')}
                            ${statuses.markers.map(s => {
                                const def = this.statusEffectDefinitions[s];
                                return `<div style="margin: 3px 0; font-size: 12px;">
                                    ${def?.icon || '🔖'} <strong>${def?.name || s}</strong>: ${def?.description || 'Unknown effect'}
                                </div>`;
                            }).join('')}
                        </div>
                    `;
                    document.getElementById('combatDialRobotStats').innerHTML += statusDisplay;
                }
                
                // Update ability
                const abilitySection = document.getElementById('combatDialAbility');
                abilitySection.querySelector('.combat-dial-ability-name').textContent = robot.ability.name;
                abilitySection.querySelector('.combat-dial-ability-desc').textContent = robot.ability.description;
                
                // Generate circular wheel visualization using conic-gradient (same as attack wheels)
                const wheelContainer = document.getElementById('combatDialWheelContainer');
                wheelContainer.innerHTML = '';
                
                // Clear any existing pip overlays
                const existingPips = wheelContainer.querySelectorAll('.wheel-pip-container');
                existingPips.forEach(pip => pip.remove());
                
                // Clear any existing star overlays
                const existingStars = wheelContainer.querySelectorAll('.wheel-star-container');
                existingStars.forEach(star => star.remove());
                
                // Assign pip identifiers
                const wheelDataWithPips = this.assignPipIdentifiers(robot.wheel);
                
                let gradientSegments = [];
                let currentAngle = 0;
                const totalSize = 96;
                
                wheelDataWithPips.forEach(segment => {
                    const segmentAngle = (segment.size / totalSize) * 360;
                    const color = this.getMoveColorHex(segment.moveType);
                    
                    gradientSegments.push(`${color} ${currentAngle}deg ${currentAngle + segmentAngle}deg`);
                    
                    // Add pip overlay if this segment has a pip identifier
                    if (segment.pipCount > 0) {
                        this.addPipOverlay(wheelContainer, currentAngle, segmentAngle, segment.pipCount);
                    }
                    
                    // Add star overlay if this segment has stars
                    if (segment.stars !== undefined && segment.stars !== null) {
                        this.addStarOverlay(wheelContainer, currentAngle, segmentAngle, segment.stars);
                    }
                    
                    currentAngle += segmentAngle;
                });
                
                wheelContainer.style.background = `conic-gradient(${gradientSegments.join(', ')})`;
                
                // Reset and add spinning animation
                wheelContainer.style.animation = 'none';
                setTimeout(() => {
                    wheelContainer.style.animation = 'combatDialWheelSpin 3s cubic-bezier(0.17, 0.67, 0.12, 0.99) forwards';
                }, 10);
                
                // Populate wheel display with pip identifiers (same format as attack screen)
                const wheelDisplay = document.getElementById('combatDialWheelDisplay');
                wheelDisplay.innerHTML = '';
                
                // Sort wheel data: Miss moves at bottom, others by size (most common first)
                const sortedWheelData = [...wheelDataWithPips].sort((a, b) => {
                    const aIsMiss = a.moveName.toLowerCase().includes('miss');
                    const bIsMiss = b.moveName.toLowerCase().includes('miss');
                    
                    // If one is Miss and the other isn't, Miss goes to bottom
                    if (aIsMiss && !bIsMiss) return 1;
                    if (!aIsMiss && bIsMiss) return -1;
                    
                    // Otherwise sort by size (largest first)
                    return b.size - a.size;
                });
                
                sortedWheelData.forEach(move => {
                    const moveEl = document.createElement('div');
                    moveEl.className = `combat-dial-move ${move.moveType}`;
                    
                    // Icon for move type
                    const typeIcons = {
                        'White': '⚔️',
                        'Gold': '⭐',
                        'Purple': '✨',
                        'Blue': '🛡️',
                        'Red': '❌'
                    };
                    const icon = typeIcons[move.moveType] || '•';
                    
                    // Format move name with pip identifier if present
                    let displayName = move.moveName;
                    if (move.pipCount > 0) {
                        const pips = '•'.repeat(move.pipCount);
                        displayName += ` (${pips})`;
                    }
                    
                    // Show full effect text - handle "None" case for normal attacks
                    let effectText = move.effect;
                    
                    // Miss moves should have no description
                    if (move.moveName.toLowerCase().includes('miss')) {
                        effectText = '';
                    } else if (!effectText || effectText === 'None' || effectText.trim() === '') {
                        // Normal attacks without special effects
                        effectText = 'Normal attack';
                    }
                    
                    // Build damage/stars display with status effect modifications
                    let statsHtml = '';
                    if (move.damage) {
                        // Check if status effects reduce damage for this move type
                        let modifiedDamage = move.damage;
                        let damageReduction = 0;
                        const moveType = move.moveType.toLowerCase();
                        
                        // Check each status effect for damage reductions
                        [...statuses.conditions, ...statuses.markers].forEach(statusName => {
                            const statusDef = this.statusEffectDefinitions[statusName];
                            if (statusDef && statusDef.damageReduction) {
                                if (statusDef.affectedMoveTypes && statusDef.affectedMoveTypes.includes(moveType)) {
                                    damageReduction += statusDef.damageReduction;
                                }
                            }
                        });
                        
                        modifiedDamage = Math.max(0, move.damage - damageReduction);
                        
                        if (damageReduction > 0) {
                            statsHtml = `<div class="combat-dial-move-damage">
                                <span style="text-decoration: line-through; color: #999;">${move.damage}</span> 
                                <span style="color: #ff6b6b; font-weight: bold;">${modifiedDamage}</span>
                                <span style="font-size: 10px; color: #ff6b6b;"> (-${damageReduction})</span>
                            </div>`;
                        } else {
                            statsHtml = `<div class="combat-dial-move-damage">${move.damage}</div>`;
                        }
                    } else if (move.stars) {
                        statsHtml = `<div class="combat-dial-move-damage">${'⭐'.repeat(move.stars)}</div>`;
                    }
                    statsHtml += `<div class="combat-dial-move-size">Size: ${move.size}</div>`;
                    
                    moveEl.innerHTML = `
                        <div class="combat-dial-move-color">${icon}</div>
                        <div class="combat-dial-move-info">
                            <div class="combat-dial-move-name">${displayName}</div>
                            <div class="combat-dial-move-effect">${effectText}</div>
                        </div>
                        <div class="combat-dial-move-stats">
                            ${statsHtml}
                        </div>
                    `;
                    
                    wheelDisplay.appendChild(moveEl);
                });
                
                // Show overlay
                document.getElementById('combatDialOverlay').classList.add('active');
            },
            
            // Close Combat Dial info overlay
            closeCombatDialInfo() {
                document.getElementById('combatDialOverlay').classList.remove('active');
                console.log('📊 Combat Dial info closed');
            },
            
            // Show turn indicator
            showTurnIndicator(team) {
                const indicator = document.getElementById('turnIndicator');
                indicator.className = 'turn-indicator active';
                
                if (team === 'player') {
                    indicator.classList.add('player-turn');
                    indicator.textContent = '🎮 Your Turn';
                } else {
                    indicator.classList.add('opponent-turn');
                    indicator.textContent = '🤖 Opponent Turn';
                }
                
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 2000);
            },
            
            // Team Selection Functions
            showTeamSelection() {
                this.hideAllViews();
                document.getElementById('teamSelectionView').style.display = 'block';
                this.updateTeamSelectionUI();
                console.log('🤖 Team Selection screen opened');
            },
            
            updateTeamSelectionUI() {
                // Update team count
                const teamCount = document.getElementById('teamCount');
                if (teamCount) {
                    teamCount.textContent = TeamManager.selectedTeam.length;
                }
                
                // Update team analysis
                const analysis = TeamManager.getTeamAnalysis();
                const teamAnalysisEl = document.getElementById('teamAnalysis');
                if (teamAnalysisEl) {
                    if (analysis.size === 0) {
                        teamAnalysisEl.textContent = 'Select robots to see team composition';
                    } else {
                        const roleText = Object.entries(analysis.roles).map(([role, count]) => 
                            `${count} ${role}${count > 1 ? 's' : ''}`
                        ).join(', ');
                        teamAnalysisEl.textContent = `Roles: ${roleText}`;
                    }
                }
                
                // Update selected team grid
                this.updateSelectedTeamGrid();
                
                // Update available robots grid
                this.updateAvailableRobotsGrid();
                
                // Update start battle button
                const startBtn = document.getElementById('startBattleBtn');
                if (startBtn) {
                    startBtn.disabled = !TeamManager.isTeamComplete();
                }
            },
            
            updateSelectedTeamGrid() {
                const grid = document.getElementById('selectedTeamGrid');
                if (!grid) return;
                
                const slots = grid.querySelectorAll('.squad-slot');
                slots.forEach((slot, index) => {
                    const robotId = TeamManager.selectedTeam[index];
                    const slotNumber = slot.querySelector('.slot-number');
                    const slotLabel = slot.querySelector('.slot-label');
                    
                    if (robotId) {
                        const robot = RobotDatabase.getRobot(robotId);
                        slot.className = 'squad-slot filled';
                        slotLabel.innerHTML = `
                            <div style="font-weight: 600; margin-bottom: 2px;">${robot.name}</div>
                            <div style="font-size: 8px;">${robot.mp} MP • ${robot.role}</div>
                        `;
                        slot.onclick = () => {
                            TeamManager.removeFromTeam(robotId);
                            app.updateTeamSelectionUI();
                        };
                        slot.title = `Click to remove ${robot.name}`;
                    } else {
                        slot.className = 'squad-slot empty';
                        slotLabel.textContent = 'Empty';
                        slot.onclick = null;
                        slot.title = 'Select a robot from the bay below';
                    }
                });
            },
            
            updateAvailableRobotsGrid() {
                console.log('🔧 updateAvailableRobotsGrid called');
                const grid = document.getElementById('robotsGrid');
                if (!grid) {
                    console.error('❌ robotsGrid element not found!');
                    return;
                }
                
                console.log('📐 Grid element found:', grid);
                console.log('📏 Grid dimensions:', grid.offsetWidth, 'x', grid.offsetHeight);
                console.log('👁️ Grid visibility:', getComputedStyle(grid).display, getComputedStyle(grid).visibility);
                
                console.log('🤖 Getting robots from database...');
                const allRobots = RobotDatabase.getAllRobots();
                console.log('📊 Found robots:', allRobots.length, allRobots);
                
                if (allRobots.length === 0) {
                    console.error('❌ No robots found in database!');
                    grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 20px;">No robots available</div>';
                    return;
                }
                
                grid.innerHTML = '';
                
                allRobots.forEach(robot => {
                    const isSelected = TeamManager.selectedTeam.includes(robot.id);
                    const isTeamFull = TeamManager.selectedTeam.length >= TeamManager.maxTeamSize;
                    const isDisabled = isSelected || (isTeamFull && !isSelected);
                    
                    const card = document.createElement('div');
                    card.className = `robot-card ${isSelected ? 'selected' : ''} ${isDisabled && !isSelected ? 'disabled' : ''}`;
                    
                    // Create wheel visualization
                    const wheelSegments = robot.wheel.map(segment => {
                        const width = (segment.size / 96) * 100;
                        return `<div class="wheel-segment ${segment.moveType.toLowerCase()}" style="width: ${width}%;" title="${segment.moveName}"></div>`;
                    }).join('');
                    
                    card.innerHTML = `
                        <div class="robot-card-header">
                            <img src="${robot.image}" alt="${robot.name}" class="robot-card-image">
                            <div>
                                <div class="robot-card-name">${robot.name}</div>
                                <div class="robot-card-role">${robot.role}</div>
                            </div>
                        </div>
                        <div class="robot-card-stats">
                            <div class="robot-stat"><strong>MP:</strong> ${robot.mp}</div>
                        </div>
                        <div class="robot-card-description">${robot.description}</div>
                        <div class="robot-card-wheel">${wheelSegments}</div>
                        <div style="font-size: 10px; color: var(--text-secondary);">${robot.ability.name}</div>
                    `;
                    
                    if (!isDisabled) {
                        card.onclick = () => {
                            if (isSelected) {
                                TeamManager.removeFromTeam(robot.id);
                            } else {
                                if (TeamManager.selectedTeam.length >= TeamManager.maxTeamSize) {
                                    app.showSquadFullMessage('Squad is full! Remove a robot first.');
                                    return;
                                }
                                TeamManager.addToTeam(robot.id);
                            }
                            app.updateTeamSelectionUI();
                        };
                    } else if (isTeamFull && !isSelected) {
                        card.onclick = () => {
                            app.showSquadFullMessage('Squad is full! Remove a robot first.');
                        };
                    }
                    
                    grid.appendChild(card);
                    console.log('🎯 Added robot card to grid:', robot.name);
                });
                
                console.log('✅ Robot grid update complete. Total cards:', allRobots.length);
            },
            
            startBattleWithTeam() {
                if (!TeamManager.isTeamComplete()) {
                    app.showSquadFullMessage('Please select 6 robots before starting battle!');
                    return;
                }
                
                console.log('🚀 Starting battle with selected team:', TeamManager.selectedTeam);
                
                // Transition from team selection to battle game phase
                app.showBattleGamePhase();
                
                // TODO: Use selected team for battle instead of test robots
                // For now, just show the battle game phase
            },
            
            showSquadFullMessage(message) {
                // Create temporary message element
                const messageEl = document.createElement('div');
                messageEl.textContent = message;
                messageEl.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--danger);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-weight: 600;
                    z-index: 1000;
                    animation: shake 0.5s ease-in-out;
                `;
                
                document.body.appendChild(messageEl);
                
                // Remove after 2 seconds
                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 2000);
            }
        };

        // ==========================================
        // ROBOT DATA SYSTEM - PLACEHOLDER ROBOTS
        // ==========================================
        
        const RobotDatabase = {
            // 6 Unique Placeholder Robots for Team Selection
            robots: {
                'unit-001-uc-0': {
                    id: 'unit-001-uc-0',
                    name: 'Bulbasaur',
                    rarity: 'UC',
                    mp: 3,
                    role: 'Scout',
                    type: 'Grass / Poison',
                    description: 'UC rarity unit with 3 movement points. A Grass/Poison type with powder-based attacks.',
                    image: 'Imag/Battle/Battle-data/Unit-001_UC_0/Unit-001_sprite.png',
                    ability: {
                        name: 'Powder Mastery',
                        description: 'Can inflict poison and sleep status conditions.'
                    },
                    wheel: [
                        {
                            moveName: 'Poison Powder',
                            moveType: 'Purple',
                            size: 24,
                            stars: 1,
                            effect: 'The battle opponent becomes poisoned'
                        },
                        {
                            moveName: 'Seed Bomb',
                            moveType: 'White',
                            size: 20,
                            damage: 50,
                            effect: 'None'
                        },
                        {
                            moveName: 'Sleep Powder',
                            moveType: 'Purple',
                            size: 24,
                            stars: 1,
                            effect: 'The battle opponent falls asleep'
                        },
                        {
                            moveName: 'Miss',
                            moveType: 'Red',
                            size: 28,
                            effect: 'None'
                        }
                    ],
                    statusWheels: {
                        poisoned: [
                            {
                                moveName: 'Poison Powder',
                                moveType: 'Purple',
                                size: 24,
                                stars: 1,
                                effect: 'The battle opponent becomes poisoned'
                            },
                            {
                                moveName: 'Seed Bomb',
                                moveType: 'White',
                                size: 20,
                                damage: 50,
                                effect: 'None'
                            },
                            {
                                moveName: 'Sleep Powder',
                                moveType: 'Purple',
                                size: 24,
                                stars: 1,
                                effect: 'The battle opponent falls asleep'
                            },
                            {
                                moveName: 'Miss',
                                moveType: 'Red',
                                size: 28,
                                effect: 'None'
                            }
                        ]
                    },
                    stats: {
                        hp: 88,
                        attack: 77,
                        defense: 66,
                        speed: 83
                    }
                },
                'unit-002-c-0': {
                    id: 'unit-002-c-0',
                    name: 'Ivysaur',
                    rarity: 'C',
                    mp: 2,
                    role: 'Vanguard',
                    type: 'Grass / Poison',
                    description: 'C rarity unit with 2 movement points. Evolution of Bulbasaur with stronger attacks.',
                    image: 'Imag/Battle/Battle-data/Unit-002_C_0/Unit-002_sprite.png',
                    ability: {
                        name: 'Evolved Power',
                        description: 'Stronger attacks than its pre-evolution.'
                    },
                    wheel: [
                        {
                            moveName: 'Vine Whip',
                            moveType: 'White',
                            size: 28,
                            damage: 40,
                            effect: 'None'
                        },
                        {
                            moveName: 'Razor Leaf',
                            moveType: 'White',
                            size: 24,
                            damage: 60,
                            effect: 'None'
                        },
                        {
                            moveName: 'Sleep Powder',
                            moveType: 'Purple',
                            size: 28,
                            stars: 1,
                            effect: 'The battle opponent falls asleep'
                        },
                        {
                            moveName: 'Miss',
                            moveType: 'Red',
                            size: 16,
                            effect: 'None'
                        }
                    ],
                    statusWheels: {
                        poisoned: [
                            {
                                moveName: 'Vine Whip',
                                moveType: 'White',
                                size: 28,
                                damage: 40,
                                effect: 'None'
                            },
                            {
                                moveName: 'Razor Leaf',
                                moveType: 'White',
                                size: 24,
                                damage: 60,
                                effect: 'None'
                            },
                            {
                                moveName: 'Sleep Powder',
                                moveType: 'Purple',
                                size: 28,
                                stars: 1,
                                effect: 'The battle opponent falls asleep'
                            },
                            {
                                moveName: 'Miss',
                                moveType: 'Red',
                                size: 16,
                                effect: 'None'
                            }
                        ]
                    },
                    stats: {
                        hp: 80,
                        attack: 70,
                        defense: 60,
                        speed: 50
                    }
                },
                'unit-003-ex-0': {
                    id: 'unit-003-ex-0',
                    name: 'Venusaur',
                    rarity: 'EX',
                    mp: 1,
                    role: 'Sentinel',
                    type: 'Grass / Poison',
                    description: 'EX rarity unit with 1 movement point. Final evolution with devastating Solar Beam attack.',
                    image: 'Imag/Battle/Battle-data/Unit-003_EX_0/Unit-003_sprite.png',
                    ability: {
                        name: 'Solar Power',
                        description: 'Devastating Solar Beam attack with 150 damage.'
                    },
                    wheel: [
                        {
                            moveName: 'Protect',
                            moveType: 'Blue',
                            size: 20,
                            effect: 'Defensive move'
                        },
                        {
                            moveName: 'Solar Beam',
                            moveType: 'White',
                            size: 36,
                            damage: 150,
                            effect: 'Massive damage attack'
                        },
                        {
                            moveName: 'Sleep Powder',
                            moveType: 'Purple',
                            size: 32,
                            stars: 1,
                            effect: 'The battle opponent falls asleep'
                        },
                        {
                            moveName: 'Miss',
                            moveType: 'Red',
                            size: 8,
                            effect: 'None'
                        }
                    ],
                    statusWheels: {
                        poisoned: [
                            {
                                moveName: 'Protect',
                                moveType: 'Blue',
                                size: 20,
                                effect: 'Defensive move'
                            },
                            {
                                moveName: 'Solar Beam',
                                moveType: 'White',
                                size: 36,
                                damage: 150,
                                effect: 'Massive damage attack'
                            },
                            {
                                moveName: 'Sleep Powder',
                                moveType: 'Purple',
                                size: 32,
                                stars: 1,
                                effect: 'The battle opponent falls asleep'
                            },
                            {
                                moveName: 'Miss',
                                moveType: 'Red',
                                size: 8,
                                effect: 'None'
                            }
                        ]
                    },
                    stats: {
                        hp: 120,
                        attack: 105,
                        defense: 90,
                        speed: 38
                    }
                },
                'unit-025-r-0': {
                    id: 'unit-025-r-0',
                    name: 'Pikachu',
                    rarity: 'R',
                    mp: 2,
                    role: 'Vanguard',
                    type: 'Electric',
                    description: 'R rarity unit with 2 movement points. The iconic Electric-type with powerful Thunder attacks.',
                    image: 'Imag/Battle/Battle-data/Unit-025_R_0/Unit-025_sprite.png',
                    ability: {
                        name: 'Static',
                        description: 'Can paralyze opponents with Thunder Wave.'
                    },
                    wheel: [
                        {
                            moveName: 'Quick Attack',
                            moveType: 'Gold',
                            size: 20,
                            damage: 50,
                            effect: 'Priority attack'
                        },
                        {
                            moveName: 'Thunder',
                            moveType: 'White',
                            size: 12,
                            damage: 100,
                            effect: 'High damage electric attack'
                        },
                        {
                            moveName: 'Thunder Wave',
                            moveType: 'Purple',
                            size: 20,
                            stars: 2,
                            effect: 'The battle opponent becomes paralyzed'
                        },
                        {
                            moveName: 'Thunder Shock',
                            moveType: 'White',
                            size: 40,
                            damage: 30,
                            effect: 'Basic electric attack'
                        },
                        {
                            moveName: 'Miss',
                            moveType: 'Red',
                            size: 4,
                            effect: 'None'
                        }
                    ],
                    statusWheels: {
                        paralyzed: [
                            {
                                moveName: 'Quick Attack',
                                moveType: 'Gold',
                                size: 20,
                                damage: 50,
                                effect: 'Priority attack'
                            },
                            {
                                moveName: 'Thunder',
                                moveType: 'White',
                                size: 12,
                                damage: 100,
                                effect: 'High damage electric attack'
                            },
                            {
                                moveName: 'Miss',
                                moveType: 'Red',
                                size: 20,
                                effect: 'Paralyzed - Thunder Wave becomes Miss'
                            },
                            {
                                moveName: 'Thunder Shock',
                                moveType: 'White',
                                size: 40,
                                damage: 30,
                                effect: 'Basic electric attack'
                            },
                            {
                                moveName: 'Miss',
                                moveType: 'Red',
                                size: 4,
                                effect: 'None'
                            }
                        ]
                    },
                    stats: {
                        hp: 100,
                        attack: 88,
                        defense: 75,
                        speed: 63
                    }
                },
                'unit-150-ex-0': {
                    id: 'unit-150-ex-0',
                    name: 'Mewtwo',
                    rarity: 'EX',
                    mp: 2,
                    role: 'Vanguard',
                    type: 'Psychic',
                    description: 'EX rarity unit with 2 movement points. The legendary Psychic-type with devastating abilities.',
                    image: 'Imag/Battle/Battle-data/Unit-150_EX_0/Unit-150_sprite.png',
                    ability: {
                        name: 'Legendary Power',
                        description: 'Psychic Shove can knock back multiple opponents and Psycho Cut can deal massive damage.'
                    },
                    wheel: [
                        {
                            moveName: 'Psychic Shove',
                            moveType: 'Purple',
                            size: 32,
                            stars: 2,
                            effect: 'The battle opponent is knocked as far back as possible in a straight line. Any Pokémon it collides with are also knocked back. All affected Pokémon gain Wait.'
                        },
                        {
                            moveName: 'Annihilate',
                            moveType: 'Blue',
                            size: 16,
                            effect: 'This Pokémon moves 2 steps away'
                        },
                        {
                            moveName: 'Psycho Cut',
                            moveType: 'White',
                            size: 40,
                            damage: 70,
                            effect: 'Spin again - if Psycho Cut is spun, it deals +50 damage'
                        },
                        {
                            moveName: 'Miss',
                            moveType: 'Red',
                            size: 8,
                            effect: 'None'
                        }
                    ],
                    statusWheels: {
                        poisoned: [
                            {
                                moveName: 'Psychic Shove',
                                moveType: 'Purple',
                                size: 32,
                                stars: 2,
                                effect: 'The battle opponent is knocked as far back as possible in a straight line. Any Pokémon it collides with are also knocked back. All affected Pokémon gain Wait.'
                            },
                            {
                                moveName: 'Annihilate',
                                moveType: 'Blue',
                                size: 16,
                                effect: 'This Pokémon moves 2 steps away'
                            },
                            {
                                moveName: 'Psycho Cut',
                                moveType: 'White',
                                size: 40,
                                damage: 70,
                                effect: 'Spin again - if Psycho Cut is spun, it deals +50 damage'
                            },
                            {
                                moveName: 'Miss',
                                moveType: 'Red',
                                size: 8,
                                effect: 'None'
                            }
                        ]
                    },
                    stats: {
                        hp: 130,
                        attack: 110,
                        defense: 90,
                        speed: 75
                    }
                },
                'speed-scout': {
                    id: 'speed-scout',
                    name: 'Speed Scout',
                    rarity: 'Common',
                    mp: 3, // High movement - Runner role
                    role: 'Runner',
                    description: 'Fast reconnaissance robot. Excels at reaching key positions quickly.',
                    image: 'Imag/mascot.png',
                    ability: {
                        name: 'Quick Deploy',
                        description: 'Can move immediately after being deployed from bench.'
                    },
                    wheel: [
                        { moveName: 'Dash', moveType: 'White', damage: 20, size: 24, effect: 'None' },
                        { moveName: 'Dodge', moveType: 'Blue', damage: null, size: 32, effect: 'Avoid all attacks' },
                        { moveName: 'Scout', moveType: 'Purple', damage: null, stars: 1, size: 16, effect: 'Move opponent 1 step' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Attack fails' }
                    ],
                    stats: { hp: 70, attack: 60, defense: 40, speed: 95 }
                },
                
                'heavy-bruiser': {
                    id: 'heavy-bruiser',
                    name: 'Heavy Bruiser',
                    rarity: 'Uncommon',
                    mp: 1, // Low movement - Goalie role
                    role: 'Goalie',
                    description: 'Powerful defensive robot. Perfect for protecting your goal.',
                    image: 'Imag/mascot.png',
                    ability: {
                        name: 'Fortress Mode',
                        description: 'Cannot be knocked out by attacks with 50 damage or less.'
                    },
                    wheel: [
                        { moveName: 'Smash', moveType: 'White', damage: 70, size: 28, effect: 'None' },
                        { moveName: 'Guard', moveType: 'Blue', damage: null, size: 20, effect: 'Protect adjacent allies' },
                        { moveName: 'Intimidate', moveType: 'Purple', damage: null, stars: 2, size: 12, effect: 'Opponent cannot attack next turn' },
                        { moveName: 'Power Charge', moveType: 'White', damage: 90, size: 12, effect: 'High damage attack' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Attack fails' }
                    ],
                    stats: { hp: 120, attack: 85, defense: 90, speed: 25 }
                },
                
                'tech-support': {
                    id: 'tech-support',
                    name: 'Tech Support',
                    rarity: 'Rare',
                    mp: 2, // Balanced movement - Support role
                    role: 'Support',
                    description: 'Utility robot with powerful special abilities.',
                    image: 'Imag/mascot.png',
                    ability: {
                        name: 'System Repair',
                        description: 'Remove all status conditions from adjacent friendly robots.'
                    },
                    wheel: [
                        { moveName: 'Data Beam', moveType: 'White', damage: 40, size: 20, effect: 'None' },
                        { moveName: 'Firewall', moveType: 'Blue', damage: null, size: 16, effect: 'Block all Purple moves' },
                        { moveName: 'Virus Upload', moveType: 'Purple', damage: null, stars: 3, size: 20, effect: 'Paralyze opponent' },
                        { moveName: 'System Boost', moveType: 'Purple', damage: null, stars: 2, size: 16, effect: '+20 damage to allies this turn' },
                        { moveName: 'Reboot', moveType: 'Purple', damage: null, stars: 1, size: 12, effect: 'Heal self to full HP' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 12, effect: 'Attack fails' }
                    ],
                    stats: { hp: 85, attack: 55, defense: 65, speed: 70 }
                },
                
                'alaka-bot': {
                    id: 'alaka-bot',
                    name: 'Alaka-bot',
                    rarity: 'EX',
                    mp: 2, // Balanced movement - Psychic Vanguard
                    role: 'Vanguard',
                    type: 'Psychic',
                    description: 'Elite psychic robot with devastating special abilities and status manipulation.',
                    image: 'Imag/Battle/example/alaka-bot.png',
                    ability: {
                        name: 'Psychic Mastery',
                        description: 'Purple moves cannot be blocked by Blue moves from opponents with special conditions.'
                    },
                    wheel: [
                        { moveName: 'Stillblind', moveType: 'Purple', damage: null, stars: 3, size: 24, effect: 'Attaches an Mp-2 marker to the battle opponent or one opposing Pokémon adjacent to the battle opponent. That Pokémon gains Wait 5' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 4, effect: 'Attack fails' },
                        { moveName: 'Psychic', moveType: 'White', damage: 120, size: 24, effect: 'High damage psychic attack' },
                        { moveName: 'Psyshock', moveType: 'Purple', damage: null, stars: 4, size: 24, effect: 'If the battle opponent is affected by a special condition or has Wait, the battle opponent is knocked out. The battle opponent gains Wait 3.' },
                        { moveName: 'Psycho Shift', moveType: 'Blue', damage: null, size: 20, effect: 'If this Pokémon has a special condition, that condition is applied to its battle opponent and removed from this Pokémon instead.' }
                    ],
                    statusWheels: {
                        poisoned: [
                            { moveName: 'Stillblind', moveType: 'Purple', damage: null, stars: 3, size: 24, effect: 'Attaches an Mp-2 marker to the battle opponent or one opposing Pokémon adjacent to the battle opponent. That Pokémon gains Wait 5' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 4, effect: 'Attack fails' },
                            { moveName: 'Psychic', moveType: 'White', damage: 120, size: 24, effect: 'High damage psychic attack' },
                            { moveName: 'Psyshock', moveType: 'Purple', damage: null, stars: 4, size: 24, effect: 'If the battle opponent is affected by a special condition or has Wait, the battle opponent is knocked out. The battle opponent gains Wait 3.' },
                            { moveName: 'Psycho Shift', moveType: 'Blue', damage: null, size: 20, effect: 'If this Pokémon has a special condition, that condition is applied to its battle opponent and removed from this Pokémon instead.' }
                        ],
                        paralyzed: [
                            { moveName: 'Stillblind', moveType: 'Purple', damage: null, stars: 3, size: 24, effect: 'Attaches an Mp-2 marker to the battle opponent or one opposing Pokémon adjacent to the battle opponent. That Pokémon gains Wait 5' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 4, effect: 'Attack fails' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Paralyzed - cannot use Psychic' },
                            { moveName: 'Psyshock', moveType: 'Purple', damage: null, stars: 4, size: 24, effect: 'If the battle opponent is affected by a special condition or has Wait, the battle opponent is knocked out. The battle opponent gains Wait 3.' },
                            { moveName: 'Psycho Shift', moveType: 'Blue', damage: null, size: 20, effect: 'If this Pokémon has a special condition, that condition is applied to its battle opponent and removed from this Pokémon instead.' }
                        ],
                        burned: [
                            { moveName: 'Stillblind', moveType: 'Purple', damage: null, stars: 3, size: 24, effect: 'Attaches an Mp-2 marker to the battle opponent or one opposing Pokémon adjacent to the battle opponent. That Pokémon gains Wait 5' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 4, effect: 'Attack fails' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Burned - cannot use Psychic' },
                            { moveName: 'Psyshock', moveType: 'Purple', damage: null, stars: 4, size: 24, effect: 'If the battle opponent is affected by a special condition or has Wait, the battle opponent is knocked out. The battle opponent gains Wait 3.' },
                            { moveName: 'Psycho Shift', moveType: 'Blue', damage: null, size: 20, effect: 'If this Pokémon has a special condition, that condition is applied to its battle opponent and removed from this Pokémon instead.' }
                        ],
                        frozen: [
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Frozen - all moves disabled' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 4, effect: 'Frozen - all moves disabled' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Frozen - all moves disabled' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 24, effect: 'Frozen - all moves disabled' },
                            { moveName: 'Miss', moveType: 'Red', damage: null, size: 20, effect: 'Frozen - all moves disabled' }
                        ]
                    },
                    stats: { hp: 110, attack: 95, defense: 75, speed: 85 }
                },
                
                'assault-striker': {
                    id: 'assault-striker',
                    name: 'Assault Striker',
                    rarity: 'Common',
                    mp: 2, // Balanced movement - Attacker role
                    role: 'Attacker',
                    description: 'Aggressive combat robot designed for front-line battles.',
                    image: 'Imag/mascot.png',
                    ability: {
                        name: 'Combat Rush',
                        description: 'Gains +10 damage for each enemy robot knocked out this game.'
                    },
                    wheel: [
                        { moveName: 'Laser Blast', moveType: 'White', damage: 50, size: 32, effect: 'None' },
                        { moveName: 'Plasma Shot', moveType: 'Gold', damage: 60, size: 16, effect: 'Pierces Purple moves' },
                        { moveName: 'Evasion', moveType: 'Blue', damage: null, size: 12, effect: 'Dodge attack' },
                        { moveName: 'Overload', moveType: 'Purple', damage: null, stars: 2, size: 16, effect: 'Burn opponent (-10 damage)' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 20, effect: 'Attack fails' }
                    ],
                    stats: { hp: 90, attack: 75, defense: 55, speed: 65 }
                },
                
                'stealth-infiltrator': {
                    id: 'stealth-infiltrator',
                    name: 'Stealth Infiltrator',
                    rarity: 'Rare',
                    mp: 2, // Balanced movement - Specialist role
                    role: 'Specialist',
                    description: 'Sneaky robot with unique movement and disruption abilities.',
                    image: 'Imag/mascot.png',
                    ability: {
                        name: 'Phase Walk',
                        description: 'Can move through occupied spaces (cannot stop on them).'
                    },
                    wheel: [
                        { moveName: 'Sneak Attack', moveType: 'White', damage: 45, size: 20, effect: 'Cannot be blocked by Blue moves' },
                        { moveName: 'Vanish', moveType: 'Blue', damage: null, size: 24, effect: 'Teleport to any empty space' },
                        { moveName: 'Sabotage', moveType: 'Purple', damage: null, stars: 3, size: 16, effect: 'Opponent spins again, you choose result' },
                        { moveName: 'Smoke Bomb', moveType: 'Purple', damage: null, stars: 1, size: 20, effect: 'All adjacent enemies get Confused' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 16, effect: 'Attack fails' }
                    ],
                    stats: { hp: 75, attack: 60, defense: 45, speed: 85 }
                },
                
                'balanced-guardian': {
                    id: 'balanced-guardian',
                    name: 'Balanced Guardian',
                    rarity: 'Uncommon',
                    mp: 2, // Balanced movement - All-rounder role
                    role: 'All-Rounder',
                    description: 'Versatile robot good in any situation. Perfect for beginners.',
                    image: 'Imag/mascot.png',
                    ability: {
                        name: 'Adaptive Protocol',
                        description: 'Gains +5 to all wheel segments when adjacent to 2+ enemies.'
                    },
                    wheel: [
                        { moveName: 'Standard Shot', moveType: 'White', damage: 55, size: 28, effect: 'None' },
                        { moveName: 'Shield', moveType: 'Blue', damage: null, size: 20, effect: 'Block attack' },
                        { moveName: 'Tactical Strike', moveType: 'Gold', damage: 50, size: 16, effect: 'Reliable damage' },
                        { moveName: 'Disrupt', moveType: 'Purple', damage: null, stars: 2, size: 16, effect: 'Push opponent 1 space' },
                        { moveName: 'Miss', moveType: 'Red', damage: null, size: 16, effect: 'Attack fails' }
                    ],
                    stats: { hp: 95, attack: 65, defense: 65, speed: 60 }
                }
            },
            
            // Get robot by ID
            getRobot(robotId) {
                // Strip '-opp' suffix for opponent robots in debug mode
                const baseId = robotId ? robotId.replace(/-opp$/, '') : robotId;
                return this.robots[baseId] || null;
            },
            
            // Get all robots as array
            getAllRobots() {
                return Object.values(this.robots);
            },
            
            // Add a robot to the database
            addRobot(robot) {
                this.robots[robot.id] = robot;
                console.log(`✅ Added robot: ${robot.name} (${robot.id})`);
            },
            
            // Get robots by role
            getRobotsByRole(role) {
                return this.getAllRobots().filter(robot => robot.role === role);
            },
            
            // Get robots by rarity
            getRobotsByRarity(rarity) {
                return this.getAllRobots().filter(robot => robot.rarity === rarity);
            },
            
            // Calculate total wheel size (should be 96)
            validateWheel(robotId) {
                const robot = this.getRobot(robotId);
                if (!robot) return false;
                
                const totalSize = robot.wheel.reduce((sum, segment) => sum + segment.size, 0);
                return totalSize === 96;
            },
            
            // Get wheel segment by spin result (1-96)
            getWheelResult(robotId, spinValue) {
                const robot = this.getRobot(robotId);
                if (!robot || spinValue < 1 || spinValue > 96) return null;
                
                let currentSum = 0;
                for (const segment of robot.wheel) {
                    currentSum += segment.size;
                    if (spinValue <= currentSum) {
                        return segment;
                    }
                }
                return null; // Should never reach here if wheel is valid
            },
            
            // Simulate a wheel spin
            spinWheel(robotId) {
                const spinValue = Math.floor(Math.random() * 96) + 1;
                const result = this.getWheelResult(robotId, spinValue);
                return {
                    spinValue: spinValue,
                    result: result
                };
            }
        };

        // ==========================================
        // DATA DISK COMBAT SYSTEM
        // ==========================================
        
        const CombatSystem = {
            // Combat Priority Matrix based on DUEL PROTOCOL
            // Blue > Gold > Purple > White > Red
            resolveCombat(attackerMove, defenderMove) {
                console.log('⚔️ Combat Resolution:', attackerMove.moveName, 'vs', defenderMove.moveName);
                
                const attacker = attackerMove.moveType;
                const defender = defenderMove.moveType;
                
                // Handle Miss (Red) cases first
                if (attacker === 'Red' && defender === 'Red') return 'draw';
                if (attacker === 'Red') return 'defender_wins';
                if (defender === 'Red') return 'attacker_wins';
                
                // Handle Blue (Defensive) cases
                if (attacker === 'Blue' && defender === 'Blue') return 'draw';
                if (attacker === 'Blue') return 'attacker_wins';
                if (defender === 'Blue') return 'defender_wins';
                
                // Handle Gold vs Purple (Gold beats Purple)
                if (attacker === 'Gold' && defender === 'Purple') return 'attacker_wins';
                if (attacker === 'Purple' && defender === 'Gold') return 'defender_wins';
                
                // Handle Purple vs White (Purple beats White)
                if (attacker === 'Purple' && defender === 'White') return 'attacker_wins';
                if (attacker === 'White' && defender === 'Purple') return 'defender_wins';
                
                // Handle same-type matchups
                if (attacker === defender) {
                    if (attacker === 'White' || attacker === 'Gold') {
                        // Compare damage values
                        if (attackerMove.damage > defenderMove.damage) return 'attacker_wins';
                        if (attackerMove.damage < defenderMove.damage) return 'defender_wins';
                        return 'draw'; // Equal damage
                    } else if (attacker === 'Purple') {
                        // Compare star ratings
                        if (attackerMove.stars > defenderMove.stars) return 'attacker_wins';
                        if (attackerMove.stars < defenderMove.stars) return 'defender_wins';
                        return 'draw'; // Equal stars
                    }
                }
                
                // Handle White vs Gold (compare damage)
                if ((attacker === 'White' && defender === 'Gold') || (attacker === 'Gold' && defender === 'White')) {
                    if (attackerMove.damage > defenderMove.damage) return 'attacker_wins';
                    if (attackerMove.damage < defenderMove.damage) return 'defender_wins';
                    return 'draw';
                }
                
                console.warn('❓ Unhandled combat case:', attacker, 'vs', defender);
                return 'draw';
            },
            
            // Simulate a battle between two robots
            simulateBattle(attackerRobotId, defenderRobotId) {
                const attackerSpin = RobotDatabase.spinWheel(attackerRobotId);
                const defenderSpin = RobotDatabase.spinWheel(defenderRobotId);
                
                const result = this.resolveCombat(attackerSpin.result, defenderSpin.result);
                
                return {
                    attacker: {
                        robotId: attackerRobotId,
                        robot: RobotDatabase.getRobot(attackerRobotId),
                        spin: attackerSpin
                    },
                    defender: {
                        robotId: defenderRobotId,
                        robot: RobotDatabase.getRobot(defenderRobotId),
                        spin: defenderSpin
                    },
                    result: result,
                    winner: result === 'attacker_wins' ? 'attacker' : result === 'defender_wins' ? 'defender' : null
                };
            },
            
            // Get move type color for UI
            getMoveColor(moveType) {
                const colors = {
                    'Red': '#ff4444',
                    'White': '#ffffff',
                    'Purple': '#8844ff',
                    'Gold': '#ffaa00',
                    'Blue': '#4488ff'
                };
                return colors[moveType] || '#cccccc';
            },
            
            // Format move display text
            formatMoveText(move) {
                let text = move.moveName;
                if (move.damage) text += ` (${move.damage})`;
                if (move.stars) text += ` (${'★'.repeat(move.stars)})`;
                return text;
            }
        };
        
        // ==========================================
        // TEAM SELECTION SYSTEM
        // ==========================================
        
        const TeamManager = {
            selectedTeam: [], // Array of 6 robot IDs
            maxTeamSize: 6,
            
            // Add robot to team
            addToTeam(robotId) {
                if (this.selectedTeam.length >= this.maxTeamSize) {
                    console.log('❌ Team is full! Remove a robot first.');
                    return false;
                }
                
                if (this.selectedTeam.includes(robotId)) {
                    console.log('❌ Robot already in team!');
                    return false;
                }
                
                this.selectedTeam.push(robotId);
                console.log(`✅ Added ${RobotDatabase.getRobot(robotId).name} to team`);
                this.updateTeamDisplay();
                return true;
            },
            
            // Remove robot from team
            removeFromTeam(robotId) {
                const index = this.selectedTeam.indexOf(robotId);
                if (index === -1) {
                    console.log('❌ Robot not in team!');
                    return false;
                }
                
                this.selectedTeam.splice(index, 1);
                console.log(`🗑️ Removed ${RobotDatabase.getRobot(robotId).name} from team`);
                this.updateTeamDisplay();
                return true;
            },
            
            // Clear entire team
            clearTeam() {
                this.selectedTeam = [];
                console.log('🧹 Team cleared');
                this.updateTeamDisplay();
            },
            
            // Check if team is complete
            isTeamComplete() {
                return this.selectedTeam.length === this.maxTeamSize;
            },
            
            // Get team composition analysis
            getTeamAnalysis() {
                const roles = {};
                const rarities = {};
                
                this.selectedTeam.forEach(robotId => {
                    const robot = RobotDatabase.getRobot(robotId);
                    roles[robot.role] = (roles[robot.role] || 0) + 1;
                    rarities[robot.rarity] = (rarities[robot.rarity] || 0) + 1;
                });
                
                return { roles, rarities, size: this.selectedTeam.length };
            },
            
            
            // Auto-fill team with balanced composition
            autoFillTeam() {
                this.clearTeam();
                const allRobots = Object.keys(RobotDatabase.robots);
                
                // Add first 6 robots (in real game, would be more strategic)
                allRobots.slice(0, 6).forEach(robotId => {
                    this.addToTeam(robotId);
                });
                
                console.log('🤖 Auto-filled team with balanced composition');
            },
            
            // UI Integration
            updateTeamDisplay() {
                console.log('👥 Current Team:', this.selectedTeam.map(id => 
                    RobotDatabase.getRobot(id).name
                ));
                console.log('📊 Team Analysis:', this.getTeamAnalysis());
                
                // Update UI if team selection view is active
                if (typeof app !== 'undefined' && app.updateTeamSelectionUI) {
                    app.updateTeamSelectionUI();
                }
            }
        };

        // Initialize app
        app.init();
        
        // Initialize Battle System
        BattleSystem.initializeBattle();
        BattleSystem.initializePhase2();
        
        // Make systems globally accessible for future development
        window.BattleSystem = BattleSystem;
        window.GameBoard = BattleSystem; // Alias for backward compatibility
        window.RobotDatabase = RobotDatabase;
        window.TeamManager = TeamManager;
        window.CombatSystem = CombatSystem;
        window.app = app;

        // Initialize Status Effect Manager when page loads
        window.addEventListener('load', () => {
            BattleSystem.initializeStatusEffectManager();
            console.log('✅ Game systems initialized');
        });

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => console.log('Service Worker registered:', registration))
                    .catch(error => console.log('Service Worker registration failed:', error));
            });
        }
    </script>
</body>
</html>